---
title: 动态规划算法
categories: 
  - 算法与数据结构
  - 算法
abbrlink: 5dc644dc
date: 2019-05-31 13:27:31
tags:
keywords:
description:
---

　　Those who cannot remember the past are condemned to repeat it!——George Santayana

　　那些记不清过去的人注定要重蹈覆辙！——乔治·桑塔耶拿

## 一、基本概念

　　动态规划通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有<font color="red">重叠子问题</font>和<font color="red">最优子结构</font>性质的问题，动态规划方法所耗时间往往远少于朴素解法。

　　动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储（在计算机科学中，记忆化是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案），以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

<!-- more -->

## 二、基本思想与策略

　　基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

　　由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个**二维数组**中。

　　与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

## 三、适用的情况

能采用动态规划求解的问题的一般要具有3个性质：

1. **最优子结构**：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。
2. **无后效性**：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
3. **重叠子问题**：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。 在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题。比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。

动态规划算法的核心是记住已经求过的解，记住求解的方式有两种：

1. **自顶向下的备忘录法**：使用一个n+1大小的数组保存递归过程中的值。fib(n)&rarr;fib(n-1)

2. **自底向上**：先计算子问题，再由子问题计算父问题。自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。fib(1)，fib(2)，...，fib(n-1)&rarr;fib(n)

　　一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好。 

## 四、求解的基本步骤

　　动态规划所处理的问题是<font color="red">一个多阶段决策问题，</font>一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。

> ​    初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
>

1. **划分阶段**：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。

2. **确定状态和状态变量**：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。

3. **确定决策并写出状态转移方程**：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。

4. **寻找边界条件**：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

　　一般，只要解决问题的<font color="red">阶段</font>、<font color="red">状态</font>和<font color="red">状态转移决策</font>确定了，就可以写出<font color="red">状态转移方程（包括边界条件）。</font>

实际应用中可以按以下几个简化的步骤进行设计：

​    （1）分析最优解的性质，并刻画其结构特征。

​    （2）递归的定义最优解。

​    （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值

​    （4）根据计算最优值时得到的信息，构造问题的最优解 

## 五、算法实现的说明

　　动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。

　　使用动态规划求解问题，最重要的就是确定动态规划三要素：

​    （1）问题的阶段 

​    （2）每个阶段的状态

​    （3）从前一个阶段转化到后一个阶段之间的递推关系

　　递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为**递推**可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。

​    确定了动态规划的这三要素，<font color="red">整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，</font>表格需要<font color="red">填写的数据一般对应此问题的在某个阶段某个状态下的最优值</font>（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

​          **<font color="red">f(i,j)=max{f(i-1,j), f(i-1,j-w[i])+P(i,j)}</font>**

## 六、动态规划算法基本框架

```
for(j=1; j<=m; j=j+1) // 第一个阶段
   xn[j] = 初始值;

 for(i=n-1; i>=1; i--)// 其他n-1个阶段
   for(j=1; j>=f(i); j++)//f(i)与i有关的表达式
     xi[j]=j=max（或min){g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};

t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案

print(x1[j1]);

for(i=2; i<=n-1; i=i+1){  
     t = t-xi-1[ji];

     for(j=1; j>=f(i); j=j+1)
        if(t=xi[ji])
             break;
}
```

 ## 七、动态规划经典模型

### 1.线性模型

　　线性模型的是动态规划中最常用的模型，钢条切割问题就是经典的线性模型。这里的线性指的是状态的排布是呈线性的。【例题1】是一个经典的面试题，我们将它作为线性模型的敲门砖。

**【例题1】**在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。

### 2.区间模型

　　区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。

**【例题2】**给定一个长度为n（n <= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 

### 3.背包模型

背包问题是动态规划中一个最典型的问题之一。由于网上有非常详尽的背包讲解，这里只将常用部分抽出来。

**【例题3】**有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。

参照：

[1.五大常用算法之二：动态规划算法](https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html)

[2.算法-动态规划 Dynamic Programming--从菜鸟到老鸟](https://blog.csdn.net/u013309870/article/details/75193592)

