---
title: 十大经典排序算法
categories:
  - 算法与数据结构
  - 排序
abbrlink: 827ca9cd
date: 2019-06-26 16:14:53
tags:
keywords:
description: 十大算法分类、比较类排序和非比较类排序的区别，以及各个算法的复杂度
---

## 一、算法分类

十种常见排序算法可以分为两大类：

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

<!--more-->

![](http://ww1.sinaimg.cn/large/75a4a8eegy1g4ez4emc61j21240uan0x.jpg)

　　常见的**快速排序、归并排序、堆排序、冒泡排序**等属于**比较排序**。**在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。**在**冒泡排序**之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在**归并排序、快速排序**之类的排序中，问题规模通过**分治法**消减为logN次，所以时间复杂度平均**O(nlogn)**。比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，**比较排序适用于一切需要排序的情况。**

　　**计数排序、桶排序、基数排序**则属于**非比较排序**。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度**O(n)**。**非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。**

## 二、算法复杂度

| 排序方法 | 平均情况           | 最好情况             | 最坏情况         | 空间复杂度 | 稳定性 | 排序方式 |
| -------- | ------------------ | -------------------- | ---------------- | ---------- | ------ | -------- |
| 冒泡排序 | O(n<sup>2</sup>)   | O(n)                 | O(n<sup>2</sup>) | O(1)       | 稳定   | 内排序   |
| 选择排序 | O(n<sup>2</sup>)   | O(n<sup>2</sup>)     | O(n<sup>2</sup>) | O(1)       | 不稳定 | 内排序   |
| 插入排序 | O(n<sup>2</sup>)   | O(n)                 | O(n<sup>2</sup>) | O(1)       | 稳定   | 内排序   |
| 快速排序 | O(nlogn)           | O(nlogn)             | O(n<sup>2</sup>) | O(nlogn)   | 不稳定 | 内排序   |
| 堆排序   | O(nlogn)           | O(nlogn)             | O(nlogn)         | O(1)       | 不稳定 | 内排序   |
| 希尔排序 | O(n<sup>1.3</sup>) | O(nlog<sup>2</sup>n) | O(n<sup>2</sup>) | O(1)       | 不稳定 | 内排序   |
| 归并排序 | O(nlogn)           | O(nlogn)             | O(nlogn)         | O(n)       | 稳定   | 外排序   |
|          |                    |                      |                  |            |        |          |
| 计数排序 | O(n+k)             | O(n+k)               | O(n+k)           | O(n+k)     | 稳定   | 外排序   |
| 桶排序   | O(n+k)             | O(n)                 | O(n<sup>2</sup>) | O(n+k)     | 稳定   | 外排序   |
| 基数排序 | O(n*k)             | O(n*k)               | O(n*k)           | O(n+k)     | 稳定   | 外排序   |

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 
- **内排序**：所有排序操作都在内存中完成。
- **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。
- **n**: 数据规模。
- **k**: “桶”的个数。

![](http://ww1.sinaimg.cn/large/75a4a8eegy1g4fh0og0qpj21450ggq8k.jpg)

　　排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。

来源：

[hustcc/JS-Sorting-Algorithm](https://github.com/hustcc/JS-Sorting-Algorithm)

[1.0 十大经典排序算法](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

参考：

[这或许是东半球分析十大排序算法最好的一篇文章](https://mp.weixin.qq.com/s?src=11&timestamp=1561599485&ver=1693&signature=*6rbmo3y62dtwYnAu5rSmtfzwzoyHiznJw*cmy5xDy6HJ1ZCgwmGKdHk2tt8j*liKqEcL7PtD5hpnRF-o4sKJKM0eEFxAFlIus1wKaavTKUA1aNLtl4whHW92qLsksfy&new=1)

[十大经典排序算法最强总结（含JAVA代码实现）](https://www.cnblogs.com/guoyaohua/p/8600214.html)

[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)



<center><font style="font-weight:bold">（完）</font></center>

