<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十五）：线程死锁]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 什么是死锁？通俗的说，死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重影响。用来描述死锁的问题最有名的场景就是“哲学家就餐问题”。哲学家就餐问题可以这样表述：假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事之一：吃饭或者思考。吃东西的时候他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为只用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐。哲学家从来不交谈，这就跟危险，可能产生死锁，每个哲学家都拿着左手的餐叉永远等右边的餐叉（或者相反）…. 死锁产生的必要条件 互斥条件：进程对锁分配的资源进行排他性使用 请求和保持条件：线程已经保持了一个资源，但是又提出了其他请求，而该资源已被其他线程占用 不剥夺条件：在使用时不能被剥夺，只能自己用完释放 环路等待条件：资源调用是一个环形的链 死锁示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Slf4jpublic class DeadLock implements Runnable &#123; public int flag = 1; //静态对象是类的所有对象共享的 private static Object o1 = new Object(), o2 = new Object(); @Override public void run() &#123; log.info(&quot;flag:&#123;&#125;&quot;, flag); if (flag == 1) &#123; synchronized (o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; log.info(&quot;1&quot;); &#125; &#125; &#125; if (flag == 0) &#123; synchronized (o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; log.info(&quot;0&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DeadLock td1 = new DeadLock(); DeadLock td2 = new DeadLock(); td1.flag = 1; td2.flag = 0; //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。 //td2的run()可能在td1的run()之前运行 new Thread(td1).start(); new Thread(td2).start(); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 上述代码出现死锁原因： 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒 td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定； td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定； td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 确认死锁在真实的环境中，我们发现程序无法执行，并且CPU占用为0，这样就有理由怀疑产生了死锁，但是光怀疑是不行的，我们需要一个实际的验证方法。接下来我们使用jdk提供的工具来检测是否真正发生了死锁。运行上述的代码，并在windows系统中使用cmd进入控制台，输入以下命令： 1jps1 可见控制台输出：我们上边运行的类的类名以及对应的进程ID接下来使用命令获取进程对应线程的堆栈信息： 1jstack 9284 1 分析堆栈信息（提取有用的部分）两个线程都进行了加锁操作（如上图）系统发现了一个Java-level的线程死锁。ok，确认无疑是发生了死锁现象。 避免死锁 注意加锁顺序（这个很好理解，就像上边的例子） 加锁时限（超过时限放弃加锁）实现方式–使用重入锁。关于重入锁可以见我之前的博客：并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock 死锁检测（较难，就像分析上边的线程情况） 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80233899]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十四）：线程池 Executor]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 new Thread的弊端 线程池的好处 线程池类图 线程池核心类-ThreadPoolExecutor 使用Executor创建线程池 new Thread的弊端 每次new Thread 新建对象，性能差 线程缺乏统一管理，可能无限制的新建线程，相互竞争，可能占用过多的系统资源导致死机或者OOM（out of memory 内存溢出），这种问题的原因不是因为单纯的new一个Thread，而是可能因为程序的bug或者设计上的缺陷导致不断new Thread造成的。 缺少更多功能，如更多执行、定期执行、线程中断。 线程池的好处 重用存在的线程，减少对象创建、消亡的开销，性能好 可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。 提供定时执行、定期执行、单线程、并发数控制等功能。 线程池类图 在线程池的类图中，我们最常使用的是最下边的Executors,用它来创建线程池使用线程。那么在上边的类图中，包含了一个Executor框架，它是一个根据一组执行策略的调用调度执行和控制异步任务的框架，目的是提供一种将任务提交与任务如何运行分离开的机制。它包含了三个executor接口： Executor:运行新任务的简单接口 ExecutorService：扩展了Executor，添加了用来管理执行器生命周期和任务生命周期的方法 ScheduleExcutorService：扩展了ExecutorService，支持Future和定期执行任务 线程池核心类-ThreadPoolExecutor参数说明：ThreadPoolExecutor一共有七个参数，这七个参数配合起来，构成了线程池强大的功能。 corePoolSize：核心线程数量 maximumPoolSize：线程最大线程数 workQueue：阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响 当我们提交一个新的任务到线程池，线程池会根据当前池中正在运行的线程数量来决定该任务的处理方式。处理方式有三种：1、直接切换（SynchronusQueue）2、无界队列（LinkedBlockingQueue）能够创建的最大线程数为corePoolSize,这时maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是运行状态的时候，新的任务提交就会放入等待队列中。3、有界队列（ArrayBlockingQueue）最大maximumPoolSize，能够降低资源消耗，但是这种方式使得线程池对线程调度变的更困难。因为线程池与队列容量都是有限的。所以想让线程池的吞吐率和处理任务达到一个合理的范围，又想使我们的线程调度相对简单，并且还尽可能降低资源的消耗，我们就需要合理的限制这两个数量分配技巧： [如果想降低资源的消耗包括降低cpu使用率、操作系统资源的消耗、上下文切换的开销等等，可以设置一个较大的队列容量和较小的线程池容量，这样会降低线程池的吞吐量。如果我们提交的任务经常发生阻塞，我们可以调整maximumPoolSize。如果我们的队列容量较小，我们需要把线程池大小设置的大一些，这样cpu的使用率相对来说会高一些。但是如果线程池的容量设置的过大，提高任务的数量过多的时候，并发量会增加，那么线程之间的调度就是一个需要考虑的问题。这样反而可能会降低处理任务的吞吐量。] keepAliveTime：线程没有任务执行时最多保持多久时间终止（当线程中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交核心线程外的线程不会立即销毁，而是等待，直到超过keepAliveTime） unit：keepAliveTime的时间单位 threadFactory：线程工厂，用来创建线程，有一个默认的工场来创建线程，这样新创建出来的线程有相同的优先级，是非守护线程、设置好了名称） rejectHandler：当拒绝处理任务时(阻塞队列满)的策略（AbortPolicy默认策略直接抛出异常、CallerRunsPolicy用调用者所在的线程执行任务、DiscardOldestPolicy丢弃队列中最靠前的任务并执行当前任务、DiscardPolicy直接丢弃当前任务） corePoolSize、maximumPoolSize、workQueue 三者关系：如果运行的线程数小于corePoolSize的时候，直接创建新线程来处理任务。即使线程池中的其他线程是空闲的。如果运行中的线程数大于corePoolSize且小于maximumPoolSize时，那么只有当workQueue满的时候才创建新的线程去处理任务。如果corePoolSize与maximumPoolSize是相同的，那么创建的线程池大小是固定的。这时有新任务提交，当workQueue未满时，就把请求放入workQueue中。等待空线程从workQueue取出任务。如果workQueue此时也满了，那么就使用另外的拒绝策略参数去执行拒绝策略。 初始化方法：由七个参数组合成四个初始化方法 其他方法： 序号 方法名 描述 1 execute() 提交任务，交给线程池执行 2 submit() 提交任务，能够返回执行结果 execute+Future 3 shutdown() 关闭线程池，等待任务都执行完 4 shutdownNow() 关闭线程池，不等待任务执行完 5 getTaskCount() 线程池已执行和未执行的任务总数 6 getCompleteTaskCount() 已完成的任务数量 7 getPoolSize() 线程池当前的线程数量 8 getActiveCount() 当前线程池中正在执行任务的线程数量 线程池生命周期： running：能接受新提交的任务，也能处理阻塞队列中的任务 shutdown：不能处理新的任务，但是能继续处理阻塞队列中任务 stop：不能接收新的任务，也不处理队列中的任务 tidying：如果所有的任务都已经终止了，这时有效线程数为0 terminated：最终状态 使用Executor创建线程池使用Executor可以创建四种线程池：分别对应上边提到的四种线程池初始化方法 1、Executors.newCachedThreadPool创建一个可缓存的线程池，如果线程池的长度超过了处理的需要，可以灵活回收空闲线程。如果没有可回收的就新建线程。 1234567891011121314151617181920//源码：public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;123456//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 值得注意的一点是，newCachedThreadPool的返回值是ExecutorService类型，该类型只包含基础的线程池方法，但却不包含线程监控相关方法，因此在使用返回值为ExecutorService的线程池类型创建新线程时要考虑到具体情况。 2、newFixedThreadPool定长线程池，可以线程现成的最大并发数，超出在队列等待 1234567891011121314151617181920//源码：public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;123456//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 3、newSingleThreadExecutor单线程化的线程池，用唯一的一个共用线程执行任务，保证所有任务按指定顺序执行（FIFO、优先级…） 123456789101112131415161718192021//源码public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;1234567//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 4、newScheduledThreadPool定长线程池，支持定时和周期任务执行 1234567891011121314151617181920//源码：public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,//此处super指的是ThreadPoolExecutor new DelayedWorkQueue());&#125;12345678//基础使用方法：public static void main(String[] args) &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1); executorService.schedule(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125; &#125;, 3, TimeUnit.SECONDS);//延迟3秒执行 executorService.shutdown();&#125;123456789101112 ScheduledExecutorService提供了三种方法可以使用：scheduleAtFixedRate：以指定的速率执行任务scheduleWithFixedDelay：以指定的延迟执行任务举例： 123456executorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125;&#125;, 1, 3, TimeUnit.SECONDS);//延迟一秒后每隔3秒执行123456 小扩展：延迟执行任务的操作，java中还有Timer类同样可以实现 1234567Timer timer = new Timer();timer.schedule(new TimerTask() &#123; @Override public void run() &#123; log.warn(&quot;timer run&quot;); &#125;&#125;, new Date(), 5 * 1000); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80202114]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十三）：并发容器J.U.C -- 组件FutureTask、ForkJoin、BlockingQueue]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8J-U-C-%E7%BB%84%E4%BB%B6FutureTask%E3%80%81ForkJoin%E3%80%81BlockingQueue%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 FutureTask Runnable与Callable对比 Future接口 FutureTask ForkJoin 局限性： 框架核心： 使用方式：（模拟加和运算） BlockingQueue阻塞队列 阻塞情况： 四套方法： 实现类： FutureTaskFutureTask是J.U.C中的类，是一个可删除的异步计算类。这个类提供了Future接口的的基本实现，使用相关方法启动和取消计算，查询计算是否完成，并检索计算结果。只有在计算完成时才能使用get方法检索结果;如果计算尚未完成，get方法将会阻塞。一旦计算完成，计算就不能重新启动或取消(除非使用runAndReset方法调用计算)。 Runnable与Callable对比通常实现一个线程我们会使用继承Thread的方式或者实现Runnable接口，这两种方式有一个共同的缺陷就是在执行完任务之后无法获取执行结果。从Java1.5之后就提供了Callable与Future，这两个接口就可以实现获取任务执行结果。 Runnable接口：代码非常简单，只有一个方法run 123public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125;123 Callable泛型接口：有泛型参数，提供了一个call方法，执行后可返回传入的泛型参数类型的结果。 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125;123 Future接口Future接口提供了一系列方法用于控制线程执行计算，如下： 12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning);//取消任务 boolean isCancelled();//是否被取消 boolean isDone();//计算是否完成 V get() throws InterruptedException, ExecutionException;//获取计算结果，在执行过程中任务被阻塞 V get(long timeout, TimeUnit unit)//timeout等待时间、unit时间单位 throws InterruptedException, ExecutionException, TimeoutException;&#125;12345678 使用方法： 1234567891011121314151617181920public class FutureExample &#123; static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable());//线程池提交任务 log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = future.get();//获取不到一直阻塞 log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125;1234567891011121314151617181920 运行结果：阻塞效果 FutureTaskFuture实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。 1234567public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; ...&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125;1234567 FutureTask支持两种参数类型，Callable和Runnable，在使用Runnable 时，还可以多指定一个返回结果类型。 1234567891011public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;1234567891011 使用方法： 12345678910111213141516171819public class FutureTaskExample &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125;); new Thread(futureTask).start(); log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = futureTask.get(); log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125;12345678910111213141516171819 运行结果： ForkJoinForkJoin是Java7提供的一个并行执行任务的框架，是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架。主要采用的是工作窃取算法，工作窃取算法是指某个线程从其他队列里窃取任务来执行。在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用双端队列来实现工作窃取算法。被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。 局限性：1、任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了。2、我们所拆分的任务不应该去执行IO操作，如读和写数据文件。3、任务不能抛出检查异常。必须通过必要的代码来处理他们。 框架核心：核心有两个类：ForkJoinPool | ForkJoinTaskForkJoinPool：负责来做实现，包括工作窃取算法、管理工作线程和提供关于任务的状态以及他们的执行信息。ForkJoinTask:提供在任务中执行fork和join的机制。 使用方式：（模拟加和运算）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Slf4jpublic class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123; public static final int threshold = 2;//设定不大于两个数相加就直接for循环，不适用框架 private int start; private int end; public ForkJoinTaskExample(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; //如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= threshold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算（分裂算法，可依情况调优） int middle = (start + end) / 2; ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle); ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待任务执行结束合并其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkjoinPool = new ForkJoinPool(); //生成一个计算任务，计算1+2+3+4...100 ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100); //执行一个任务 Future&lt;Integer&gt; result = forkjoinPool.submit(task); try &#123; log.info(&quot;result:&#123;&#125;&quot;, result.get()); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 BlockingQueue阻塞队列主要应用场景：生产者消费者模型，是线程安全的 阻塞情况：1、当队列满了进行入队操作2、当队列空了的时候进行出队列操作 四套方法：BlockingQueue提供了四套方法，分别来进行插入、移除、检查。每套方法在不能立刻执行时都有不同的反应。 Throws Exceptions ：如果不能立即执行就抛出异常。 Special Value：如果不能立即执行就返回一个特殊的值。 Blocks：如果不能立即执行就阻塞 Times Out：如果不能立即执行就阻塞一段时间，如果过了设定时间还没有被执行，则返回一个值 实现类： ArrayBlockingQueue：它是一个有界的阻塞队列，内部实现是数组，初始化时指定容量大小，一旦指定大小就不能再变。采用FIFO方式存储元素。 DelayQueue：阻塞内部元素，内部元素必须实现Delayed接口，Delayed接口又继承了Comparable接口，原因在于DelayQueue内部元素需要排序，一般情况按过期时间优先级排序。 123public interface Delayed extends Comparable&lt;Delayed&gt; &#123; long getDelay(TimeUnit unit);&#125;123 DalayQueue内部采用PriorityQueue与ReentrantLock实现。 1234567public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; private final transient ReentrantLock lock = new ReentrantLock(); private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;(); ...&#125;1234567 LinkedBlockingQueue：大小配置可选，如果初始化时指定了大小，那么它就是有边界的。不指定就无边界（最大整型值）。内部实现是链表，采用FIFO形式保存数据。 123public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);//不指定大小，无边界采用默认值，最大整型值&#125;123 PriorityBlockingQueue:带优先级的阻塞队列。无边界队列，允许插入null。插入的对象必须实现Comparator接口，队列优先级的排序规则就是按照我们对Comparable接口的实现来指定的。我们可以从PriorityBlockingQueue中获取一个迭代器，但这个迭代器并不保证能按照优先级的顺序进行迭代。 12345678910111213141516171819202122232425public boolean add(E e) &#123;//添加方法 return offer(e);&#125;public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator;//必须实现Comparator接口 if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true;&#125;12345678910111213141516171819202122232425 SynchronusQueue：只能插入一个元素，同步队列，无界非缓存队列，不存储元素。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80168980]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十二）：并发容器J.U.C -- AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8J-U-C-AQS%E7%BB%84%E4%BB%B6-%E9%94%81%EF%BC%9AReentrantLock%E3%80%81ReentrantReadWriteLock%E3%80%81StempedLock%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 ReentrantLock ReentrantLock与synchronized的区别 ReentrantLock独有的功能 要放弃synchronized？ 如何使用ReentrantLock？ 内置函数（部分） Condition的使用 读写锁：ReentrantReadWriteLock读写锁 票据锁：StempedLock 如何选择锁？ ReentrantLockjava中有两类锁，一类是Synchronized，而另一类就是J.U.C中提供的锁。ReentrantLock与Synchronized都是可重入锁，本质上都是lock与unlock的操作。接下来我们介绍三种J.U.C中的锁，其中 ReentrantLock使用synchronized与之比对介绍。 ReentrantLock与synchronized的区别 可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁 锁的实现：synchronized是基于JVM实现的（用户很难见到，无法了解其实现），ReentrantLock是JDK实现的。 性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自选锁）后，二者的性能差别不大，官方推荐synchronized（写法更容易、在优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞） 功能区别：（1）便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。（2）锁的细粒度和灵活度，ReentrantLock优于synchronized ReentrantLock独有的功能 可以指定是公平锁还是非公平锁，sync只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁） 提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。 提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现，这种机制 ReentrantLock是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。 要放弃synchronized？从上边的介绍，看上去ReentrantLock不仅拥有synchronized的所有功能，而且有一些功能synchronized无法实现的特性。性能方面，ReentrantLock也不比synchronized差，那么到底我们要不要放弃使用synchronized呢？答案是不要这样做。 J.U.C包中的锁定类是用于高级情况和高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需要，或这有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized。相比较这些高级的锁定类，synchronized还是有一些优势的，比如synchronized不可能忘记释放锁。还有当JVM使用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。 如何使用ReentrantLock？1234567891011//创建锁：使用Lock对象声明，使用ReentrantLock接口创建private final static Lock lock = new ReentrantLock();//使用锁：在需要被加锁的方法中使用private static void add() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125;&#125;1234567891011 分析一下源码： 123456789//初始化方面：//在new ReentrantLock的时候默认给了一个不公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125;//也可以加参数来初始化指定使用公平锁还是不公平锁public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125;123456789 内置函数（部分）基础特性： tryLock()：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。 tryLock(long timeout, TimeUnit unit)：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。 lockInterruptbily：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。 isLocked：查询此锁定是否由任意线程保持 isHeldByCurrentThread：查询当前线程是否保持锁定状态。 isFair：判断是不是公平锁… Condition相关特性： hasQueuedThread(Thread)：查询指定线程是否在等待获取此锁定 hasQueuedThreads()：查询是否有线程在等待获取此锁定 getHoldCount()：查询当前线程保持锁定的个数，也就是调用Lock方法的个数… Condition的使用Condition可以非常灵活的操作线程的唤醒，下面是一个线程等待与唤醒的例子，其中用1234序号标出了日志输出顺序 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition();//创建condition //线程1 new Thread(() -&gt; &#123; try &#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;); // 1 condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;); // 4 reentrantLock.unlock(); &#125;).start(); //线程2 new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get lock&quot;); // 2 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; condition.signalAll();//发送信号 log.info(&quot;send signal&quot;); // 3 reentrantLock.unlock(); &#125;).start();&#125;1234567891011121314151617181920212223242526272829 （这里对等待队列不熟悉的，请回顾我的上一篇文章中讲解的AQS等待队列：高并发探索（十一）：并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier）输出过程讲解： 1、线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出1号log2、接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中3、线程2因为线程1释放了锁，拿到了锁，输出2号log4、线程2执行condition.signalAll()发送信号，输出3号log5、condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列,这时线程1并没有被唤醒。6、线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程17、线程1继续执行，输出4号log，并进行unlock操作。 读写锁：ReentrantReadWriteLock读写锁在没有任何读写锁的时候才可以取得写入锁(悲观读取，容易写线程饥饿)，也就是说如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会造成等待获取写锁的线程饥饿。平时使用的场景并不多。 12345678910111213141516171819202122232425262728public class LockExample3 &#123; private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;(); private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock readLock = lock.readLock();//读锁 private final Lock writeLock = lock.writeLock();//写锁 //加读锁 public Data get(String key) &#123; readLock.lock(); try &#123; return map.get(key); &#125; finally &#123; readLock.unlock(); &#125; &#125; //加写锁 public Data put(String key, Data value) &#123; writeLock.lock(); try &#123; return map.put(key, value); &#125; finally &#123; writeLock.unlock(); &#125; &#125; class Data &#123;&#125;&#125;12345678910111213141516171819202122232425262728 票据锁：StempedLock它控制锁有三种模式（写、读、乐观读）。一个StempedLock的状态是由版本和模式两个部分组成。锁获取方法返回一个数字作为票据（stamp），他用相应的锁状态表示并控制相关的访问。数字0表示没有写锁被锁写访问，在读锁上分为悲观锁和乐观锁。 乐观读：如果读的操作很多写的很少，我们可以乐观的认为读的操作与写的操作同时发生的情况很少，因此不悲观的使用完全的读取锁定。程序可以查看读取资料之后是否遭到写入资料的变更，再采取之后的措施。 如何使用？ 1234567891011//定义private final static StampedLock lock = new StampedLock();//需要上锁的方法private static void add() &#123; long stamp = lock.writeLock(); try &#123; count++; &#125; finally &#123; lock.unlock(stamp); &#125;&#125;1234567891011 分析一下源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Point &#123; private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) &#123; long stamp = sl.writeLock(); try &#123; x += deltaX; y += deltaY; &#125; finally &#123; sl.unlockWrite(stamp); &#125; &#125; //下面看看乐观读锁案例 double distanceFromOrigin() &#123; // A read-only method long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁 double currentX = x, currentY = y; //将两个字段读入本地局部变量 if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？ stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁 try &#123; currentX = x; // 将两个字段读入本地局部变量 currentY = y; // 将两个字段读入本地局部变量 &#125; finally &#123; sl.unlockRead(stamp); &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; //下面是悲观读锁案例 void moveIfAtOrigin(double newX, double newY) &#123; // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合 long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁 if (ws != 0L) &#123; //这是确认转为写锁是否成功 stamp = ws; //如果成功 替换票据 x = newX; //进行状态改变 y = newY; //进行状态改变 break; &#125; else &#123; //如果不能成功转换为写锁 sl.unlockRead(stamp); //我们显式释放读锁 stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试 &#125; &#125; &#125; finally &#123; sl.unlock(stamp); //释放读锁或写锁 &#125; &#125; &#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 如何选择锁？1、当只有少量竞争者，使用synchronized2、竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock3、synchronized不会造成死锁，jvm会自动释放死锁。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80058631]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十一）：并发容器J.U.C -- AQS组件CountDownLatch、Semaphore、CyclicBarrier]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8J-U-C-AQS%E7%BB%84%E4%BB%B6CountDownLatch%E3%80%81Semaphore%E3%80%81CyclicBarrier%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 AQS简介 AQS设计思想 AQS的大致实现思路 AQS组件：CountDownLatch AQS组件：Semaphore AQS组件：CyclicBarrier AQS简介AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向列表。Sync queue：同步队列，是一个双向列表。包括head节点和tail节点。head节点主要用作后续的调度。Condition queue：非必须，单向列表。当程序中存在cindition的时候才会存在此列表。 AQS设计思想 使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。 利用int类型标识状态。在AQS类中有一个叫做state的成员变量 1234/** * The synchronization state. */private volatile int state;1234 基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。 继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。 可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。 AQS的大致实现思路AQS内部维护了一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。 AQS组件：CountDownLatch 通过一个计数来保证线程是否需要被阻塞。实现一个或多个线程等待其他线程执行的场景。 我们定义一个CountDownLatch，通过给定的计数器为其初始化，该计数器是原子性操作，保证同时只有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态。只有其他线程调用countDown方法（每次使计数器-1），使计数器归零才能继续执行。 123456789101112131415final CountDownLatch countDownLatch = new CountDownLatch(threadCount);for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; test(threadNum); //需要被等待的线程执行的方法 &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;);&#125;countDownLatch.await();123456789101112131415 CountDownLatch的await方法还有重载形式，可以设置等待的时间，如果超过此时间，计数器还未清零，则不继续等待： 1234countDownLatch.await(10, TimeUnit.MILLISECONDS);//参数1：等待的时间长度//参数2：等待的时间单位1234 AQS组件：Semaphore 用于保证同一时间并发访问线程的数目。 信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。Semaphore可以很容易控制系统中某个资源被同时访问的线程个数。 在数据结构中我们学过链表，链表正常是可以保存无限个节点的，而Semaphore可以实现有限大小的列表。 使用场景：仅能提供有限访问的资源。比如数据库连接。 Semaphore使用acquire方法和release方法来实现控制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 1、普通调用 */try &#123; semaphore.acquire(); // 获取一个许可 test();//需要并发控制的内容 semaphore.release(); // 释放一个许可&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/** * 2、同时获取多个许可，同时释放多个许可 */ try &#123; semaphore.acquire(2); test(); semaphore.release(2);&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/* * 3、尝试获取许可，获取不到不执行 */ try &#123; if (semaphore.tryAcquire()) &#123; test(threadNum); semaphore.release(); &#125; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/* * 4、尝试获取许可一段时间，获取不到不执行 * 参数1：等待时间长度 参数2：等待时间单位 */try &#123; if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) &#123; test(threadNum); semaphore.release(); &#125;&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 AQS组件：CyclicBarrier 也是一个同步辅助类，它允许一组线程相互等待，直到到达某个公共的屏障点（循环屏障） 通过它可以完成多个线程之间相互等待，只有每个线程都准备就绪后才能继续往下执行后面的操作。 每当有一个线程执行了await方法，计数器就会执行+1操作，待计数器达到预定的值，所有的线程再同时继续执行。由于计数器释放之后可以重用（reset方法），所以称之为循环屏障。 与CountDownLatch区别：1、计数器可重复用2、描述一个或多个线程等待其他线程的关系/多个线程相互等待 123456789101112131415161718192021222324252627282930313233343536373839404142//公共线程循环调用方法private static CyclicBarrier barrier = new CyclicBarrier(5);public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown();&#125;//使用方法1：每个线程都持续等待private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;&#123;&#125; is ready&quot;, threadNum); barrier.await(); log.info(&quot;&#123;&#125; continue&quot;, threadNum);&#125;//使用方法2：每个线程只等待一段时间private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); try &#123; barrier.await(2000, TimeUnit.MILLISECONDS); &#125; catch (InterruptedException | BrokenBarrierException | TimeoutException e) &#123; log.warn(&quot;BarrierException&quot;, e); &#125;&#125;//使用方法3：在初始化的时候设置runnable，当线程达到屏障时优先执行runnableprivate static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123; log.info(&quot;callback is running&quot;);&#125;); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80054133]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十）：HashMap与ConcurrentHashMap]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9AHashMap%E4%B8%8EConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 概述 HashMap （1）初始化方法 （2）寻址方式 （3）HashMap的线程不安全原因一：死循环 （4）HashMap的线程不安全原因二：fail-fast ConcurrentHashMap [（1）结构 Java7与Java8不同] 对比 概述在上一节我们简略提到了ConcurrentHashMap是HashMap的线程安全类，那么这两个类的具体实现是怎样的呢？我们来了解一下。 HashMap（1）初始化方法HashMap的实现方式是：数组+链表 的形式。在HashMap中有两个参数会影响HashMap的性能：初始容量/加载因子 初始容量：Hash表中桶的数量加载因子：是Hash表在自动增加之前可以达到多满的一个尺度。 HashMap在类中定义了这两个参数: 1234//初始容量，默认16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //加载因子，默认0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;1234 这两个参数的作用是：当Hash表中的条目数量超过了加载因子与当前容量的乘积，将会调用resize()进行扩容，将容量翻倍。这两个参数在初始化HashMap的时候可以进行设置：可以单独指定初始容量，也可以同时设置 （2）寻址方式对于一个新插入的数据或者要读取的数据，HashMap将key按一定规则计算出hash值，并对数组长度进行取模结果作为在数组中查找的index。由于在计算机中取模的代价远远高于位操作的代价，因此HashMap要求数组的长度必须为2的N次方。此时它将key的hash值对2的n-1次方进行与运算，等同于取模运算。HashMap并不要求用户一定要设置一个2的N次方的初始化大小，它本身内部会通过运算（tableSizeFor方法）确定一个合理的符合2的N次方的大小去设置。 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;123456789 （3）HashMap的线程不安全原因一：死循环原因在于HashMap在多线程情况下，执行resize()进行扩容时容易造成死循环。扩容思路为它要创建一个大小为原来两倍的数组，保证新的容量仍为2的N次方，从而保证上述寻址方式仍然适用。扩容后将原来的数组从新插入到新的数组中。这个过程称为reHash。 【单线程下的reHash】 扩容前：我们的HashMap初始容量为2，加载因子为1，需要向其中存入3个key，分别为5、9、11，放入第三个元素11的时候就涉及到了扩容。 第一步：先创建一个二倍大小的数组，接下来把原来数组中的元素reHash到新的数组中，5插入新的数组，没有问题。 第二步：将9插入到新的数组中，经过Hash计算，插入到5的后面。 第三步：将11经过Hash插入到index为3的数组节点中。 单线程reHash完全没有问题。 【多线程下的reHash】 我们假设有两个线程同时执行了put操作，并同时触发了reHash的操作，图示的上层的线程1，下层是线程2。 线程1某一时刻执行完扩容，准备将key为5的元素的next指针指向9，由于线程调度分配的时间片被用完而停在了这一步操作 线程2在这一刻执行reHash操作并执行完数据迁移的整个操作。 接下来线程1被唤醒继续操作。 执行上一轮的剩余部分，在处理key为5的元素时，将此key放在我们线程1申请的数组的索引1位置的链表的首部。理想状态是（线程1数组索引1）—&gt; (Key=5) —&gt; null 接着处理Key为9的元素，将key为9的元素插入在（索引1）与（key=5）之间，理想状态：（线程1数组索引1）—&gt; （Key=9）—&gt; （Key=5）—&gt;null 但是在处理完key为9的元素之后按理说应该结束了，但是由于线程2已经处理过了key=9与key=5的元素，即真实情况为（线程2数组索引1 —&gt;（key=9）—&gt; （key=5）—&gt; null）|（线程1数组索引1 —&gt; (key=9)—&gt; （key=5）—&gt; null），这时让线程1误以为key=9后面的key=5是从原数组还没有进行数组迁移的，接着又处理key=5。尝试将key=5放在k=9的前边，所以key=9与key=5之间就出现了一个循环。不断的被处理，交换顺序。 key = 11的元素是无法插入到新数组中的。一旦我们去从新的数组中获取值得时候，就会出现死循环。 （4）HashMap的线程不安全原因二：fail-fast如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast。在每一次对HashMap进行修改的时候，都会变动类中的modCount域，即modCount变量的值。源码中是这样实现的： 12345678910111213141516abstract class HashIterator &#123; ... int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; ...&#125;12345678910111213141516 在每次迭代的过程中，都会判断modCount跟expectedModCount是否相等，如果不相等代表有人修改HashMap。源码： 123456789101112final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e;&#125;123456789101112 解决办法：可以使用Collections的synchronizedMap方法构造一个同步的map，或者直接使用线程安全的ConcurrentHashMap来保证不会出现fail-fast策略。 ConcurrentHashMap（1）结构 [Java7与Java8不同] Java7里面的ConcurrentHashMap的底层结构仍然是数组和链表，与HashMap不同的是ConcurrentHashMap的最外层不是一个大的数组，而是一个Segment数组。每个Segment包含一个与HashMap结构差不多的链表数组。 当我们读取某个Key的时候它先取出key的Hash值，并将Hash值得高sshift位与Segment的个数取模，决定key属于哪个Segment。接着像HashMap一样操作Segment。 为了保证不同的Hash值保存到不同的Segment中，ConcurrentHashMap对Hash值也做了专门的优化。 Segment继承自J.U.C里的ReetrantLock，所以可以很方便的对Segment进行上锁。即分段锁。 Java8废弃了Java7中ConcurrentHashMap中分段锁的方案，并且不使用Segment，转为使用大的数组。同时为了提高Hash碰撞下的寻址做了性能优化。 Java8在列表的长度超过了一定的值（默认8）时，将链表转为红黑树实现。寻址的复杂度从O(n)转换为Olog(n)。 对比 HashMap非线程安全、ConcurrentHashMap线程安全 HashMap允许Key与Value为空，ConcurrentHashMap不允许 HashMap不允许通过迭代器遍历的同时修改，ConcurrentHashMap允许。并且更新可见 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79978855]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（九）：并发容器 J.U.C - 线程安全的集合与Map]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-J-U-C-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%8EMap%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 概述 ArrayList –&gt; CopyOnWriteArrayList HashSet –&gt; CopyOnWriteArraySet TreeSet –&gt; ConcurrentSkipListSet HashMap –&gt; ConcurrentHashMap TreeMap –&gt; ConcurrentSkipListMap 安全共享对象策略 概述Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即Java.util.concurrency。上一节我们介绍了ArrayList、HashMap、HashSet对应的同步容器保证其线程安全，这节我们介绍一下其对应的并发容器。 ArrayList –&gt; CopyOnWriteArrayListCopyOnWriteArrayList 写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁 缺点：1.写操作时复制消耗内存，如果元素比较多时候，容易导致young gc 和full gc。2.不能用于实时读的场景.由于复制和add操作等需要时间，故读取时可能读到旧值。能做到最终一致性，但无法满足实时性的要求，更适合读多写少的场景。如果无法知道数组有多大，或者add,set操作有多少，慎用此类,在大量的复制副本的过程中很容易出错。 设计思想：1.读写分离2.最终一致性3.使用时另外开辟空间，防止并发冲突 源码分析 12345678910111213141516171819202122232425262728293031323334//构造方法public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements;//使用对象数组来承载数据 if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements);&#125;//添加数据方法public boolean add(E e) &#123; final ReentrantLock lock = this.lock;//使用重入锁，保证线程安全 lock.lock(); try &#123; Object[] elements = getArray();//获取当前数组数据 int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//复制当前数组并且扩容+1 newElements[len] = e;//将要添加的数据放入新数组 setArray(newElements);//将原来的数组指向新的数组 return true; &#125; finally &#123; lock.unlock(); &#125;&#125;//获取数据方法，与普通的get没什么差别private E get(Object[] a, int index) &#123; return (E) a[index];&#125;12345678910111213141516171819202122232425262728293031323334 HashSet –&gt; CopyOnWriteArraySet 它是线程安全的，底层实现使用的是CopyOnWriteArrayList，因此它也适用于大小很小的set集合，只读操作远大于可变操作。因为他需要copy整个数组，所以包括add、remove、set它的开销相对于大一些。 迭代器不支持可变的remove操作。使用迭代器遍历的时候速度很快，而且不会与其他线程发生冲突。 源码分析： 1234567891011121314151617181920212223242526272829//构造方法public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();//底层使用CopyOnWriteArrayList&#125;//添加元素方法，基本实现原理与CopyOnWriteArrayList相同private boolean addIfAbsent(E e, Object[] snapshot) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) &#123;//添加了元素去重操作 // Optimize for lost race to another addXXX operation int common = Math.min(snapshot.length, len); for (int i = 0; i &lt; common; i++) if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) return false; if (indexOf(e, current, common, len) &gt;= 0) return false; &#125; Object[] newElements = Arrays.copyOf(current, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;1234567891011121314151617181920212223242526272829 TreeSet –&gt; ConcurrentSkipListSet它是JDK6新增的类，同TreeSet一样支持自然排序，并且可以在构造的时候自己定义比较器。 同其他set集合，是基于map集合的（基于ConcurrentSkipListMap），在多线程环境下，里面的contains、add、remove操作都是线程安全的。 多个线程可以安全的并发的执行插入、移除、和访问操作。但是对于批量操作addAll、removeAll、retainAll和containsAll并不能保证以原子方式执行，原因是addAll、removeAll、retainAll底层调用的还是contains、add、remove方法，只能保证每一次的执行是原子性的，代表在单一执行操纵时不会被打断，但是不能保证每一次批量操作都不会被打断。在使用批量操作时，还是需要手动加上同步操作的。 不允许使用null元素的，它无法可靠的将参数及返回值与不存在的元素区分开来。 源码分析： 1234//构造方法public ConcurrentSkipListSet() &#123; m = new ConcurrentSkipListMap&lt;E,Object&gt;();//使用ConcurrentSkipListMap实现&#125;1234 HashMap –&gt; ConcurrentHashMap 不允许空值，在实际的应用中除了少数的插入操作和删除操作外，绝大多数我们使用map都是读取操作。而且读操作大多数都是成功的。基于这个前提，它针对读操作做了大量的优化。因此这个类在高并发环境下有特别好的表现。 ConcurrentHashMap作为Concurrent一族，其有着高效地并发操作，相比Hashtable的笨重，ConcurrentHashMap则更胜一筹了。 在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。 源码分析：推荐参考chenssy的博文：J.U.C之Java并发容器：ConcurrentHashMap TreeMap –&gt; ConcurrentSkipListMap 底层实现采用SkipList跳表 曾经有人用ConcurrentHashMap与ConcurrentSkipListMap做性能测试，在4个线程1.6W的数据条件下，前者的数据存取速度是后者的4倍左右。但是后者有几个前者不能比拟的优点：1、Key是有序的2、支持更高的并发，存储时间与线程数无关 安全共享对象策略 线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改 共享只读：一个共享只读的U帝乡，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它 线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保障线程安全，多以其他线程无需额外的同步就可以通过公共接口随意访问他 被守护对象：被守护对象只能通过获取特定的锁来访问。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79947616]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（八）：线程不安全类、同步容器]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%B1%BB%E3%80%81%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 1、线程不安全的类 （1）StringBuilder 与 StringBuffer （2）SimpleDateFormat 与 jodatime插件 （3）ArrayList,HashSet,HashMap 等Collection类 2、同步容器 （1）ArrayList的线程安全类：Vector,Stack （2）HashMap的线程安全类：HashTable （3）Collections类中的相关同步方法 1、线程不安全的类如果一个类的对象同时可以被多个线程访问，并且你不做特殊的同步或并发处理，那么它就很容易表现出线程不安全的现象。比如抛出异常、逻辑处理错误…下面列举一下常见的线程不安全的类及对应的线程安全类： （1）StringBuilder 与 StringBufferStringBuilder是线程不安全的，而StringBuffer是线程安全的。分析源码：StringBuffer的方法使用了synchronized关键字修饰。 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125;123456 （2）SimpleDateFormat 与 jodatime插件SimpleDateFormat 类在处理时间的时候，如下写法是线程不安全的： 12345678910private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);//线程调用方法private static void update() &#123; try &#123; simpleDateFormat.parse(&quot;20180208&quot;); &#125; catch (Exception e) &#123; log.error(&quot;parse exception&quot;, e); &#125;&#125;12345678910 但是我们可以变换其为线程安全的写法：在每次转换的时候使用线程封闭，新建变量 12345678private static void update() &#123; try &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;); simpleDateFormat.parse(&quot;20180208&quot;); &#125; catch (Exception e) &#123; log.error(&quot;parse exception&quot;, e); &#125;&#125;12345678 另外我们也可以使用jodatime插件来转换时间：其可以保证线程安全性Joda 类具有不可变性，因此它们的实例无法被修改。（不可变类的一个优点就是它们是线程安全的） 12345private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyyMMdd&quot;);private static void update(int i) &#123; log.info(&quot;&#123;&#125;, &#123;&#125;&quot;, i, DateTime.parse(&quot;20180208&quot;, dateTimeFormatter).toDate());&#125;12345 分析源码：（不可变性） 123456789101112131415161718192021222324252627public class DateTimeFormatter &#123; //均使用final声明 private final InternalPrinter iPrinter; private final InternalParser iParser; private final Locale iLocale; private final boolean iOffsetParsed; private final Chronology iChrono; private final DateTimeZone iZone; private final Integer iPivotYear; private final int iDefaultYear; ... private InternalParser requireParser() &#123; InternalParser var1 = this.iParser; if (var1 == null) &#123; throw new UnsupportedOperationException(&quot;Parsing not supported&quot;); &#125; else &#123; return var1; &#125; &#125; public DateTime parseDateTime(String var1) &#123; InternalParser var2 = this.requireParser(); Chronology var3 = this.selectChronology((Chronology)null); DateTimeParserBucket var4 = new DateTimeParserBucket(0L, var3, this.iLocale, this.iPivotYear, this.iDefaultYear); ... &#125;123456789101112131415161718192021222324252627 （3）ArrayList,HashSet,HashMap 等Collection类像ArrayList,HashSet,HashMap 等Collection类均是线程不安全的，我们以ArrayList举例分析一下源码：1、ArrayList的基本属性：在声明时使用了transient 关键字，此关键字意为在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。而ArrayList实现了序列化接口，自己定义了序列化方法（在此不描述）。 123456//对象数组：ArrayList的底层数据结构private transient Object[] elementData;//elementData中已存放的元素的个数private int size;//默认数组容量private static final int DEFAULT_CAPACITY = 10;123456 2、初始化 12345678910111213141516/** * 创建一个容量为initialCapacity的空的（size==0）对象数组 */ public ArrayList(int initialCapacity) &#123; super();//即父类protected AbstractList() &#123;&#125; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity:&quot; + initialCapacity); this.elementData = new Object[initialCapacity];&#125;/** * 默认初始化一个容量为10的对象数组 */ public ArrayList() &#123; this(10); &#125;12345678910111213141516 3、添加方法（重点） 123456789101112131415161718//每次添加时将数组扩容1，然后再赋值public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;123456789101112131415161718 4、总结：ArrayList每次对内容进行插入操作的时候，都会做扩容处理，这是ArrayList的优点（无容量的限制），同时也是缺点，线程不安全。（以下例子取材于鱼笑笑博客）一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成： 在 Items[Size] 的位置存放此元素； 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 那么如何将其处理为线程安全的？或者说对应的线程安全类有哪些呢？接下来就涉及到我们同步容器。 2、同步容器同步容器分两类，一种是Java提供好的类，另一类是Collections类中的相关同步方法。 （1）ArrayList的线程安全类：Vector,StackVector实现了List接口，Vector实际上就是一个数组，和ArrayList非常的类似，但是内部的方法都是使用synchronized修饰过的方法。Stack它的方法也是使用synchronized修饰了，继承了Vector，实际上就是栈使用举例（Vector）： 123456//定义private static List&lt;Integer&gt; list = new Vector&lt;&gt;();//多线程调用方法private static void update(int i) &#123; list.add(i);&#125;123456 源码分析：使用了synchronized修饰 123456public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;123456 但是Vector也不是完全的线程安全的，比如：错误[1]：删除与获取并发操作 1234567891011121314151617181920212223242526272829public class VectorExample &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread thread1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829 运行结果：报错java.lang.ArrayIndexOutOfBoundsException: Array index out of range原因分析：同时发生获取与删除的操作。当两个线程在同一时间都判断了vector的size，假设都判断为9，而下一刻线程1执行了remove操作，随后线程2才去get，所以就出现了错误。synchronized关键字可以保证同一时间只有一个线程执行该方法，但是多个线程同时分别执行remove、add、get操作的时候就无法控制了。 错误[2]：使用foreach\iterator遍历Vector的时候进行增删操作 123456789101112131415161718192021222324252627282930313233343536373839public class VectorExample3 &#123; // 报错java.util.ConcurrentModificationException private static void test1(Vector&lt;Integer&gt; v1) &#123; // foreach for(Integer i : v1) &#123; if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // 报错java.util.ConcurrentModificationException private static void test2(Vector&lt;Integer&gt; v1) &#123; // iterator Iterator&lt;Integer&gt; iterator = v1.iterator(); while (iterator.hasNext()) &#123; Integer i = iterator.next(); if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // success private static void test3(Vector&lt;Integer&gt; v1) &#123; // for for (int i = 0; i &lt; v1.size(); i++) &#123; if (v1.get(i).equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; public static void main(String[] args) &#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); vector.add(1); vector.add(2); vector.add(3); test1(vector); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839 解决办法：在使用iteratir进行增删操作的时候，加上Lock或者synchronized同步措施或者并发容器 （2）HashMap的线程安全类：HashTable使用举例: 123456//定义private static Map&lt;Integer, Integer&gt; map = new Hashtable&lt;&gt;();//多线程调用方法private static void update(int i) &#123; map.put(i, i);&#125;123456 源码分析： 保证安全性：使用了synchronized修饰 不允许空值（在代码中特殊做了判断） HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。 Entry对象唯一表示一个键值对，有四个属性：-K key 键对象-V value 值对象-int hash 键对象的hash值-Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部 1234567891011121314151617181920212223public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125;1234567891011121314151617181920212223 （3）Collections类中的相关同步方法Collections类中提供了一系列的线程安全方法用于处理ArrayList等线程不安全的Collection类 使用方法： 123456//定义private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());//多线程调用方法private static void update(int i) &#123; list.add(i);&#125;123456 源码分析：内部操作的方法使用了synchronized修饰符 123456789101112131415161718static class SynchronizedList&lt;E&gt; extends SynchronizedCollection&lt;E&gt; implements List&lt;E&gt; &#123; ... public E get(int index) &#123; synchronized (mutex) &#123;return list.get(index);&#125; &#125; public E set(int index, E element) &#123; synchronized (mutex) &#123;return list.set(index, element);&#125; &#125; public void add(int index, E element) &#123; synchronized (mutex) &#123;list.add(index, element);&#125; &#125; public E remove(int index) &#123; synchronized (mutex) &#123;return list.remove(index);&#125; &#125; ...&#125; 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79923837]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（七）：线程封闭 - ThreadLocal]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD-ThreadLocal%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 1、什么是线程封闭？它其实就是把对象封装到一个线程里，只有一个线程能看到这个对象，那么这个对象就算不是线程安全的，也不会出现任何线程安全方面的问题。 线程封闭技术有一个常见的应用： 数据库连接对应jdbc的Connection对象，Connection对象在实现的时候并没有对线程安全做太多的处理，jdbc的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。 2、线程封闭的种类：（1）Ad-hoc 线程封闭： Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象（例如，GUI应用程序中的可视化组件或数据模型等）的引用通常保存在公有变量中。 （2）堆栈封闭：堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，方法中的局部变量都会被拷贝一份到线程的栈中（Java内存模型），所以局部变量是不会被多个线程所共享的。 （3）ThreadLocal线程封闭：它是一个特别好的封闭方法，其实ThreadLocal内部维护了一个map,map的key是每个线程的名称，而map的value就是我们要封闭的对象。ThreadLocal提供了get、set、remove方法，每个操作都是基于当前线程的，所以它是线程安全的。 1234567891011121314//ThreadLocal的get方法源码public T get() &#123; Thread t = Thread.currentThread();//当前线程对象 ThreadLocalMap map = getMap(t);//get操作基于当前线程 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;1234567891011121314 3、Springboot框架中使用ThreadLocal说明：1、这里不描述springboot框架的搭建过程，假定你已经有了一个可以正常运行的springboot简单项目。2、我们这里的例子使用的是springboot框架中的filter与Interceptor来使用threadLocal，对于Springboot的filter与Interceptor不做过多的讲解。 coding：（1）创建一个包含ThreadLocal对象的类，并提供基础的添加、删除、获取操作。 12345678910111213141516public class RequestHolder &#123; private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;&gt;(); public static void add(Long id) &#123; requestHolder.set(id); &#125; public static Long getId() &#123; return requestHolder.get(); &#125; public static void remove() &#123; requestHolder.remove(); &#125;&#125;12345678910111213141516 （2）创建Filter，在Filter中对ThreadLocal做添加操作。 123456789101112131415161718192021222324public class HttpFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; //打印当前线程的ID与请求路径 log.info(&quot;do filter, &#123;&#125;, &#123;&#125;&quot;, Thread.currentThread().getId(), request.getServletPath()); //将当前线程ID添加到ThreadLocal中 RequestHolder.add(Thread.currentThread().getId()); filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125;123456789101112131415161718192021222324 （3)创建controller，在controller中获取到filter中存入的值 1234567891011@Controller@RequestMapping(&quot;/threadLocal&quot;)public class ThreadLocalController &#123; @RequestMapping(&quot;/test&quot;) @ResponseBody public Long test() &#123; return RequestHolder.getId(); &#125;&#125;1234567891011 （4）创建拦截器Interceptor，在拦截器中删除刚才添加的值 123456789101112131415161718public class HttpInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(&quot;preHandle&quot;); return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; RequestHolder.remove(); log.info(&quot;afterCompletion&quot;); return; &#125;&#125;123456789101112131415161718 （5）在springboot的启动类Application中注册filter与Interceptor。要继承WebMvcConfigurerAdapter 类。（我这里的启动类名为：ConcurrencyApplication） 1234567891011121314151617181920212223@SpringBootApplicationpublic class ConcurrencyApplication extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; SpringApplication.run(ConcurrencyApplication.class, args); &#125; //注册过滤器 @Bean public FilterRegistrationBean httpFilter() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new HttpFilter()); //设置要过滤的url registrationBean.addUrlPatterns(&quot;/threadLocal/*&quot;); return registrationBean; &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new HttpInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125;1234567891011121314151617181920212223 （6）运行程序，访问 http://localhost:8080/threadLocal/test 结果如下： 页面中打印出我们当前的线程ID： 查看控制台：从控制台的打印日志我们可以看出，首先filter过滤器先获取到我们当前的线程ID为40、我们当前的请求路径为/threadLocal/test ，紧接着进入了我们的Interceptor的preHandle方法中，打印了preHandle字样。最后进入了我们的Interceptor的afterCompletion方法，删除了我们之前存入的值，并打印了afterCompletion字样。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79902773]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（六）：不可变对象 -final -ImmutableX -unmodifiableX]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1-final-ImmutableX-unmodifiableX%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 概念1、不可变对象有一种对象只要它发布了就是安全的，它就是不可变对象。一个不可变对象需要满足的条件： 对象创建一个其状态不能修改 对象所有域都是final类型 对象是正确创建的(在对象创建期间，this引用没有逸出) 2、创建一个不可变对象的方法（1）自己定义这里可以采用的方式包括：1、将类声明为final，这样它就不能被继承。2、将所有的成员声明为私有的，这样就不允许直接访问这些成员。3、对变量不提供set方法，将所有可变的成员声明为final，这样就只能赋值一次。通过构造器初始化所有成员进行深度拷贝。4、在get方法中不直接返回对象的本身，而是克隆对象，返回对象的拷贝。 （2）使用Java中提供的Collection类中的各种unmodifiable开头的方法（3）使用Guava中的Immutable开头的类 3、final关键字final关键字可以修饰类、修饰方法、修饰变量 修饰类：类不能被集成。基础类型的包装类都是final类型的类。final类中的成员变量可以根据需要设置为final，但是要注意的是，final类中的所有成员方法都会被隐式的指定为final方法 修饰方法：(1)把方法锁定，以防任何继承类修改它的含义(2)效率：在早期的java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不见效果。一个private方法会被隐式的指定为final方法 修饰变量：基本数据类型变量，在初始化之后，它的值就不能被修改了。如果是引用类型变量，在它初始化之后便不能再指向另外的对象。 从上图我们可见，（1）对一个被final修饰的变量（Integer a、String b）被赋值时在编译过程中就出现了错误。（2）（map）在重新被指向一个新的map对象的时候也出现了错误。那么对被定义为final的map进行赋值呢？我们单独运行map.put(1,3)语句，结果是可以的。被final修饰的引用类型变量，虽然不能重新指向，但是可以修改,这一点尤为要注意。（3）当final修饰方法的参数时：同样也是不允许在方法内部对其修改的。 4、Java:unmodifiable相关方法使用Java的Collection类的unmodifiable相关方法，可以创建不可变对象。unmodifiable相关方法包含：Collection、List、Map、Set….举个栗子： 1234567891011121314151617public class ImmutableExample &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125;1234567891011121314151617 上面程序的执行结果为：在map.put（1，3）操作的位置抛出了异常。由此可见map对象已经成为不可变对象。 那么unmodifiable相关类的实现原理是什么呢？我们查看一下Collections.unmodifiableMap的源码：（以下源码只筛选出表达观点的部分，非全部） 12345678910public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) &#123; return new UnmodifiableMap&lt;&gt;(m);&#125;private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; ... public V put(K key, V value) &#123; throw new UnsupportedOperationException(); &#125; ...&#125;12345678910 Collections.unmodifiableMap在执行时，将参数中的map对象进行了转换，转换为Collection类中的内部类 UnmodifiableMap对象。而 UnmodifiableMap对map的更新方法（比如put、remove等）进行了重写，均返回UnsupportedOperationException异常，这样就做到了map对象的不可变。 5、Guava:Immutable相关类使用Guava的Immutable相关类也可以创建不可变对象。同样包含很多类型：Collection、List、Map、Set….举栗子：（1）ImmutableList 123private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);list.add(4);//这一句在书写完就会被IDE提示该add方法为过时方法，实际为不可用方法123 对于ImmutableList.of方法，如果传多个参数，需要这样一直写下去，以逗号分隔每个参数。其源码中是这样实现的： 1234567891011121314151617181920212223242526272829303132333435363738//单个或少于12个参数时public static &lt;E&gt; ImmutableList&lt;E&gt; of() &#123; return RegularImmutableList.EMPTY;&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E element) &#123; return new SingletonImmutableList(element);&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2) &#123; return construct(e1, e2);&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3) &#123; return construct(e1, e2, e3);&#125;....//多于12个参数时，参数列表中最后的E...other会以数组形式接收参数@SafeVarargspublic static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) &#123; Object[] array = new Object[12 + others.length]; array[0] = e1; array[1] = e2; array[2] = e3; array[3] = e4; array[4] = e5; array[5] = e6; array[6] = e7; array[7] = e8; array[8] = e9; array[9] = e10; array[10] = e11; array[11] = e12; System.arraycopy(others, 0, array, 12, others.length); return construct(array);&#125;1234567891011121314151617181920212223242526272829303132333435363738 运行结果仍然为抛出UnsupportedOperationException异常。分析源码：Immutable相关类使用了跟Java的unmodifiable相关类相似的实现方法。 123456/** @deprecated */ @Deprecated @CanIgnoreReturnValue public final boolean add(E e) &#123; throw new UnsupportedOperationException(); &#125;123456 （2）ImmutableSetImmutableSet除了使用of的方法进行初始化，还可以使用copyof方法，将Collection类型、Iterator类型作为参数。 123private final static ImmutableSet set = ImmutableSet.copyOf(list);private final static ImmutableSet set = ImmutableSet.copyOf(list.iterator());123 （3）ImmutableMapImmutableMap有特殊的builder写法： 1234private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79897550]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（五）：安全发布对象与多种单例模式]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%A4%9A%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 发布对象 对象逸出 代码演示 不安全发布对象 对象逸出 安全发布对象示例（多种单例模式演示） 1、懒汉式（最简式） 2、懒汉式（synchronized） 3、双重同步锁模式【先入坑再出坑】 4、饿汉式（最简式） 5、饿汉式（静态块初始化） 6、枚举式 概念发布对象使一个对象能够被当前范围之外的代码所使用。在我们的日常开发中，我们经常要发布一些对象，比如通过类的非私有方法返回对象的引用，或者通过公有静态变量发布对象。 对象逸出一种错误的发布。当一个对象还没有构造完成时，就使它被其他线程所见。 代码演示不安全发布对象1234567891011121314151617public class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; //类的非私有方法，返回私有对象的引用 public String[] getStates() &#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125;1234567891011121314151617 分析： 这个代码通过public访问级别发布了类的域，在类的任何外部的线程都可以访问这些域 我们无法保证其他线程会不会修改这个域，从而使私有域内的值错误（上述代码中就对私有域进行了修改） 对象逸出123456789101112131415161718192021public class Escape &#123; private Integer thisCanBeEscape = 0; public Escape () &#123; new InnerClass(); thisCanBeEscape = null; &#125; //内部类构造方法调用外部类的私有域 private class InnerClass &#123; public InnerClass() &#123; log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125;123456789101112131415161718192021 分析： 这个内部类的实例里面包含了对封装实例的私有域对象的引用，在对象没有被正确构造完成之前就会被发布，有可能有不安全的因素在里面，会导致this引用在构造期间溢出的错误。 上述代码在函数构造过程中启动了一个线程。无论是隐式的启动还是显式的启动，都会造成这个this引用的溢出。新线程总会在所属对象构造完毕之前就已经看到它了。 因此要在构造函数中创建线程，那么不要启动它，而是应该采用一个专有的start或者初始化的方法统一启动线程 这里其实我们可以采用工厂方法和私有构造函数来完成对象创建和监听器的注册等等，这样才可以避免错误 ——————————————————————————————————————————————————- 如果不正确的发布对象会导致两种错误：（1）发布线程意外的任何线程都可以看到被发布对象的过期的值（2）线程看到的被发布线程的引用是最新的，然而被发布对象的状态却是过期的 安全发布对象示例（多种单例模式演示）如何安全发布对象？共有四种方法 1、在静态初始化函数中初始化一个对象引用 2、将对象的引用保存到volatile类型域或者AtomicReference对象中 3、将对象的引用保存到某个正确构造对象的final类型域中 4、将对象的引用保存到一个由锁保护的域中 下面我们用各种单例模式来演示其中的几种方法 1、懒汉式（最简式）12345678910111213141516public class SingletonExample &#123; //私有构造函数 private SingletonExample()&#123; &#125; //单例对象 private static SingletonExample instance = null; //静态工厂方法 public static SingletonExample getInstance()&#123; if(instance==null)&#123; return new SingletonExample(); &#125; return instance; &#125;&#125;12345678910111213141516 分析：1、在多线程环境下，当两个线程同时访问这个方法，同时制定到instance==null的判断。都判断为null，接下来同时执行new操作。这样类的构造函数被执行了两次。一旦构造函数中涉及到某些资源的处理，那么就会发生错误。所以说最简式是线程不安全的 2、懒汉式（synchronized）12在类的静态方法上使用synchronized修饰 public static synchronized SingletonExample getInstance()12 分析：1、使用synchronized修饰静态方法后，保证了方法的线程安全性，同一时间只有一个线程访问该方法2、有缺陷：会造成性能损耗 3、双重同步锁模式【先入坑再出坑】12345678910111213141516171819public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = null; // 静态的工厂方法 public static SingletonExample getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (SingletonExample.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonExample(); &#125; &#125; &#125; return instance; &#125;&#125;12345678910111213141516171819 （入坑）分析：1、我们将上面的第二个例子(懒汉式（synchronized))进行了改进，由synchronized修饰方法改为先判断后，再锁定整个类，再加上双重的检测机制，保证了最大程度上的避免耗损性能。2、这个方法是线程不安全的，可能大家会想在多线程情况下，只要有一个线程对类进行了上锁，那么无论如何其他线程也不会执行到new的操作上。接下来我们分析一下线程不安全的原因： 这里有一个知识点：CPU指令相关在上述代码中，执行new操作的时候，CPU一共进行了三次指令（1）memory = allocate() 分配对象的内存空间（2）ctorInstance() 初始化对象（3）instance = memory 设置instance指向刚分配的内存 在程序运行过程中，CPU为提高运算速度会做出违背代码原有顺序的优化。我们称之为乱序执行优化或者说是指令重排。那么上面知识点中的三步指令极有可能被优化为（1）（3）（2）的顺序。当我们有两个线程A与B，A线程遵从132的顺序，经过了两此instance的空值判断后，执行了new操作，并且cpu在某一瞬间刚结束指令（3），并且还没有执行指令（2）。而在此时线程B恰巧在进行第一次的instance空值判断，由于线程A执行完（3）指令，为instance分配了内存，线程B判断instance不为空，直接执行return，返回了instance，这样就出现了错误。 （出坑）解决办法： 12在对象声明时使用volatile关键字修饰，阻止CPU的指令重排。private volatile static SingletonExample instance = null;12 关于volatile如何阻止CPU指令重排，详情请见另一篇文章：高并发探索（四)：线程安全性-可见性-有序性 4、饿汉式（最简式）1234567891011121314public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = new SingletonExample(); // 静态的工厂方法 public static SingletonExample getInstance() &#123; return instance; &#125;&#125;1234567891011121314 分析：1、饿汉模式由于单例实例是在类装载的时候进行创建，因此只会被执行一次，所以它是线程安全的。2、该方法存在缺陷：如果构造函数中有着大量的事情操作要做，那么类的装载时间会很长，影响性能。如果只是做的类的构造，却没有引用，那么会造成资源浪费3、饿汉模式适用场景为：（1）私有构造函数在实现的时候没有太多的处理（2）这个类在实例化后肯定会被使用 5、饿汉式（静态块初始化）123456789101112131415161718public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = null; static &#123; instance = new SingletonExample(); &#125; // 静态的工厂方法 public static SingletonExample getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; System.out.println(getInstance().hashCode()); System.out.println(getInstance().hashCode()); &#125;&#125;123456789101112131415161718 分析：1、除了使用静态域直接初始化单例对象，还可以用静态块初始化单例对象。2、值得注意的一点是，静态域与静态块的顺序一定不要反，在写静态域和静态方法的时候，一定要注意顺序，不同的静态代码块是按照顺序执行的，它跟我们正常定义的静态方法和普通方法是不一样的。 6、枚举式1234567891011121314151617181920212223public class SingletonExample &#123; private SingletonExample() &#123; &#125; public static SingletonExample getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private SingletonExample singleton; Singleton() &#123; singleton = new SingletonExample(); &#125; public SingletonExample getInstance() &#123; return singleton; &#125; &#125;&#125;1234567891011121314151617181920212223 由于枚举类的特殊性，枚举类的构造函数Singleton方法只会被实例化一次，且是这个类被调用之前。这个是JVM保证的。 对比懒汉与饿汉模式，它的优势很明显。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79866152]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（四）：线程安全性-可见性-有序性]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7-%E5%8F%AF%E8%A7%81%E6%80%A7-%E6%9C%89%E5%BA%8F%E6%80%A7%2F</url>
    <content type="text"><![CDATA[可见性什么是可见性？ 一个线程对主内存的修改可以及时的被其他线程观察到 导致共享变量在线程间不可见的原因 线程交叉执行 重排序结合线程交叉执行 共享变量更新后的值没有在工作内存与主存间及时更新 JVM处理可见性JVM对于可见性，提供了synchronized和volatile JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁） Volatile:通过加入内存屏障和禁止重排序优化来实现 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存。 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。 volatile的屏障操作都是cpu级别的。 适合状态验证，不适合累加值，volatile关键字不具有原子性举个例子：我们仍用高并发学习（二）中的例子来说明，对一个int型数值的多线程读写操作。我们将count变量用volatile来修饰： 12345678910111213141516171819202122232425262728293031323334public class CountExample &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //计数 * public static volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count); &#125; private static void add()&#123; count++; &#125;&#125;12345678910111213141516171819202122232425262728293031323334 多次运行代码我们发现：count的最终结果并不是预期的5000，而是有时为5000，但是大多数时间比5000小，这是为什么呢？原因在于对count++的操作中，jvm对count做了三步操作： 1、从主存中取出count的值放入工作变量 count2、对工作变量中的count进行+13、将工作变量中的count刷新回主存中 在单线程执行此操作绝对没有问题，但是在多线程环境中，假设有两个线程A、B同时执行count++操作，某一刻A与B同时读取主存中count的值，然后在自己线程对应的工作空间中对count+1，最后又同时将count+1的值写回主存。到此，count+1的值被写回主存两遍，所以导致最终的count值小了1。在整体程序执行过程中，该事件发生一次或多次，自然结果就不正确。那么volatile适合做什么呢？其实它比较适合做状态标记量（不会涉及到多线程同时读写的操作），而且要保证两点：（1）对变量的写操作不依赖于当前值（2）该变量没有包含在具有其他变量的不变的式子中例如： 12345678910volatile boolean inited = false;//线程一：context = loadContext();inited = true;//线程二：while（!inited）&#123; sleep();&#125;doSomethingWithConfig(context);12345678910 有序性什么是有序性？Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。关于重排序，详情见：高并发学习（二）– 4、乱序执行优化 java中保证有序性java提供了 volatile、synchronized、Lock可以用来保证有序性另外，java内存模型具备一些先天的有序性，即不需要任何手段就能得到保证的有序性。通常被我们成为happens-before原则（先行发生原则）。如果两个线程的执行顺序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机就可以对它们进行重排序。 【以下规则来自于《深入理解java虚拟机》】 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作（重要） 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C —————————————————————————————————————————————— 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79848032]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（三）：线程安全性-原子性-CAS（CAS的ABA问题）]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7-%E5%8E%9F%E5%AD%90%E6%80%A7-CAS%EF%BC%88CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 线程安全性线程安全性 线程安全？ 线程安全性？ 原子性 Atomic包中的类与CAS： AtomicInteger AtomicLong 与 LongAdder AtomicBoolean AtomicIntegerFieldUpdater AtomicStampReference与CAS的ABA问题 AtomicLongArray synchronized synchronized 修饰一个代码块 synchronized 修饰一个方法 synchronized 修饰一个静态方法 synchronized 修饰一个类 原子性操作各方法间的对比 线程安全？当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 线程安全性？线程安全性主要体现在三个方面：原子性、可见性、有序性 原子性:提供了互斥访问，同一时刻只能有一个线程来对它进行操作 可见性:一个线程对主内存的修改可以及时的被其他线程观察到 有序性:一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。 基础代码：以下代码用于描述下方的知识点，所有代码均在此代码基础上进行修改。 12345678910111213141516171819202122232425262728293031323334public class CountExample &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //变量声明：计数 public static AtomicInteger count = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count.get());//变量取值 &#125; private static void add()&#123; count.incrementAndGet();//变量操作 &#125;&#125;12345678910111213141516171819202122232425262728293031323334 原子性说到原子性，一共有两个方面需要学习一下，一个是JDK中已经提供好的Atomic包，他们均使用了CAS完成线程的原子性操作，另一个是使用锁的机制来处理线程之间的原子性。锁包括：synchronized、Lock Atomic包中的类与CAS：我们从最简单的AtomicInteger类来了解什么是CAS AtomicInteger上边的示例代码就是通过AtomicInteger类保证了线程的原子性。那么它是如何保证原子性的呢？我们接下来分析一下它的源码。示例中，对count变量的+1操作，采用的是incrementAndGet方法，此方法的源码中调用了一个名为unsafe.getAndAddInt的方法 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;123 而getAndAddInt方法的具体实现为： 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;1234567 在此方法中，方法参数为要操作的对象Object var1、期望底层当前的数值为var2、要修改的数值var4。定义的var5为真正从底层取出来的值。采用do..while循环的方式去获取底层数值并与期望值进行比较，比较成功才将值进行修改。而这个比较再进行修改的方法就是compareAndSwapInt就是我们所说的CAS，它是一系列的接口，比如下面罗列的几个接口。使用native修饰，是底层的方法。CAS取的是compareAndSwap三个单词的首字母. 另外，示例代码中的count可以理解为JMM中的工作内存，而这里的底层数值即为主内存，如果看过我上一篇文章的盆友就能把这一块的知识点串联起来了。 123public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);123 AtomicLong 与 LongAdderLongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。首先看一下代码实现： 1234567891011121314AtomicLong：//变量声明public static AtomicLong count = new AtomicLong(0);//变量操作count.incrementAndGet();//变量取值count.get();1234567LongAdder：//变量声明public static LongAdder count = new LongAdder();//变量操作count.increment();//变量取值count1234567 那么问题来了，为什么有了AtomicLong还要新增一个LongAdder呢？原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。 知识点： 对于普通类型的long、double变量，JVM允许将64位的读操作或写操作拆成两个32位的操作。 LongAdder类的实现核心是将热点数据分离，比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。 1234567891011121314源码：public void increment() &#123; add(1L);&#125;public void add(long x) &#123; Cell[] as; long b, v; int m; Cell a; if ((as = cells) != null || !casBase(b = base, b + x)) &#123; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) longAccumulate(x, null, uncontended); &#125;&#125;1234567891011121314 缺点：如果在统计的时候，如果有并发更新，可能会有统计数据有误差。实际使用中在处理高并发计数的时候优先使用LongAdder，而不是AtomicLong在线程竞争很低的时候，使用AtomicLong会简单效率更高一些。比如序列号生成（准确性） AtomicBoolean这个类中值得一提的是它包含了一个名为compareAndSet的方法，这个方法可以做到的是控制一个boolean变量在一件事情执行之前为false，事情执行之后变为true。或者也可以理解为可以控制某一件事只让一个线程执行，并仅能执行一次。他的源码如下： 12345public final boolean compareAndSet(boolean expect, boolean update) &#123; int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u);&#125;12345 举例说明： 12345678910111213141516171819202122232425262728293031323334353637 //是否发生过 private static AtomicBoolean isHappened = new AtomicBoolean(false); // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); test(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;isHappened:&#123;&#125;&quot;, isHappened.get()); &#125; private static void test() &#123; if (isHappened.compareAndSet(false, true)) &#123;//控制某有一段代码只执行一次 log.info(&quot;execute&quot;); &#125; &#125;结果：(log只打印一次)[pool-1-thread-2] INFO com.superboys.concurrency.example.Atomic.AtomicExample6 - execute[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample6 - isHappened:true12345678910111213141516171819202122232425262728293031323334353637 AtomicIntegerFieldUpdater这个类的核心作用是要更新一个指定的类的某一个字段的值。并且这个字段一定要用volatile修饰同时还不能是static的。举例说明： 123456789101112131415161718192021222324252627282930@Slf4jpublic class AtomicExample5 &#123; //原子性更新某一个类的一个实例 private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class,&quot;count&quot;); @Getter public volatile int count = 100;//必须要volatile标记，且不能是static public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if(updater.compareAndSet(example5,100,120))&#123; log.info(&quot;update success 1,&#123;&#125;&quot;,example5.getCount()); &#125; if(updater.compareAndSet(example5,100,120))&#123; log.info(&quot;update success 2,&#123;&#125;&quot;,example5.getCount()); &#125;else&#123; log.info(&quot;update failed,&#123;&#125;&quot;,example5.getCount()); &#125; &#125;&#125;此方法输出的结果为：[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample5 - update success 1,120[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample5 - update failed,120由此可见，count的值只修改了一次。123456789101112131415161718192021222324252627282930 AtomicStampReference与CAS的ABA问题什么是ABA问题？CAS操作的时候，其他线程将变量的值A改成了B，但是随后又改成了A，本线程在CAS方法中使用期望值A与当前变量进行比较的时候，发现变量的值未发生改变，于是CAS就将变量的值进行了交换操作。但是实际上变量的值已经被其他的变量改变过，这与设计思想是不符合的。所以就有了AtomicStampReference。 12345678910111213141516171819202122232425262728293031源码：private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125;private volatile Pair&lt;V&gt; pair;private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); &#125;public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; //排除新的引用和新的版本号与底层的值相同的情况 newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125;12345678910111213141516171819202122232425262728293031 AtomicStampReference的处理思想是，每次变量更新的时候，将变量的版本号+1，之前的ABA问题中，变量经过两次操作以后，变量的版本号就会由1变成3，也就是说只要线程对变量进行过操作，变量的版本号就会发生更改。从而解决了ABA问题。 解释一下上边的源码：类中维护了一个volatile修饰的Pair类型变量current，Pair是一个私有的静态类，current可以理解为底层数值。compareAndSet方法的参数部分分别为期望的引用、新的引用、期望的版本号、新的版本号。return的逻辑为判断了期望的引用和版本号是否与底层的引用和版本号相符，并且排除了新的引用和新的版本号与底层的值相同的情况（即不需要修改）的情况（return代码部分3、4行）。条件成立，执行casPair方法，调用CAS操作。 AtomicLongArray这个类实际上维护了一个Array数组，我们在对数值进行更新的时候，会多一个索引值让我们更新。 原子性，提供了互斥访问，同一时刻只能有一个线程来对它进行操作。那么在java里，保证同一时刻只有一个线程对它进行操作的，除了Atomic包之外，还有锁的机制。JDK提供锁主要分为两种：synchronized和Lock。接下来我们了解一下synchronized。 synchronized依赖于JVM去实现锁，因此在这个关键字作用对象的作用范围内，都是同一时刻只能有一个线程对其进行操作的。synchronized是java中的一个关键字，是一种同步锁。它可以修饰的对象主要有四种： 修饰代码块:大括号括起来的代码，作用于调用的对象 修饰方法：整个方法，作用于调用的对象 ———————————————————————– 修饰静态方法：整个静态方法，作用于所有对象 修饰类：括号括起来的部分，作用于所有对象 synchronized 修饰一个代码块被修饰的代码称为同步语句块，作用的范围是大括号括起来的部分。作用的对象是调用这段代码的对象。验证： 1234567891011121314151617public class SynchronizedExample &#123; public void test(int j)&#123; synchronized (this)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; &#125; //使用线程池方法进行测试： public static void main(String[] args) &#123; SynchronizedExample example1 = new SynchronizedExample(); SynchronizedExample example2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt; example1.test(1)); executorService.execute(()-&gt; example2.test(2)); &#125;&#125;1234567891011121314151617 结果：不同对象之间的操作互不影响 synchronized 修饰一个方法被修饰的方法称为同步方法，作用的范围是大括号括起来的部分，作用的对象是调用这段代码的对象。验证： 123456789public class SynchronizedExample public synchronized void test(int j)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; //验证方法与上面相同 ...&#125;123456789 结果：不同对象之间的操作互不影响 TIPS：如果当前类是一个父类，子类调用父类的被synchronized修饰的方法，不会携带synchronized属性，因为synchronized不属于方法声明的一部分 synchronized 修饰一个静态方法作用的范围是synchronized 大括号括起来的部分，作用的对象是这个类的所有对象。验证： 123456789public class SynchronizedExample&#123; public static synchronized void test(int j)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; //验证方法与上面相同 ...&#125;123456789 结果：同一时间只有一个线程可以执行 synchronized 修饰一个类验证： 1234567891011public class SynchronizedExample&#123; public static void test(int j)&#123; synchronized (SynchronizedExample.class)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125;-&#123;&#125;&quot;,j,i); &#125; &#125; &#125; //验证方法与上面相同 ...&#125;1234567891011 结果：同一时间只有一个线程可以执行 原子性操作各方法间的对比 synchronized:不可中断锁，适合竞争不激烈，可读性好 Lock：可中断锁，多样化同步，竞争激烈时能维持常态 Atomic:竞争激烈时能维持常态，比Lock性能好，每次只能同步一个值 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79837508]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（二）：高并发相关基础知识 - MESI - JMM]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-MESI-JMM%2F</url>
    <content type="text"><![CDATA[高并发相关基础知识特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 高并发相关基础知识0、工具1、基础概念2、CPU多级缓存3、缓存一致性(MESI Modify|Exclusive|Share|Invalid)4、乱序执行优化5、JAVA 内存模型(JMM)6、Java内存模型-同步八种操作7、Java内存模型-同步规则8、并发的优势与风险 0、工具 Apache Bench(AB) :Apache附带的工具，测试网站性能 — ApacheBench安装及使用方法 Jmeter ： Apache组织开发的压力测试工具（比AB更强大） 代码测试方法 ：Semaphore、CountDownLatch类 Semaphore类：信号量信号量，在我们测试的过程中充当监控并发数的角色。能够维持在同一时间的请求的并发量，达到并发量上线，会阻塞进程。 CountDownLatch类：计数器向下减的闭锁说明：假设计数器的值为3，线程A执行了await()方法之后，进入了awaiting等待状态。在其他线程的方法中执行了countDown()方法之后，计数器的值都会减一，直到计数器的值减为0，线程A的方法才继续执行。所以说，countDownLatch类可以阻塞线程执行，并且当满足指定条件后让线程继续执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author JeffOsmond * @version V1.0 * @package com.superboys.concurrency * @description 【线程不安全】模拟示例 * @email yinjiaxing_web@163.com * @time 2018/4/3 */@NotThreadSafe@Slf4jpublic class CountExample1 &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //计数 public static int count = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count); &#125; private static void add()&#123; count++; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445 1、基础概念 并发:同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地还如或者换出内存，这些线程是同时”存在”的，每隔线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。 高并发:High Concurrency 是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 2、CPU多级缓存CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题。CPU多级缓存配置（演变）：局部性原理：(1) 时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。(2) 空间局部性：如果某个数据被访问，那么与他相邻的数据很快也可能被访问。 3、缓存一致性(MESI Modify|Exclusive|Share|Invalid) Modify:被修改，该缓存行只被缓存在该CPU的缓存中。并且是被修改过的，因此它与主存中的数据是不一致的，该缓存行中的内存需要在未来的某个时间点写回主存，这个时间点是允许其他CPU读取主存中相应的内存之前。当这里的值被写回主存之后，该缓存行的状态将变为Excluisive. Exclusive:独享，该缓存行只被缓存在该CPU的缓存中，他是未被修改过的，是与主存中的数据一致的。他可以在任何时刻，被其他CPU读取该内存时，变成Share。当该CPU修改他的内容时，变成Modify Share：共享，意味着该缓存行可能被多个CPU进行缓存，并且各缓存中的数据与主存数据是一致的。当有一个CPU修改该缓存行的时候，其他CPU中该缓存行变成Invalid Invalid：无效 四种操作 本地读取 local read :读本地缓存 本地写入 local write : 写本地缓存 远端读取 remote rade : 将Memory中的数据读取过来 远端写入 remote write : 将数据写回Memory中缓存被修改时的情况：某一时刻缓存被CPU A 与CPU B共享，这时CPU A 要修改本地缓存的时候，会将主存的数据与CPU B在共享的数据置为无效状态。缓存由S -&gt; I 4、乱序执行优化处理器为提高运算速度而做出违背代码原有顺序的优化。举例：初始计算需求如下 预期计算流程： 实际计算流程（乱序执行优化后）： 5、JAVA 内存模型(JMM)一种规范，规范了java虚拟机与计算机内存如何协同工作的。它规定了一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步地访问共享变量。 堆Heap:运行时数据区，有垃圾回收，堆的优势可以动态分配内存大小，生存期也不必事先告诉编译器，因为他是在运行时动态分配内存。缺点是由于运行时动态分配内存，所以存取速度慢一些。 栈Stack:优势存取速度快，速度仅次于计算机的寄存器。栈的数据是可以共享的，但是缺点是存在栈中数据的大小与生存期必须是确定的。主要存放基本类型变量，对象据点。要求调用栈和本地变量存放在线程栈上。 静态类型变量跟随类的定义存放在堆上。存放在堆上的对象可以被所持有对这个对象引用的线程访问。 如果两个线程同时调用了同一个对象的同一个方法，他们都会访问这个对象的成员变量。但是这两个线程都拥有的是该对象的成员变量（局部变量）的私有拷贝。—[线程封闭中的堆栈封闭] CPU Registers(寄存器):是CPU内存的基础，CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器速度远大于主存。 CPU Cache Memory(高速缓存):由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存，来作为内存与处理器之间的缓冲。将运算时所使用到的数据复制到缓存中,让运算能快速的进行。当运算结束后，再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。 RAM-Main Memory(主存/内存): 当一个CPU需要读取主存的时候，他会将主存中的部分读取到CPU缓存中，甚至他可能将缓存中的部分内容读到他的内部寄存器里面，然后在寄存器中执行操作。当CPU需要将结果回写到主存的时候，他会将内部寄存器中的值刷新到缓存中，然后在某个时间点从缓存中刷回主存。 Java内存模型抽象结构：每个线程都有一个私有的本地内存，本地内存他是java内存模型的一个抽象的概念。它并不是真实存在的，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器的优化。本地内存中它存储了该线程以读或写共享变量拷贝的一个副本。 从更低的层次来说，主内存就是硬件的内存，是为了获取更高的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中，java内存模型中的线程的工作内存是CPU的寄存器和高速缓存的一个抽象的描述。而JVM的静态内存存储模型它只是对内存的一种物理划分而已。它只局限在内存，而且只局限在JVM的内存。 6、Java内存模型-同步八种操作 lock(锁定) ：作用于主内存变量，把一个变量标识为一条线程独占状态 unlock(解锁) ： 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read(读取) ： 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load(载入) ：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use(使用) ：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign(赋值) ： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量 store(存储) ： 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作 write(写入) ：作用于主内存的变量中，它把store操作从工作内存中一个变量的值传送到主内存的变量中 7、Java内存模型-同步规则 如果要把一个变量从主内存中复制到工作内存，就需要按顺序的执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序的执行store和write操作。但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量早同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须是成对出现。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock锁定，则不允许对它执行unlock操作，也不允许unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） 8、并发的优势与风险 风险： 安全性：多个线程共享数据时可能会产生于期望不相符的结果 活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁、饥饿问题 性能：线程过多时会使得CPU频繁切换，调度时间增多；同步机制；消耗过多内存。 优势： 速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程同时进行。 设计：程序设计在某些情况下更简单，也可以有更多选择 资源利用：CPU能够在等待IO的时候做一些其他的事情 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79811336]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（一）：详细讲解 - 网站性能测试工具Apache Bench]]></title>
    <url>%2F2018%2F09%2F14%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3-%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Apache-Bench%2F</url>
    <content type="text"><![CDATA[特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 1、Apache Bench 简介Apache Bench是Apache 服务器附带的工具，专门用来执行网站服务器的运行效能，特别是针对Apache 网站服务器。原本用来检测Apache网站能够提供的效能，特别是能看出Apache能提供每秒能送出多少网页。 2、Apache Bench下载我们到网站的官网去下载Apache服务器下载地址：Apache服务器下载地址下载成功后直接进行解压，无需安装即可使用（仅针对于ApacheBench而言）。 3、简单的Apache Bench使用方法 我们打开命令行界面，从命令行界面进入Apache Bench的解压路径下，进入后访问bin文件夹。 进入后我们输入基础的测试命令对接口进行测试（例如http://localhost:8080/test） ab -n 1000 -c 50 http://localhost:8080/test 这段命令的含义是对于上述接口进行1000次测试，在同一时间内允许50个并发请求，执行结果如下： 4、测试结果讲解（1）测试指令参数说明：Usage: ab [options][]hostname[:port]/path&gt;我们上述的测试指令中，options为测试指令参数，其全部指参数说明如下： Options are:（英文水平太烂，凑活看吧） 参数编码（-？） 参数名 参数说明 含义 -n requests Number of requests to perform 总请求数 -c concurrency Number of multiple requests to make at a time 并发数量 -t timelimit Seconds to max. to spend on benchmarkin ,This implies -n 50000 测试时长最大秒数 -s timeout Seconds to max. wait for each response, Default is 30 seconds 每次请求等待响应的最长时间，默认30秒 -b windowsize Size of TCP send/receive buffer, in bytes TCP发送\接收缓存大小（单位bytes） -B address Address to bind to when making outgoing connections 发送连接时绑定的地址 -p postfile File containing data to POST. Remember also to set -T 以POST方法发送文件，必须同时使用-T参数 -u putfile File containing data to PUT. Remember also to set -T 以PUT方法发送文件，必须同时使用-T参数 -T content-type Content-type header to use for POST/PUT data, eg., ‘application/x-www-form-urlencoded’, Default is ‘text/plain’ 使用POST\PUT方式时的Content-Type头，例如：’application/x-www-form-urlencoded’，默认：’text/plain’ -v verbosity How much troubleshooting info to print 设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出 -w Print out results in HTML tables 以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表 -i Use HEAD instead of GET 使用HEAD请求 -x attributes String to insert as table attributes 插入字符串作为表格属性 -y attributes String to insert as tr attributes 插入字符串作为tr属性 -z attributes String to insert as td or th attributes 插入字符串作为th属性 -C attribute Add cookie, eg. ‘Apache=1234’. (repeatable) 添加cookie，可重复 -H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’, Inserted after all normal header lines. (repeatable) 添加任意的头信息，可重复 -A attribute Add Basic WWW Authentication, the attributes ,are a colon separated username and password. 添加基础的www认证、属性，是一个以冒号分割的账号与密码 -P attribute Add Basic Proxy Authentication, the attributes ,are a colon separated username and password. 添加基本的代理身份验证、属性，是一个以冒号分隔的用户名和密码。 -X proxy:port Proxyserver and port number to use 使用的代理服务和对应端口号 -V Print version number and exit 直接输出版本号退出 -k Use HTTP KeepAlive feature 使用Http KeepAlice特性 -d Do not show percentiles served table. -S Do not show confidence estimators and warnings. 不显示confidence estimators和警告 -q Do not show progress when doing more than 150 requests 当超过150个请求的时候不显示进程 -l Accept variable document length (use this for dynamic pages) 接受可变文档长度(用于动态页面) -g filename Output collected data to gnuplot format file. 以gnuplot格式文件输出收集的数据。 -e filename Output CSV file with percentages served 以CSV文件的方式输出命中的服务 -r Don’t exit on socket receive errors. 返回error时不要终端socket -m method Method name 方法名 -h Display usage information (this message) 显示使用信息 （2）返回结果的说明： 字段名 解释 Document Path 测试页面 Document Length 页面大小 Concurrency Level 并发量 Time taken for tests 整个测试持续的时间 Complete requests 完成的请求数量 Failed requests 失败的请求数量 Total transferred 所有请求的响应数据的长度总和，包括每个http响应数据的头信息和正文数据的长度，这里不包括http请求数据的长度。仅仅为WEB服务器流向用户PC的应用层数据总长度 HTML transferred 所有请求的响应数据中正文数据的总和，数量上 = Total transferred - 响应数据头信息的长度 Requests per second 吞吐率,相当于LR中的每秒事务数，后面括号中的mean表示这是一个平均值 Time per request 用户平均请求等待时间,相当于LR中的平均事务响应时间，后面括号中的mean表示这是一个平均值 Time per request 服务器平均请求等待时间,每个连接请求实际运行时间的平均值 Transfer rate （单位时间内从服务器获取的数据长度）平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题。计算公式：（Total transferred : Time taken for tests） 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79806358]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
</search>
