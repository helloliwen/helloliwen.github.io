<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【LeetCode】45. Jump Game II]]></title>
    <url>%2Fdc64a916.html</url>
    <content type="text"><![CDATA[1.题目描述Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 Example: Input: [2,3,1,1,4]Output: 2Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Note: You can assume that you can always reach the last index. 2.SolutionsThe main idea is based on greedy. Let’s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following: 主要思想是基于贪婪。 假设当前跳跃的范围是[curBegin，curEnd]，curFarthest是[curBegin，curEnd]中所有点都可以达到的最远点。 一旦当前点达到curEnd，然后触发另一次跳转，并使用curFarthest设置新的curEnd，然后保持上述步骤，如下所示： 1234567891011public static int jump(int[] nums) &#123; int jumps = 0, curEnd = 0, curFarthest = 0; for (int i = 0; i &lt; nums.length - 1; i++) &#123; curFarthest = Math.max(curFarthest, i + nums[i]); if (i == curEnd) &#123; jumps++; curEnd = curFarthest; &#125; &#125; return jumps;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】44. Wildcard Matching]]></title>
    <url>%2F7463a464.html</url>
    <content type="text"><![CDATA[1.题目描述Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for &#39;?&#39;and &#39;*&#39;. 12&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。 ‘?’ 可以匹配任何单个字符。‘*’ 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 Example 1: Input:s = “aa”p = “a”Output: falseExplanation: “a” does not match the entire string “aa”. Example 2: Input:s = “aa”p = “*“Output: trueExplanation: ‘*’ matches any sequence. Example 3: Input:s = “cb”p = “?a”Output: falseExplanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’. Example 4: Input:s = “adceb”p = “*a*b”Output: trueExplanation: The first ‘*‘ matches the empty sequence, while the second ‘*’ matches the substring “dce”. Example 5: Input:s = “acdcb”p = “a*c?b”Output: false 2.SolutionsThe original post has DP 2d array index from high to low, which is not quite intuitive. Below is another 2D dp solution. Ideal is identical. dp[i][j] denotes whether s[0….i-1] matches p[0…..j-1], First, we need to initialize dp[i][0], i= [1,m]. All the dp[i][0] should be false because p has nothing in it. Then, initialize dp[0][j], j = [1, n]. In this case, s has nothing, to get dp[0][j] = true, p must be ‘‘, ‘‘, ‘‘,etc. Once p.charAt(j-1) != ‘*’, all the dp[0][j] afterwards will be false. Then start the typical DP loop. Though this solution is clear and easy to understand. It is not good enough in the interview. it takes O(mn) time and O(mn) space. Improvement: 1) optimize 2d dp to 1d dp, this will save space, reduce space complexity to O(N). 2) use iterative 2-pointer. 123456789101112131415161718192021222324252627public boolean isMatch_2d_method(String s, String p) &#123; int m=s.length(), n=p.length(); boolean[][] dp = new boolean[m+1][n+1]; dp[0][0] = true; for (int i=1; i&lt;=m; i++) &#123; dp[i][0] = false; &#125; for(int j=1; j&lt;=n; j++) &#123; if(p.charAt(j-1)=='*')&#123; dp[0][j] = true; &#125; else &#123; break; &#125; &#125; for(int i=1; i&lt;=m; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if (p.charAt(j-1)!='*') &#123; dp[i][j] = dp[i-1][j-1] &amp;&amp; (s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='?'); &#125; else &#123; dp[i][j] = dp[i-1][j] || dp[i][j-1]; &#125; &#125; &#125; return dp[m][n];&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】43. Multiply Strings]]></title>
    <url>%2Fac8eaac7.html</url>
    <content type="text"><![CDATA[1.题目描述Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 Example 1: Input: num1 = “2”, num2 = “3”Output: “6” Example 2: Input: num1 = “123”, num2 = “456”Output: “56088” Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. 2.SolutionsRemember how we do multiplication? Start from right to left, perform multiplication on every pair of digits, and add them together. Let’s draw the process! From the following draft, we can immediately conclude: 从右到左开始，对每对数字执行乘法运算，并将它们加在一起。 让我们画出这个过程吧！ 从以下草案中，我们可以立即得出结论： 1`num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` 2.Solutions12345678910111213141516171819202122public static String multiply(String num1, String num2) &#123; int m = num1.length(), n = num2.length(); int[] indices = new int[m + n]; for(int i = m - 1; i &gt;= 0; i--) &#123; for(int j = n - 1; j &gt;= 0; j--) &#123; int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + indices[p2]; indices[p1] += sum / 10; indices[p2] = sum % 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int p : indices) //去掉前面的0 if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p); return sb.length() == 0 ? "0" : sb.toString();&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】42. Trapping Rain Water]]></title>
    <url>%2Fc1b9387f.html</url>
    <content type="text"><![CDATA[1.题目描述Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 2.SolutionsIndeed this question can be solved in one pass and O(1) space, but it’s probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. The main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar’s index (il), and right larger bar’s index(ir). So that the water is (min(height[il],height[ir])-height[bot])*(ir-il-1). use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il. To implement this we use a stack that store the indices(指数/索引) with decreasing bar height. Once we find a bar who’s height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. 123456789101112131415161718192021public int trap(int[] height) &#123; if (height == null || height.length &lt; 2) return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int water = 0, i = 0; while (i &lt; height.length) &#123; if (stack.isEmpty() || height[i] &lt;= height[stack.peek()]) &#123; stack.push(i++); &#125; else &#123; int pre = stack.pop(); if (!stack.isEmpty()) &#123; // find the smaller height between the two sides int minHeight = Math.min(height[stack.peek()], height[i]); // calculate the area water += (minHeight - height[pre]) * (i - stack.peek() - 1); &#125; &#125; &#125; return water;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】41. First Missing Positive]]></title>
    <url>%2Fe81613bd.html</url>
    <content type="text"><![CDATA[1.题目描述Given an unsorted integer array, find the smallest missing positive integer. 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 Example 1: Input: [1,2,0]Output: 3 Example 2: Input: [3,4,-1,1]Output: 2 Example 3: Input: [7,8,9,11,12]Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 2.Solutions 这里的关键是使用交换来保持恒定的空间并且还利用数组的长度，这意味着最多可以有n个正整数。 所以每次遇到一个有效的整数，找到它的正确位置和交换，否则继续。 1234567891011121314151617181920public static int firstMissingPositive(int[] nums) &#123; int i = 0; while(i &lt; nums.length)&#123; if(nums[i] &gt;= 1 &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[nums[i]-1] != nums[i]) &#123; swap(nums, i, nums[i]-1); &#125;else&#123; i++; &#125; &#125; i = 0; while(i &lt; nums.length &amp;&amp; nums[i] == i+1) i++; return i+1;&#125;private static void swap(int[] nums, int i, int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】40. Combination Sum II]]></title>
    <url>%2F9b36a93.html</url>
    <content type="text"><![CDATA[1.题目描述Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Example 2: Input: candidates = [2,5,2,1,2], target = 5,A solution set is:[ [1,2,2], [5]] 2.Solutions回溯算法，也是使用了DFS。 1234567891011121314151617181920212223242526public static List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;Integer&gt;(), nums, target, 0); return list;&#125;public static void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; //不能使用数组中的重复数字，所以可以去掉重复路径。如果可以使用重复数字，那么这一步就不行。 if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue;//去除搜索时的重复路径 tempList.add(nums[i]); //i+1表明不能使用数组中的重复数字 backtrack(list, tempList, nums, remain-nums[i], i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】39. Combination Sum]]></title>
    <url>%2Fd88a68c8.html</url>
    <content type="text"><![CDATA[1.题目描述Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. 给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。 candidates中的数字可以无限制重复被选取。 Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 Example 1: Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 2: Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 2.Solutions1234567891011121314151617181920212223public static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;Integer&gt;(), nums, target, 0); return list;&#125;//典型的回溯处理方法public static void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; //枚举i所有可能的路径 for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); //not i + 1 because we can reuse same elements backtrack(list, tempList, nums, remain - nums[i], i); tempList.remove(tempList.size() - 1);//回溯前的清理工作 &#125; &#125;&#125; 3.举一反三This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets(子集), Permutations(全排列), Combination Sum(组合总和) and Palindrome Partitioning(分割回文串). Subsets : https://leetcode.com/problems/subsets/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 1234567891011121314151617public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 1234567891011121314151617181920212223242526public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】37. Sudoku Solver]]></title>
    <url>%2F6b1ed872.html</url>
    <content type="text"><![CDATA[1.题目描述Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character &#39;.&#39;. 编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 ‘.’ 表示。 一个数独。 答案被标成红色。 Note: 给定的数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 2.SolutionsStraight Forward Java Solution Using Backtracking Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code. 12345678910111213141516171819202122232425262728293031323334353637public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0) return; solve(board);&#125;public boolean solve(char[][] board)&#123; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == '.')&#123; for(char c = '1'; c &lt;= '9'; c++)&#123;//trial. Try 1 through 9 if(isValid(board, i, j, c))&#123; board[i][j] = c; //Put c for this cell if(solve(board)) return true; //If it's the solution return true else board[i][j] = '.'; //Otherwise go back &#125; &#125; return false; &#125; &#125; &#125; return true;&#125;private boolean isValid(char[][] board, int row, int col, char c)&#123; for(int i = 0; i &lt; 9; i++) &#123; if(board[i][col] != '.' &amp;&amp; board[i][col] == c) return false; //check row if(board[row][i] != '.' &amp;&amp; board[row][i] == c) return false; //check column if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' &amp;&amp; board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block &#125; return true;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】36. Valid Sudoku]]></title>
    <url>%2F793fe09c.html</url>
    <content type="text"><![CDATA[1.题目描述Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;. 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 Example 1: Input:[ [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”], [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”], [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”], [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”], [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”], [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”], [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”], [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”], [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]Output: true Example 2: Input:[[“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid. 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character &#39;.&#39;. The given board size is always 9x9. 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 2.Solutions1234567891011121314public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; char number = board[i][j]; if (number != '.') if (!seen.add(number + " in row " + i) || !seen.add(number + " in column " + j) || !seen.add(number + " in block " + i/3 + "-" + j/3)) return false; &#125; &#125; return true;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】35. Search Insert Position]]></title>
    <url>%2Ffa60640c.html</url>
    <content type="text"><![CDATA[1.题目描述Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 Example 1: Input: [1,3,5,6], 5Output: 2 Example 2: Input: [1,3,5,6], 2Output: 1 Example 3: Input: [1,3,5,6], 7Output: 4 Example 4: Input: [1,3,5,6], 0Output: 0 2.Solutions123456789101112public static int searchInsert(int[] nums, int target) &#123; int low = 0,high = nums.length; int mid = 0; while(low &lt; high)&#123; mid = low + (high - low &gt;&gt; 1);// low &lt;= mid &lt; high if(nums[mid] &gt;= target)&#123; high = mid; // high always decreases (even high-low==1) &#125;else low = mid + 1;//low always increases &#125; return low;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】34. Find First and Last Position of Element in Sorted Array]]></title>
    <url>%2F2a1e5e50.html</url>
    <content type="text"><![CDATA[1.题目描述Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 Example 1: Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 2.Solutions1234567891011121314151617181920212223242526272829public static int[] searchRange(int[] nums, int target) &#123; int start = firstGreaterOrEqual(nums, target); if (start == nums.length || nums[start] != target) &#123; return new int[]&#123;-1, -1&#125;; &#125; int end = firstGreaterOrEqual(nums, target + 1) - 1; return new int[]&#123;start, end&#125;;&#125;/** * find the first number that is greater than or equal to target. * could return nums.length if target is greater than nums[nums.length-1]. * actually this is the same as lower_bound in C++ STL. */private static int firstGreaterOrEqual(int[] nums, int target) &#123; int low = 0, high = nums.length; while (low &lt; high) &#123; int mid = low + (high - low &gt;&gt; 1); //low &lt;= mid &lt; high if (nums[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; //should not be mid-1 when nums[mid]==target. //could be mid even if nums[mid]&gt;target because mid&lt;high. high = mid; &#125; &#125; return low;&#125; target + 1可能造成内存溢出。 测试用例：nums = [1,1,2,2,5,2147483647]，target=2147483647 输出：[5,-1] 因为target+1之后变成了-2147483648，然后第二次调用firstGreaterOrEqual方法返回0，所以end=-1。 附：二分查找 循环版本： 1234567891011121314151617public static int binarySearch(int[] arr, int target)&#123; int result = -1; int start = 0,end = arr.length - 1; while (start &lt;= end)&#123; int mid = start + (end - start &gt;&gt; 1); //防止溢位 if (arr[mid] &gt; target) end = mid - 1; else if (arr[mid] &lt; target) start = mid + 1; else &#123; result = mid ; break; &#125; &#125; return result;&#125; 递归版本： 123456789101112public static int binarySearch(int[] arr, int start, int end, int target)&#123; if (start &gt; end) return -1; int mid = start + (end - start &gt;&gt; 1);//防止溢位 if (arr[mid] &gt; target) return binarySearch(arr, start, mid - 1, target); if (arr[mid] &lt; target) return binarySearch(arr, mid + 1, end, target); return mid; &#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】33. Search in Rotated Sorted Array]]></title>
    <url>%2F66578634.html</url>
    <content type="text"><![CDATA[1.题目描述Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 2.Solutions123456789101112131415161718192021222324252627282930313233public static int search(int[] nums, int target) &#123; if(nums.length == 0) return -1; int minIdx = findMinIdx(nums); if (target == nums[minIdx]) return minIdx; int len = nums.length; int start = (target &lt;= nums[len - 1]) ? minIdx : 0; int end = (target &gt; nums[len - 1]) ? minIdx : len - 1; while (start &lt;= end) &#123; int mid = start + ((end - start) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (target &gt; nums[mid]) start = mid + 1; else end = mid - 1; &#125; return -1;&#125;public static int findMinIdx(int[] nums) &#123; int start = 0, end = nums.length - 1; while (start &lt; end) &#123; int mid = start + ((end - start) &gt;&gt; 1); if (nums[mid] &gt; nums[end]) start = mid + 1; else end = mid; &#125; return start;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】32. Longest Valid Parentheses]]></title>
    <url>%2F826765dd.html</url>
    <content type="text"><![CDATA[1.题目描述Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 Example 1: Input: “(()”Output: 2Explanation: The longest valid parentheses substring is “()” Example 2: Input: “)()())”Output: 4Explanation: The longest valid parentheses substring is “()()” 2.SolutionsThis is my DP solution, just one pass V[i] represents number of valid parentheses matches from S[j to i] (j&lt;i) V[i] = V[i-1] + 2 + previous matches V[i- (V[i-1] + 2) ] if S[i] = ‘)’ and ‘(‘ count &gt; 0 123456789101112131415161718public int longestValidParentheses(String s) &#123; char[] S = s.toCharArray(); int[] V = new int[S.length]; int open = 0; int max = 0; for (int i=0; i&lt;S.length; i++) &#123; if (S[i] == '(') open++; if (S[i] == ')' &amp;&amp; open &gt; 0) &#123; V[i] = 2+ V[i-1];// matches found if(i-V[i]&gt;0)// add matches from previous V[i] += V[i-V[i]]; open--; &#125; if (V[i] &gt; max) max = V[i]; &#125; return max;&#125; The idea is simple, we only update the result (max) when we find a “pair”. If we find a pair. We throw this pair away and see how big the gap is between current and previous invalid. EX: “( )( )” stack: -1, 0, when we get to index 1 “)”, the peek is “(“ so we pop it out and see what’s before “(“. In this example it’s -1. So the gap is “current_index” - (-1) = 2. The idea only update the result (max) when we find a “pair” and push -1 to stack first covered all edge cases. 1234567891011121314public int longestValidParenthesesUseStack(String s) &#123; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int result = 0; stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ')' &amp;&amp; stack.size() &gt; 1 &amp;&amp; s.charAt(stack.peek()) == '(') &#123; stack.pop(); result = Math.max(result, i - stack.peek()); &#125; else &#123; stack.push(i); &#125; &#125; return result;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】25. Reverse Nodes in k-Group]]></title>
    <url>%2Fb452e4fc.html</url>
    <content type="text"><![CDATA[1.题目描述Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 2.Solutions123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode curr = head; int count = 0; while (curr != null &amp;&amp; count != k) &#123; // find the k+1 node curr = curr.next; count++; &#125; if (count == k) &#123; // if k+1 node is found curr = reverseKGroup(curr, k); // reverse list with k+1 node as head // head - head-pointer to direct part, // curr - head-pointer to reversed part; while (count-- &gt; 0) &#123; // reverse current k-group: ListNode tmp = head.next; // tmp - next head in direct part head.next = curr; // preappending "direct" head to the reversed list curr = head; // move head of reversed part to a new node head = tmp; // move "direct" head to the next node in direct part &#125; head = curr; &#125; return head;&#125; 【链表】打卡9：将单链表的每K个结点之间逆序 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】24. Swap Nodes in Pairs]]></title>
    <url>%2F664d5542.html</url>
    <content type="text"><![CDATA[1.题目描述Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 Example: Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 2.Solutions递归版本： 12345678public static ListNode swapPairs(ListNode head) &#123; if ((head == null)||(head.next == null)) return head; ListNode node = head.next; head.next = swapPairs(head.next.next); node.next = head; return node;&#125; 迭代版本： 1234567891011121314public static ListNode swapPairsWithIteration(ListNode head)&#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; while (current.next != null &amp;&amp; current.next.next != null) &#123; ListNode first = current.next; ListNode second = current.next.next; first.next = second.next; current.next = second; current.next.next = first; current = current.next.next; &#125; return dummy.next;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】23. Merge k Sorted Lists]]></title>
    <url>%2F2997e0e6.html</url>
    <content type="text"><![CDATA[1.题目描述Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 Example: Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 2.Solutions迭代、分治版本： 123456789101112131415161718192021222324252627public static ListNode mergeKLists(ListNode[] lists)&#123; return partion(lists,0,lists.length-1);&#125;public static ListNode partion(ListNode[] lists,int s,int e)&#123; if(s==e) return lists[s]; if(s&lt;e)&#123; int q=s+(e-s)/2;// avoid integer overflow, ListNode l1=partion(lists,s,q); ListNode l2=partion(lists,q+1,e); return merge(l1,l2); &#125;else return null;&#125;//This function is from Merge Two Sorted Lists.public static ListNode merge(ListNode l1,ListNode l2)&#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val)&#123; l1.next=merge(l1.next,l2); return l1; &#125;else&#123; l2.next=merge(l1,l2.next); return l2; &#125;&#125; 优先队列： If someone understand how priority queue works, then it would be trivial to walk through the codes. 12345678910111213141516171819202122232425262728293031public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists==null||lists.size()==0) return null; PriorityQueue&lt;ListNode&gt; queue= new PriorityQueue&lt;ListNode&gt;(lists.size(),new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode o1,ListNode o2)&#123; if (o1.val&lt;o2.val) return -1; else if (o1.val==o2.val) return 0; else return 1; &#125; &#125;); ListNode dummy = new ListNode(0); ListNode tail=dummy; for (ListNode node:lists) if (node!=null) queue.add(node); while (!queue.isEmpty())&#123; tail.next=queue.poll(); tail=tail.next; if (tail.next!=null) queue.add(tail.next); &#125; return dummy.next;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】22. Generate Parentheses]]></title>
    <url>%2Fb2297cf9.html</url>
    <content type="text"><![CDATA[1.题目描述Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 2.Solutions12345678910111213141516171819202122/** * The idea here is to only add '(' and ')' * that we know will guarantee us a solution (instead of adding 1 too many close). * Once we add a '(' we will then discard it and try a ')' which can only close a valid '('. * Each of these steps are recursively called. */public static List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list, "", 0, 0, n); return list;&#125;public static void backtrack(List&lt;String&gt; list, String str, int open, int close, int max)&#123; if(str.length() == max*2)&#123; list.add(str); return; &#125; if(open &lt; max) backtrack(list, str+"(", open+1, close, max); if(close &lt; open) backtrack(list, str+")", open, close+1, max);&#125; I would like to share my understanding about this algorithm. Hope will make people easier to understand the beauty of this code. Chip in your ideas if I am wrong. The goal is to print a string of “(“ ,”)” in certain order. The length of string is 2n. The constraints(限制) are that “(“s need to match “)”s. Without constraints, we just simply print out “(“ or “)” until length hits n. So the base case will be length ==2n, recursive(递归) case is print out “(“ and “)”. The code will look like 12345678//base caseif(string length == 2*n) &#123; add(string); return;&#125;//recursive caseadd a “(“add a “)" Let’s add in constraints now. We need to interpret the meanings of constraints. First, the first character should be “(“. Second, at each step, you can either print “(“ or “)”, but print “)” only when there are more “(“s than “)”s. Stop printing out “(“ when the number of “(“ s hit n. The first actually merges into the second condition. The code will be: 123456789101112//base caseif(string length == 2*n) &#123; add(string); return;&#125;//recursive caseif(number of “(“s &lt; n)&#123; add a “(“&#125;if(number of “(“s &gt; number of “)”s)&#123; add a “)"&#125; 程序运行图： （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】21. Merge Two Sorted Lists]]></title>
    <url>%2Fd9f1239e.html</url>
    <content type="text"><![CDATA[1.题目描述Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 2.Solutions递归版本： 1234567891011public static ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 迭代版本： 123456789101112131415161718public static ListNode mergeTwoListsIterative(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; ListNode start = new ListNode(0); ListNode cur = start; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; cur.next = l1; l1 = l1.next; &#125;else&#123; cur.next = l2; l2 = l2.next; &#125; cur = cur.next; &#125; cur.next = l1 == null ? l2 : l1; return start.next;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】20. Valid Parentheses]]></title>
    <url>%2F8ccacc1f.html</url>
    <content type="text"><![CDATA[1.题目描述Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 Example 1: Input: “()”Output: true Example 2: Input: “()[]{}”Output: true Example 3: Input: “(]”Output: false Example 4: Input: “([)]”Output: false Example 5: Input: “{[]}”Output: true 2.Solutions12345678910111213141516171819public static boolean isValid(String s) &#123; //按位与运算符，只有对应的两个二进位均为1时，结果位才为1，否则为0。 //s.length() &amp; 1 = 1,s.length()为奇数 if((s.length() &amp; 1) == 1) return false; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; //目前只有三种符号，扩展的话可以使用HashMap switch (c) &#123; case '(': stack.push(')'); break; case '&#123;': stack.push('&#125;'); break; case '[': stack.push(']'); break; case ')': case '&#125;': case ']': if(stack.isEmpty() || stack.pop() != c) return false; &#125; &#125; return stack.isEmpty();&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】19. Remove Nth Node From End of List]]></title>
    <url>%2Ffc2aa4a3.html</url>
    <content type="text"><![CDATA[1.题目描述Given a linked list, remove the n-th node from the end of list and return its head. 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up（进阶）: Could you do this in one pass? 你能尝试使用一趟扫描实现吗？ 2.Solutions快慢指针（双指针），把慢指针定位到要删除节点的前面就可以了。 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; ListNode head = new ListNode(1); ListNode node = head; int i = head.val; while(++i&lt;6)&#123; node.next = new ListNode(i); node = node.next; &#125; node = removeNthFromEnd(head,1); while(node!=null)&#123; System.out.print(node.val+" "); node = node.next; &#125;&#125;public static ListNode removeNthFromEnd(ListNode head, int n) &#123; //如果head.length=1并且只删除这一个节点，就没用了 //ListNode slow = head,fast = head; ListNode start = new ListNode(0); start.next = head; ListNode slow = start,fast = start; //Move fast in front so that the gap between slow and fast becomes n for (int i = 0; i &lt;= n; i++) &#123; fast = fast.next; &#125; //Move fast to the end, maintaining the gap while(fast!=null)&#123; slow = slow.next; fast = fast.next; &#125; //删除节点 slow.next = slow.next.next; return start.next;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】17. Letter Combinations of a Phone Number]]></title>
    <url>%2F582f38e.html</url>
    <content type="text"><![CDATA[1.题目描述Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 Example: Input: “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 2.Solutions使用FIFO队列解决： 12345678910111213141516public static List&lt;String&gt; letterCombinations(String digits) &#123; LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;(); if(digits.isEmpty()) return queue; String[] mapping = &#123;"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; queue.offer(""); for(int i =0; i&lt;digits.length();i++)&#123; int str = Character.getNumericValue(digits.charAt(i)); while(queue.peek().length()==i)&#123; String rows = queue.poll(); for(char s : mapping[str].toCharArray()) queue.offer(rows+s); &#125; &#125; return queue;&#125; 这是一个迭代的解决方案。 对于添加的每个数字，删除并复制队列中的每个元素，并将可能的字母添加到每个元素，然后再将更新的元素添加回队列。 重复此过程，直到迭代所有数字。 但是没有回溯（BFS或者DFS）版本。 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】14. Longest Common Prefix]]></title>
    <url>%2Fe4d324d5.html</url>
    <content type="text"><![CDATA[1.题目描述Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 Example 1: Input: [“flower”,”flow”,”flight”]Output: “fl” Example 2: Input: [“dog”,”racecar”,”car”]Output: “”Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 2.Solutions1234567891011121314public static String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0) return ""; String pre = strs[0]; for (int i = 1; i &lt; strs.length; i++) &#123; //Meanwhile startsWith() is faster than indexOf() in JAVA world while(!strs[i].startsWith(pre)) pre = pre.substring(0,pre.length()-1); //第一轮结束，pre为空字符串，那么就没有最长相同公共前缀， if(pre.equals("")) return ""; &#125; return pre;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机 JVM高级特性与最佳实践 第2版》读书笔记3]]></title>
    <url>%2Fcea12f28.html</url>
    <content type="text"><![CDATA[第五部分 高效并发 并发处理的广泛应用是使得Amdahl定律代替摩尔定律成分为计算及性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。 第12章 Java内存模型与线程1.概述 多任务处理在现代计算机操作系统中几乎已是一项必备的功能了；原因不仅是因为计算机的运算能力强大，另一个很重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大（开飞机的和骑驴车的打交道——缓存、让计算机同时处理多任务）。 除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景。 服务端是Java语言最擅长的领域之一，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持，幸好Java语言和虚拟机提供了许多工具，把并发编码的门槛降低了不少。 2.硬件的效率与一致性 绝大多数的运算任务不可能只靠处理器计算就能完成，处理器至少要与内存交互，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了（计算机的所有问题都可以通过增加一个中间层来解决）。 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。 本章将会多次提到内存模型一词，可以理解在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问具有很高的可比性。 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的； 3.Java内存模型 Java虚拟机规范中视图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。 3.1 主内存与工作内存 Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享。 Java内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量； 这里所讲的主内存、工作内存与第二章所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的；线程、主内存和工作内存的关系如下所示： 线程、主内存和工作内存的关系 对于JMM与JVM本身的内存模型，如果一定要勉强对应，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就是物理内存，而为了获取更好的执行速度。虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为运行时主要访问——读写的是工作内存。 3.2 内存间交互操作 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下八种操作来完成。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量的某些操作在某些平台允许有例外）： lock（锁定） unlock（解锁） read（读取） load（载入） use（使用） assign（赋值） store（存储） write（写入） 基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这八种操作去定义Java内存模型的访问协议了，后面将会介绍一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。 3.3 对于volatile型变量的特殊规则 关键字v olatile可以说是Java虚拟机提供的最轻量级的同步机制； 当一个变量定义为volatile之后，它将具备两种特性：第一是保证此变量对所有线程的可见性。这里的可见性是指当一个线程修改了这个变量的值，新的值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通的变量的值在线程间传递均需要通过主内存来完成；另外一个是禁止指令重排序优化。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 volatile变量在各个线程的工作内存中不存在一致性问题，但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。 在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性：运算结果并不依赖变量的当前值或者能够确保只有单一的线程修改变量的值、变量不需要与其他的状态变量共同参与不变约束。 volatile变量读操作的性能消耗与普通变量几乎没有任何差别，但是写操作则可能会慢一些；不过大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。 3.4 对于long和double型变量的特殊规则 允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定。 但允许虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待。 3.5 原子性、可见性与有序性 原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write；在synchronized块之间的操作也具备原子性； 可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了volatile之外，Java还有synchronized和final关键字能实现可见性； 有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性； 3.6 先行发生原则 先行发生是Java内存模型中定义的两项操作之间的偏序关系。如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等； 下面是Java内存模型下一些天然的先行发生关系：程序次序规则、管程锁定规则、volatile变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性； 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准； 4.Java与线程4.1 线程的实现 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度； Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的； 实现线程主要有三种方式：使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）、使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）和使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险）； 对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模式就是一对一的； 4.2 Java线程调度 线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（线程的执行时间由线程本身来控制）和抢占式线程调度（线程由系统来分配执行时间，线程的切换不由线程本身来决定）； Java语言一共设置了10个级别的线程优先级，不过线程优先级并不是太靠谱，原因就是操作系统的线程优先级不见得总是与Java线程的优先级一一对应，另外优先级还可能被系统自行改变。 4.3 状态转换 Java语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。它们之间相互的转换关系如下所示： 线程状态转换关系 Java多线程、反射与克隆 5.本章小结 本章我们首先了解了虚拟机Java内存模型的结构及操作，然后讲解了原子性、可见性、有序性在Java内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在Java语言之中是如何实现的。 在本章主要介绍了虚拟机如何实现并发，而在下一章我们主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。 第13章 线程安全与锁优化1.概述 首先需要保证并发的正确性，然后在此基础上实现高效（安全、高效）。 2.线程安全 Brian Goetz对线程安全有一个比较恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 2.1 Java语言中的线程安全 我们可以将Java语言中各个操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立； 不可变：不可变（Immutable）的对象一定是线程安全的。不可变带来的安全性是最简单和最纯粹的，如final的基本数据类型；如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。比如String类的substring、replace方法，Number类型的大部分子类都符合不可变要求的类型。但是AtomicInteger和AtomicLong则并非不可变的。 线程绝对安全：Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全；比如java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了。 相对线程安全：是我们通常意义上所讲的线程安全，在Java语言中，大部分的线程安全类都属于这种类型。 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况。 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java语言中很少出现。 2.2 线程安全的实现方法 互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。Java中最基本的互斥同步手段就是synchronized关键字，它对同一个线程来说是可重入的且会阻塞后面其他线程的进入；另外还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步，相比synchronized关键字ReentrantLock增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件； 非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略；随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步；Java并发包的整数原子类，其中的compareAndSet和getAndIncrement等方法都使用了Unsafe类的CAS操作。 无同步方案：要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码 【多线程】如何保证线程安全 3.锁优化3.1 自旋锁与自适应自旋 互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这些技术就是所谓的自旋锁； 在JDK 1.6已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源； 在JDK 1.6中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定； 3.2 锁消除 锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除； 锁消除的主要判断依据来源于逃逸分析的数据支持； 3.3 锁粗化 原则上总是推荐将同步块的作用范围限制得尽量小 – 只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁； 但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗； 3.4 轻量级锁 轻量级锁是JDK 1.6之中加入的新型锁机制，它是相对于使用操作系统互斥量来实现的传统锁而言的。它并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从HotSpot虚拟机的对象的内存布局开始介绍。HotSpot虚拟机的对象头分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，这部分官方称之为Mark Word，是实现轻量级锁和偏向锁的关键；另外一部分用于存储指向方法区对象类型数据的指针。 Mark Word被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，在32位的HotSpot虚拟机中对象未被锁定的状态下，25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0；在其他状态（轻量级锁定、重量级锁定、GC标志、可偏向）下对象的存储内容如下： HotSpot虚拟机对象头 在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝（官方称之为Displaced Mark Word）。然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果更新成功了那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为“00”，即表示此对象处于轻量级锁定状态；如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了；如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进行阻塞状态； 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。 3.5 偏向锁 偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了； 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步； 假设当前虚拟机启动了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式；同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中；如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；偏向锁、轻量级锁的状态转化以及对象Mark Work的关系如下图所示： 偏向锁、轻量级锁的状态转化 偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化； 4.本章小结 本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运行原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机 JVM高级特性与最佳实践 第2版》读书笔记2]]></title>
    <url>%2Fb9a61fbe.html</url>
    <content type="text"><![CDATA[第三部分 虚拟机执行子系统 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。（需要《编译原理》、《操作系统》相关知识） 第6章 类文件结构《深入理解Java虚拟机》读书笔记4：类文件结构 第7章 虚拟机类加载机制《深入理解Java虚拟机》读书笔记5：类加载机制与字节码执行引擎 第8章 虚拟机字节码执行引擎《深入理解Java虚拟机》读书笔记5：类加载机制与字节码执行引擎 第9章 类加载及执行子系统的案例与实战《深入理解Java虚拟机》读书笔记5：类加载机制与字节码执行引擎 第四部分 程序编译与代码优化第10章 早期（编译期）优化《深入理解Java虚拟机》读书笔记6：程序编译与代码优化 第11章 晚期（运行期）优化《深入理解Java虚拟机》读书笔记6：程序编译与代码优化]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机 JVM高级特性与最佳实践 第2版》读书笔记]]></title>
    <url>%2Fcfa1c762.html</url>
    <content type="text"><![CDATA[第一部分 走近Java 世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。 第1章 走进Java1.Java优点 结构严谨、面向对象。 摆脱了硬件平台的束缚，实现“一次编写，到处运行”的理想 提供了相对安全的内存管理和访问机制 实现了热点代码监测和运行时编译及优化 有一套完善的应用程序接口以及无数来自商业机构和开源社区的第三方类库来帮助它实现各种各样的功能 认识这些技术运作的本质，是自己思考“程序这样写好不好”的基础和前提。 2.Java技术体系Sun官方所定义的Java技术体系包括： Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java API类库 来自商业机构和开源社区的第三方Java类库 其中，其中第1、2、4点统称为JDK（Java Development Kit），JDK是用于支持Java开发的最小环境，JRE是支持Java程序运行的标准环境，整个Java体系如下所示： 3.Java发展史 JDK 1.0：Java虚拟机、Applet、AWT等 JDK 1.1：JAR文件格式、JDBC、JavaBeans、RMI、内部类、反射 JDK 1.2：拆分为J2SE/J2EE/J2ME、内置JIT编译器、一系列Collections集合类 JDK 1.3：JNDI服务、使用CORBA IIOP实现RMI通信协议、Java 2D改进 JDK 1.4：正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器 JDK 1.5：自动装箱、泛型、动态注解、枚举、可变参数、遍历循环（foreach循环）、改进了Java内存模型、提供了java.util.concurrent并发包 JDK 1.6：提供动态语言支持、提供编译API和微型HTTP服务器API、虚拟机优化（锁与同步、垃圾收集、类加载等） JDK 1.7：G1收集器、加强对Java语言的调用支持、升级类加载架构 JDK 1.8：Lambda表达式等 4.Java虚拟机发展史 Sun Classic/Exact VM：Classic VM是第一款商用虚拟机，纯解析器方式来执行Java代码，如果要使用JIT编译器就必须进行外挂，解析器和编译器不能配合工作，编译器执行效率非常差；Exact VM是Sun虚拟机团队曾在Solaris平台发布的虚拟机，支持两级即时编译器、编译器和解释器混合工作、使用准确内存管理（虚拟机可以知道内存中某个位置的数据具体是什么类型），但很快就被HotSpot VM所取代 Sun HotSpot VM：Sun JDK和OpenJDK所带的虚拟机，目前使用范围最广；继承了前两款虚拟机的优点，还支持热点代码探测技术（通过计数器找出最具编译价值的代码）；2006年Sun公司宣布JDK包括HotSpot VM开源，在此基础上建立OpenJDK Sun Mobile-Embedded VM/Meta-Circular VM：还有一些Sun开发的面对移动和嵌入式发布的和实验性质的虚拟机 BEA JRockit/IBM J9 VM：JRockit VM号称是世界上最快的Java虚拟机，专注于服务器端应用，不包含解析器实现，全部靠即时编译器编译执行；J9 VM定位于HotSpot比较接近，主要目的是作为IBM公司各种Java产品的执行平台 Azul VM/BEA Liquid VM：特定硬件平台专有的高性能虚拟机 Apache Harmony/Google Android Dalvik VM：Apache Harmony包含自己的虚拟机和Java库，但没有通过TCK认证；Dalvik VM是Android平台的核心组成部分，其并没有遵循Java虚拟机规范，不能直接执行Class文件，使用的是寄存器架构而不是JVM常见的栈架构 Microsoft JVM及其他：微软曾经是Java技术的铁杆支持者，开发过Windows下性能最好的Java虚拟机，但后来被Sun起诉终止其发展 5.展望Java技术的未来 模块化、混合语言、多核并行、进一步丰富语法、64位虚拟机 第二部分 自动内存管理机制 Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 第2章 Java内存区域与内存溢出异常1.概述 对于Java程序员来说，在虚拟机自动内存管理机制下，不需要为new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。由虚拟机管理内存这一切看起来都很美好，但是一旦出现内存泄漏问题，如果不了解虚拟机的是怎样使用内存的，便难以定位，排查错误将会成为一项异常艰难的工作。 2.运行时数据区域 1.程序计数器（Program Counter Register） 一块较小的内存，可以看作是当前线程所执行的字节码的行号指示器。 在虚拟机概念模型里（各种虚拟机实现可能不一样），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 程序计数器是属于“线程私有”的内存：Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。 如果执行的是Java方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法则为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 2.Java虚拟机栈（Java Virtual Machine Stacks） Java虚拟机栈也是线程私有的； 描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程； 局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型；其所需的内存空间在编辑期完成分配，不会再运行期改变； 可能存在两种异常：StackOverflowError和OutOfMemoryError； 3.本地方法栈（Native Method Stack） 与虚拟机栈非常相似，只不过是为虚拟机使用到的Native方法服务； 可能存在两种异常：StackOverflowError和OutOfMemoryError； 4.Java堆（Java Heap） Java堆是被所有线程共享的，在虚拟机启动时创建； 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这分配； 是垃圾收集器管理的主要区域，可以分为新生代和老年代：一个Eden空间、两个Survivor空间——From Survivor空间、To Survivor空间； 可以物理不连续，只要逻辑上是连续的即可； 如果堆中没有内存完成实例分配也无法再扩展时，会抛出OutOfMemoryError异常； 5.方法区（Method Area） 是线程共享的区域； 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据； 该区域对于垃圾收集来说条件比较苛刻，但是还是非常有必要要进行回收处理。相对而言，垃圾收集行为在这个区域是比较少出现的，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载； 当无法满足内存分配需求时，将抛出OutOfMemoryError异常； 对于HotSpot虚拟机来说，很多人把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。JDK1.7中的HotSpot中，已经移除永久代。 6.运行时常量池（Runtime Constant Pool） 是方法区的一部分； Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放； Java虚拟机规范要求较少，通常还会把翻译出来的直接引用也存储在此； 另外一个重要特征是具备动态性，可以在运行期间将新的常量放入池中，如String类的intern()方法； 可能存在的异常：OutOfMemoryError； 7.直接内存（Direct Memory） 并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域； JDK 1.4的NIO（New Input/Output）类引入了基于通道（Channel）和缓冲区（Buffer）的IO方法，可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作以提升性能； 3.HotSpot虚拟机对象探秘 进一步了解虚拟机内存中数据的其他细节，比如它们是如何创建、如何布局以及如何访问的。下面以虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。 1.对象的创建 类加载检查：虚拟机遇到一条new指令时，先检查指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 为新生对象分配内存：接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便完全确定，为对象分配空间等同于把一块确定大小的内存从Java堆中划分出来。在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞（内存绝对规整，只要通过指针作为分界点标识）；而使用CMS这种基于Mark-Sweep算法收集器时，通常使用空闲列表（内存不规整，通过维护一个列表记录那块内存是可用的）。 并发情况下处理对象创建的线程安全问题：另外一个需要考虑的并发下的线程安全问题，有两种方案：一是分配内存空间的动作进行同步处理（实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性）；二是为每个线程分配一小块内存（称为本地线程分配缓冲，TLAB），各个线程独立分配，只有TLAB用完需要分配新的才需要同步锁定，虚拟机通过-XX:+/-UseTLAB参数来设定。 为分配到的内存空间初始化为零值：内存分配完后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），这保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序能访问到这些字段数据类型对应的零值（P220）。 虚拟机设置对象的对象头（Object Header）信息：包括对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象GC分代年龄等。 执行方法：把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 HotSpot解释器的代码片段：略 2.对象的内存布局 对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 对象头包括两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；官方称它为“Mark Word”。Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（并不是所有虚拟机都必须在对象数据上保留类型指针）。另外如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据。 实例数据部分是真正存储的有效信息，也是在代码中所定义的各种类型的字段内容。无论是父类继承的还是子类中定义的都需要记录下来。这部分存储的顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。 对齐填充不是必然存在的，主要是由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍。 3.对象的访问定位 Java程序需要通过栈上的reference数据来操作堆上的具体对象。而栈上的reference类型在虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆栈对象的具体位置，目前主流的访问方式有句柄和直接指针两种。 通过句柄：Java堆中划出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。其最大好处就是reference存储的是稳定的句柄地址，在对象被移到（垃圾收集时移到）只改变实例数据指针，而reference不需要修改； 通过直接指针：Java堆对象的布局中必须考虑如果放置访问类型数据的相关信息，而reference中存在的直接就是对象地址。其最大好处在于速度更快，节省了一次指针定位的时机开销。HotSpot采用该方式进行对象访问，但其他语言和框架采用句柄的也非常常见。 4.本章小结 学习了虚拟机的内存是如何划分的，对象是如何创建、布局和访问的，哪部分区域、什么样的代码和操作可能导致内存的溢出异常。 第3章 垃圾收集器与内存分配策略1.概述思考GC需要完成的3件事情： 哪些内存需要回收？ 什么时候回收？ 如何回收？ 再回头看看第二章介绍的Java内存运行时区域的各个部分： 程序计时器、虚拟机栈、本地方法栈：随线程而生，随线程而灭。栈帧随方法而进行出栈和入栈，每一个栈帧分配的内存在类结构确定就已知，因此这几个区域不需要考虑回收 对于Java堆和方法区，只有程序运行期间才知道会创建哪些对象，内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存 2.对象已死吗 在垃圾收集器进行回收前，第一件事就是确定这些对象哪些还存活，哪些已经死去。 1.引用计数法 给对象添加引用计数器，当有地方引用它时就加1，引用失效就减1，为0时就认为对象不再被使用可回收。该算法实现简单，判断高效，但并不被主流虚拟机采用，主要原因是它很难解决对象之间相互循环引用的问题。 2.可达性分析算法 通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），如果一个对象到GC Roots没有引用链相连，则该对象是不可用的。 在Java语言中，可作为GC Roots的对象包括： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 执行上下文 方法区中类静态属性引用的对象； 全局性引用 方法区中常量引用的对象； 全局性引用 本地方法栈中JNI（即一般说的Native方法）引用的对象； 3.再谈引用 在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用，这4种引用强度依次减弱。 4.生存还是死亡 要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法（如没有重写finalize方法或者已经被调用过则认为没有必要执行）。如果有必要执行则将该对象放置在F-Queue队列中，并在稍后由一个由虚拟机自己建立的、低优先级的Finalizer线程去执行它；稍后GC将对F-Queue中的对象进行第二次标记，如果对象还是没有被引用，则会被回收。 但是作者不建议通过finalize方法“拯救”对象，因为它运行代价高、不确定性大、无法保证各个对象的调用顺序。 5.回收方法区 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 一个无用的类需要满足以下三个条件： 该类的所有实例都已经被回收； 加载该类的ClassLoader已经被回收； 该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法； 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能（HotSpot提供-Xnoclassgc参数控制），以保证永久代不会溢出。 3.垃圾收集算法 标记-清除（Mark-Sweep）算法：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象；缺点是效率不高且容易产生大量不连续的内存碎片； 复制（Copying）算法：将可用内存分为大小相等的两块，每次只使用其中一块；当这一块用完了，就将还活着的对象复制到另一块上，然后把已使用过的内存清理掉。在HotSpot里，考虑到大部分对象存活时间很短将内存分为Eden和两块Survivor，默认比例为8:1:1。代价是存在部分内存空间浪费，适合在新生代使用； 标记-整理（Mark-Compact）算法：首先标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。适用于老年代。 分代收集算法：一般把Java堆分新生代和老年代，在新生代用复制算法，在老年代用标记-清理或标记-整理算法，是现代虚拟机通常采用的算法。 4.HotSpot的算法实现1.枚举根节点 由于要确保在一致性的快照中进行可达性分析，从而导致GC进行时必须要停顿所有Java执行线程（“Stop The World”） 在HotSpot里通过一组OopMap数据结构来知道哪些地方存放着对象引用 2.安全点（Safepoint） HotSpot只在特定的位置记录了OopMap，这些位置称为安全点（SafePoint）； 即程序执行时并非在所有地方都能停顿下来开始GC，只有到达安全点时才能暂停； 对于安全点基本上是以程序“是否具有让程序长时间执行的特征”（比如方法调用、循环跳转、异常跳转等）为标准进行选定的； 另外还需要考虑如果在GC时让所有线程都跑到最近的安全点上，有两种方案：抢先式中断和主动式中断（主流选择）。 3.安全区域 如果程序没有分配CPU时间（如线程处于Sleep或Blocked），此时就需要安全区域（Safe Region），其是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。 线程执行到安全区域时，首先标识自己已经进入了安全区域，这样JVM在GC时就不管这些线程了； 5.垃圾收集器 垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。 这里讨论JDK 1.7 Update 14之后的HotSpot虚拟机（此时G1仍处于实验状态），包含的虚拟机如下图所示（存在连线的表示可以搭配使用）： 1.Serial收集器 最基本、发展历史最悠久，在JDK 1.3之前是新生代收集的唯一选择； 是一个单线程的收集器（单线程并非指只会使用一个CPU或者一条收集线程，更重要的是在它进行垃圾收集时必须其他所有的工作线程，直到它收集结束）； 现在依然是虚拟机运行在Client模式下的默认新生代收集器，主要就是因为它简单而高效（没有线程交互的开销）； 2.ParNew收集器 其实就是Serial收集器的多线程版本； ParNew收集器在单CPU环境中绝对不会有比Serial收集器更好的效果； 是许多运行在Server模式下虚拟机首选的新生代收集器，重要原因就是除了Serial收集器外，只有它能与CMS收集器配合工作； 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态； 并发（Concurrent）：指用户线程与垃圾收集线程同时执行，用户线程在继续执行而垃圾收集程序运行在另外一个CPU上； 3.Parallel Scavenge收集器 新生代收集器，使用复制算法，并行的多线程收集器； 与其他收集器关注于尽可能缩短垃圾收集时用户线程停顿时间不同，它的目标是达到一个可控制的吞吐量； 高吞吐量可以高效率利用CPU时间，适合在后台运算而不需要太多交互的任务，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器； -XX:MaxGCPauseMillis参数可以设置最大停顿时间，而停顿时间缩短是以牺牲吞吐量和新生代空间来换取的； 另外它还支持GC自适应的调节策略，这是与ParNew收集器的一个重要区别。 4.Serial Old收集器 是Serial收集器的老年代版本，同样是单线程，使用标记-整理算法； 主要是给Client模式下的虚拟机使用的； 在Server模式下主要是给JDK 1.5及之前配合Parallel Scavenge使用或作为CMS收集器的后备预案； 5.Parallel Old收集器 是Parallel Scavenge的老年代版本，使用多线程和标记-整理算法； 是JDK 1.6中才开始提供的； 6.CMS收集器 是一种以获取最短回收停顿时间为目标的收集器，特别适合互联网站或者B/S的服务端； 主要包括4个步骤：初始标记、并发标记、重新标记和并发清除； 优点：并发收集、低停顿。并发低停顿收集器 还有3个明显的缺点：CMS收集器对CPU非常敏感、无法处理浮动垃圾、大量内存碎片产生； 4.G1收集器 一款面向服务端应用的垃圾收集器，后续会替换掉CMS垃圾收集器； 特点：并行与并发（充分利用多核多CPU缩短Stop-The-World时间）、分代收集（独立管理整个Java堆，但针对不同年龄的对象采取不同的策略）、空间整合（基于标记-整理）、可预测的停顿（将堆分为大小相等的独立区域，避免全区域的垃圾收集）； 关于Region：新生代和老年代不再物理隔离，只是部分Region的集合；G1跟踪各个Region垃圾堆积的价值大小，在后台维护一个优先列表，根据允许的收集时间优先回收价值最大的Region；Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，采用Remembered Set来避免全堆扫描； G1收集器运作大致分为几个步骤：初始标记（标记一下GC Roots能直接关联的对象并修改TAMS值，需要STW但耗时很短）、并发标记（从GC Root从堆中对象进行可达性分析找存活的对象，耗时较长但可以与用户线程并发执行）、最终标记（为了修正并发标记期间产生变动的那一部分标记记录，这一期间的变化记录在Remembered Set Log里，然后合并到Remembered Set里，该阶段需要STW但是可并行执行）、筛选回收（对各个Region回收价值排序，根据用户期望的GC停顿时间制定回收计划来回收）； 6.内存分配与回收策略 对象优先在新生代分配 大对象直接进入老年代 长期存活的对象将进入老年代 动态对象年龄判断：如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，大于或等于该年龄的对象直接进入老年代 空间分配担保：发生Minor GC前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间；如果不成立，虚拟机会查看HandlePromotionFailure设置值是否允许担保失败；如果允许继续检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果大于会尝试进行一次Minor GC；如果小于或者不允许冒险，会进行一次Full GC； 7.本章小结 本章介绍了垃圾回收算法、几款JDK 1.7中提供的垃圾收集器特点以及运作原理。内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一。然而没有固定收集器和参数组合，也没有最优的调优方法，需要根据实践了解各自的行为、优势和劣势。 第4章 虚拟机性能监控与故障处理工具1.概述 定位问题时，知识和经验是关键基础、数据（运行日志、异常堆栈、GC日志、线程快照、堆转储快照heapdump）是依据、工具是运用知识处理数据的手段。 2.jps: 虚拟机进程状况工具 功能：可以列出正在运行的虚拟机进程，并线上虚拟机执行的主类名称及其本地虚拟机唯一ID（LVMID）； 对于本地虚拟机来说，LVMID和操作系统的进程ID是一致的； 其他的工具通常都需要依赖jps获取LVMID； 主要选项：-q（只输出LVMID）、-m（输出传给main函数的参数）、-l（输出主类的全名）、-v（输出虚拟机启动JVM参数）； 3.jstat：虚拟机统计信息监视工具 功能：监视虚拟机各种运行状态信息，包括类装载、内存、垃圾收集、JIT等； 纯文本监控首选； 4.jinfo：Java配置信息工具 功能：实时地查看虚拟机各项参数。虽然jps -v可以查看虚拟机启动参数，但是无法查看一些系统默认的参数。 支持运行期修改参数的能力，格式为“jinfo -flag name=value pid”； 5.jmap：Java内存映像工具 功能：用于生成堆转储快照（一般称为heapdump或dump文件）； 其他可生成heapdump的方式：使用参数-XX:+HeapDumpOnOutOfMemoryError；使用参数-XX:+HeapDumpOnCtrlBreak然后使用Ctrl+Break生成；Linux系统使用kill -3生成； 另外它还可以查询finalize执行队列、Java堆和永久代的详细信息； 6.jhat：虚拟机堆转储快照分析工具 功能：用于分析jmap生成的heapdump。其内置了一个微型的HTTP服务器，可以在浏览器查看分析结果； 实际很少用jhat，主要有两个原因：一是分析工程会耗用服务器资源；二是功能相对BisualVM、IBM HeapAnalyzer较为简陋； 7.jstack：Java堆栈跟踪工具 功能：用于生成虚拟机当前时刻的线程快照（一般称为threaddump或javacore文件）。javacore主要目的是定位线程出现长时间停顿的原因，比如死锁、死循环、请求外部资源响应长时间等待等； 另外JDK 1.5后Thread类新增了getAllStackTraces()方法，可以基于此自己增加管理页面来分析； 8.HSDIS：JIT生成代码反编译 现代虚拟机的实现慢慢地和虚拟机规范产生差距，如果要分析程序如何执行，最常见的就是通过软件调试工具（GDB、Windbg等）断点调试。但是对于Java来说，很多执行代码是通过JIT动态生成到CodeBuffer中的； 功能：HSDIS是官方推荐的HotSpot虚拟机JIT编译代码的反汇编工具，它包含在HotSpot虚拟机的源码中但没有提供编译后的程序，可以自己下载放到JDK的相关目录里。 9.JDK的可视化工具1.JConsole：Java监视与管理控制台 是一种基于JMX的可视化监控和管理工具，它管理部分的功能是针对MBean进行管理，由于MBean可以使用代码、中间件服务器或者所有符合JMX规范的软件进行访问，因此这里着重介绍JConsole的监控功能； 通过jconsole命令启动JConsole后，会自动搜索本机所有虚拟机进程。另外还支持远程进程的监控； 进入主界面，支持查看以下标签页：概述、内存、线程、类、VM摘要和MBean。 2.VisualVM：多合一故障处理工具 目前为止JDK发布的功能最强调的运行监控和故障处理程序，另外还支持性能分析； VisualVM还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，对应用程序的实际性能影响很小，可直接应用在生成环境中； VisualVM基于NetBeans平台开发，具备插件扩展功能的特性，基于插件可以做到：显示虚拟机进程以及进程配置、环境信息（jps、jinfo）、监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）、dump以及分析堆转储快照（jmap、jhat）、方法级的程序运行性能分析，找出被调用最多运行时间最长的方法、离线程序快照（收集运行时配置、线程dump、内存dump等信息建立快照）、其他plugins的无限可能。 使用jvisualvm首次启动时需要在线自动安装插件（也可手工安装）； 特色功能：生成浏览堆转储快照（摘要、类、实例标签页、OQL控制台）、分析程序性能（Profiler页签可以录制一段时间程序每个方法执行次数和耗时）、BTrace动态日志跟踪（不停止目标程序运行的前提下通过HotSwap技术动态加入调试代码）。 10.本章小结 本章介绍了随JDK发布的6个命令行工具以及两个可视化的故障处理工具，灵活运行这些工具可以给问题处理带来很多便利。我的总体感觉是可视化工具虽然强大，但是加载速度相比命令行工具慢很多，这个时候专注于某个功能的命令行工具是更优的选择。 第5章 调优案例分析与实践1.概述除了第四章介绍的知识和工具外，在处理实际问题时，经验同样很重要。 2.案例分析以下的案例大部分来源作者处理过的一些问题，还有小部分是网络上笔记有代表的案例总结。 1.高性能硬件上的程序部署策略 问题描述 一个每天15万PV左右的在线文档网站升级了硬件，4个CPU，16GB物理内存，操作系统为64位CentOS 5.4，使用Resin作为Web服务器，没有部署其他的应用。 管理员选用了64位的JDK 1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。 使用一段时间不定期出现长时间失去响应的情况； 问题分析 升级前使用32位系统，Java堆设置为1.5GB，只是感觉运行缓慢没有明显的卡顿； 通过监控发现是由于GC停顿导致的，虚拟机运行在Server模式，默认使用吞吐量优先收集器，回收12GB的堆，一次Full GC的停顿时间高达14秒； 并且由于程序设计的原因，很多文档从磁盘加载到内存中，导致内存中出现很多由文档序列化生成的大对象，这些大对象进入了老年代，没有在Minor GC中清理掉； 解决办法 在虚拟机上建立5个32位的JDK逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），另外建议一个Apache服务作为前端均衡代理访问门户； 另外考虑服务压力主要在磁盘和内存访问，CPU资源敏感度较低，因此改为CMS收集器； 最终服务没有再出现长时间停顿，速度比硬件升级前有较大提升； 2.集群间同步导致的内存溢出问题描述 一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机，服务器为WebLogic 9.2，每台机器启动了3个WebLogic实例，构建一个6台节点的亲和式集群（一个固定的用户请求永远分配到固定的节点处理）。 由于有部分数据需要共享，原先采用数据库，后因为读写性能问题使用了JBossCache构建了一个全局缓存； 正常使用一段较长的时间，最近不定期出现了多次的内存溢出问题； 问题分析 监控发现，服务内存回收状况一直正常，每次内存回收后都能恢复到一个稳定的可用空间 此次未升级业务代码，排除新修改代码引入的内存泄漏问题； 服务增加-XX:+HeapDumpOnOutOfMemoryError参数，在最近一次内存溢出时，分析heapdump文件发现存在大量的org.jgroups.protocols.pbcast,NAKACK对象； 最终分析发现是由于JBossCache的NAKACK栈在页面产生大量请求时，有个负责安全校验的全局Filter导致集群各个节点之间网络交互非常频繁，当网络情况不能满足传输要求时，大量的需要失败重发的数据在内存中不断堆积导致内存溢出。 解决办法 JBossCache版本改进； 程序设计优化，JBossCahce集群缓存同步，不大适合有频繁写操作的情况； 3.堆外内存导致的溢出错误问题描述 一个学校的小型项目，基于B/S的电子考试系统，服务器是Jetty 7.1.4，硬件是一台普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统； 为了实现客户端能实时地从服务器端接收考试数据，使用了逆向AJAX技术（也称为Comet或Server Side Push），选用CometD 1.1.1作为服务端推送框架； 测试期间发现服务端不定期抛出内存溢出；加入-XX:+HeapDumpOnOutOfMemoryError后抛出内存溢出时什么问题都没有，采用jstat观察GC并不频繁且GC回收正常；最后在内存溢出后从系统日志发现如下异常堆栈： 堆外内存溢出日志 问题分析 在第二章里曾经说过直接内存溢出的场景，垃圾收集时，虚拟机虽然会对直接内存进行回收，但它只能等老年代满了触发Full GC时顺便清理，否则只能等内存溢出时catch住然后调用System.gc()，如果虚拟机还是不听（比如打开了-XX:+DisableExplictGC）则只能看着堆中还有许多空闲内存而溢出； 本案例中的CometD框架正好有大量的NIO操作需要使用直接内存； 4.外部命令导致系统缓慢问题描述 一个数字校园应用系统，运行在一个4个CPU的Solaris 10操作系统上，中间件为GlassFish服务器； 系统在做大并发压力测试时，发现请求响应时间比较慢，通过监控工具发现CPU使用率很高，并且系统占用绝大多数的CPU资源的程序并不是应用系统本身； 通过Dtrace脚本发现最消耗CPU的竟然是fork系统调用（Linux用来产生新进程的）； 问题分析 最终发现是每个用户请求需要执行一个外部的shell脚本来获取一些系统信息，是通过Runtime.getRuntime().exec()方法调用的； Java虚拟机在执行这个命令时先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新进程去执行外部命令，如果频繁地执行这个操作，系统消耗会很大； 最终修改时改用Java的API去获取这些信息，系统恢复了正常； 5.服务器JVM进程奔溃问题描述 一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP系统，服务器是WebLogic 9.2（和案例”集群间同步导致的内存溢出”相同的系统）； 正常运行一段时间后发现运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下一个hs_err_pid###.log，奔溃前不久都发生大量相同的异常，日志如下所示： JVM进程奔溃日志 问题分析 这是一个远端断开连接的异常，得知在MIS系统工作流的待办事项变化时需要通过Web服务通知OA门户系统； 通过SoapUI测试发现调用后竟然需要长达3分钟才能返回，并且返回结果都是连接中断； 由于MIS使用异步方式调用，两边处理速度不对等，导致在等待的线程和Socket连接越来越多，最终在超过虚拟机承受能力后进场奔溃； 解决方法：将异步调用修改为生产者/消费者模型的消息队列处理，系统恢复正常； 6.不恰当数据结构导致内存占用过大问题描述 有一个后台RPC服务器，使用64位虚拟机，内存配置为-Xms4g -Xmx8g -Xmn1g，使用ParNew + CMS的收集器组合； 平时Minor GC时间约在20毫秒内，但业务需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long, Long&gt; Entry，在这段时间里Minor GC会超过500毫秒，这个时间过长，GC日志如下： 不恰当数据结构GC日志1 不恰当数据结构GC日志2 问题分析 在分析数据文件期间，800M的Eden空间在Minor GC后对象还是存活的，而ParNew垃圾收集器使用的是复制算法，把这些对象复制到Survivor并维持这些对象引用成为沉重的负担，导致GC时间变长； 从GC可以将Survivor空间去掉（加入参数-XX:SurvivorRatio=65536、-XX:MaxTenuringThreshold=0或者-XX:AlwaysTenure），让新生代存活的对象第一次Minor GC后立即进入老年代，等到Major GC再清理。这种方式可以治标，但也有很大的副作用。 另外一种是从程序设计的角度看，HashMap&lt;Long, Long&gt;结构中，只有key和value所存放的两个长整形数据是有效数据，共16B（2 * 8B），而实际耗费的内存位88B（长整形包装为Long对象需要多8B的MarkWord、8B的Klass指针，Map.Entry多了16B的对象头、8B的next字段和4B的int型hash字段、为对齐添加的4B空白填充，另外还有8B的Entry引用），内存空间效率（18%）太低。 7.由Windows虚拟内存导致的长时间停顿问题描述 有一个带心跳检测功能的GUI桌面程序，每15秒发送一次心跳检查信号，如果对方30秒内都没有信信号返回，则认为和对方已断开连接； 程序上线后发现有误报，查询日志发现误报是因为程序会偶尔出现间隔约1分钟左右的时间完全无日志输出，处于停顿状态； 另外观察到GUI程序最小化时，资源管理中显示的占用内存大幅减小，但虚拟内存没变化； 因为是桌面程序，所需内存不大（-Xmx256m），加入参数-XX:+PrintGCApplicationStoppedTime -XX：PrintGCDateStamps -Xloggc:gclog.log后，从日志文件确认是GC导致的，大部分的GC时间在100ms以内，但偶尔会出现一次接近1min的GC； 加入参数-XX：PrintReferenceGC参数查看GC的具体日志信息，发现执行GC动作的时间并不长，但从准备开始GC到真正GC直接却消耗了大部分时间，如下所示： 虚拟内存案例日志 问题分析 初步怀疑是最小化时工作内存被自动交换到磁盘的页面文件中，这样发生GC时就有可能因为恢复页面文件的操作而导致不正常的GC停顿； 在MSDN查证确认了这种猜想，加入参数-Dsun.awt.keepWorkingSetOnMinimize=true来解决；这个参数在很多AWT程序如VisualVM都有应用。 3.实战：Eclipse运行速度调优 升级JDK； 设置-XX:MaxPermSize=256M解决Eclipse判断虚拟机版本的bug； 加入参数-Xverfify:none禁止字节码验证； 虚拟机运行在client模式，采用C1轻量级编译器； 把-Xms和-XX：PermSize参数设置为-Xmx和-XX:MaxPermSize一样，这样强制虚拟机启动时把老年代和永久代的容量固定下来，避免运行时自动扩展； 增加参数-XX：DisableExplicitGC屏蔽掉显式GC触发； 采用ParNew+CMS的垃圾收集器组合； 最终从Eclipse启动耗时15秒到7秒左右， eclipse.ini配置如下： Eclipse调优 4.本章小结 Java虚拟机的内存管理和垃圾收集是虚拟机结构体系最重要的组成部分，对程序的性能和稳定性有非常大的影响。通过案例和实战部分，加深了对前面理论知识和工具的理解。]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】10. Regular Expression Matching]]></title>
    <url>%2Fdd2ca416.html</url>
    <content type="text"><![CDATA[1.题目描述Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). 给你一个字符串s和一个字符规律p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符‘*’ 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。 Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 2.SolutionsThis Solution use 2D DP. beat 90% solutions, very simple. Here are some conditions to figure out, then the logic can be very straightforward. 1234567891. If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2. If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3. If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1) if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2) if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty Here is the solution 123456789101112131415161718192021222324252627282930public static boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == '*' &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == '.') &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == '*') &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != '.') &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()];&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】9. Palindrome Number]]></title>
    <url>%2F7f748733.html</url>
    <content type="text"><![CDATA[1.题目描述Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121Output: true Example 2: Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 2.Solutions12345678910public static boolean isPalindrome(int x) &#123; if(x &lt; 0) return false; int y = x; int res = 0; while(y != 0) &#123; res = res * 10 + y % 10; y /= 10; &#125; return x == res;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hadoop]]></title>
    <url>%2Fb3349d42.html</url>
    <content type="text"><![CDATA[1.简单描述如何安装配置一个apache开源版hadoop 安装JDK并配置环境变量（/etc/profile） 关闭防火墙 配置hosts文件，方便hadoop通过主机名访问（/etc/hosts） 设置ssh免密码登录 解压缩hadoop安装包，并配置环境变量 修改配置文件（$HADOOP_HOME/conf）hadoop-env.sh core-site.xml hdfs-site.xml mapred-site.xml 格式化hdfs文件系统 （hadoop namenode -format） 启动hadoop （$HADOOP_HOME/bin/start-all.sh） 使用jps查看进程 2.正常工作的hadoop集群中hadoop都分别需要启动那些进程，作用分别是什么 NameNode： HDFS的守护进程，负责记录文件是如何分割成数据块，以及这些数据块分别被存储到那些数据节点上，它的主要功能是对内存及IO进行集中管理 Secondary NameNode：辅助后台程序，与NameNode进行通信，以便定期保存HDFS元数据的快照。 DataNode：负责把HDFS数据块读写到本地的文件系统。 JobTracker：负责分配task，并监控所有运行的task。 TaskTracker：负责执行具体的task，并与JobTracker进行交互。 3.Hadoop调度器及其工作方法 比较流行的三种调度器有：默认调度器FIFO，计算能力调度器Capacity Scheduler，公平调度器Fair Scheduler 默认调度器FIFO：hadoop中默认的调度器，采用先进先出的原则 计算能力调度器Capacity Scheduler：选择占用资源小，优先级高的先执行 公平调度器Fair Scheduler：同一队列中的作业公平共享队列中所有资源 4.Hadoop二级排序 在Hadoop中，默认情况下是按照key进行排序，如果要按照value进行排序怎么办？有两种方法进行二次排序，分别为：buffer and in memory sort和value-to-key conversion。 buffer and in memory sort 主要思想是：在reduce()函数中，将某个key对应的所有value保存下来，然后进行排序。 这种方法最大的缺点是：可能会造成out of memory。 value-to-key conversion 主要思想是：将key和部分value拼接成一个组合key（实现WritableComparable接口或者调setSortComparatorClass函数），这样reduce获取的结果便是先按key排序，后按value排序的结果。需要注意的是，用户需要自己实现Paritioner，以便只按照key进行数据划分。Hadoop显式的支持二次排序，在Configuration类中有个setGroupingComparatorClass()方法，可用于设置排序group的key值。 5.MapReduce中combiner、partition的作用combiner 有时一个map可能会产生大量的输出，combiner的作用是在map端对输出先做一次合并，以减少网络传输到reducer的数量。注意：mapper的输出为combiner的输入，reducer的输入为combiner的输出。 partition 把map任务输出的中间结果按照key的范围划分成R份(R是预先定义的reduce任务的个数)，划分时通常使用hash函数，如：hash(key) mod R，这样可以保证一段范围内的key，一定会由一个reduce任务来处理。]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2Fc24675b4.html</url>
    <content type="text"><![CDATA[1.数据库三范式 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。 第二范式（2NF）：首先满足1NF。另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）：任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。 2.ACID Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。 Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 3.char和varchar的区别 char(n) ：固定长度类型。比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。优点：效率高；缺点：占用空间。适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。 varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。 所以，从空间上考虑 varchar 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。 4.内连接、左连接、右连接 内连接关键字：inner join；左连接：left join；右连接：right join。 内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。 5.MySQL索引 索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 具体来说 MySQL 中的索引，不同的数据引擎实现有所不同。但目前主流的数据库引擎的索引都是 B+ 树实现的。B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。 为什么MySQL数据库索引选择使用B+树 6.数据库的事务隔离 MySQL的事务隔离是在 MySQL.ini配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ 可用的配置值：READ-UNCOMMITTED（未提交）、READ-COMMITTED（读提交）、REPEATABLE-READ（可重复读）、SERIALIZABLE（串行化）。 read-uncommitted：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。 read-committed：读提交，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。 repeatable-read：可重复读，默认级别，保证多次读取同一个数据时。其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。 serializable：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。 不可重复读 ：是指在一个事务内，多次读同一数据。 幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。 7.MySQL常用引擎 InnoDB引擎：InnoDB 引擎提供了对数据库 ACID事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的，所以在并发度较高的场景下使用会提升效率的。 MyIASM引擎：MySQL的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。 8.MySQL行锁和表锁MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。 9.乐观锁和悲观锁 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。 数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1。这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。 10.MySQL问题排查方法 使用show processlist命令查看当前所有连接信息。 使用explain命令查询 SQL 语句执行计划。 开启慢查询日志，查看慢查询的 SQL。 11.MySQL性能优化 为搜索字段创建索引。 避免使用 select *，列出需要查询的字段。 垂直分割分表。 选择正确的存储引擎。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机（JVM）]]></title>
    <url>%2Fcff4bf17.html</url>
    <content type="text"><![CDATA[JVM结构图： JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data areaclassloader JVM 的 工作原理，层次结构 以及 GC工作原理 方法区、堆：所有线程共享的内存区域 Java虚拟机栈、本地方法栈、程序员计数器：运行时线程私有的内存区域 1.JVM的主要组成部分及其作用 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。 2.堆栈的区别 栈内存存储的是局部变量，堆内存存储的是实体； 栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短； 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。 3.双亲委派 在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。 类加载器分类： 启动类加载器（Bootstrap ClassLoader）：是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库； 扩展类加载器（Extension ClassLoader）：负责加载/lib/ext目录或Java. ext. dirs系统变量指定的路径中的所有类库； 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。 【深入理解JVM】：类加载器与双亲委派模型 4.类加载的执行过程类加载分为以下 5 个步骤： 加载：根据查找路径找到相应的 class 文件然后导入； 检查：检查加载的 class 文件的正确性； 准备：给类中的静态变量分配内存空间； 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址； 初始化：对静态变量和静态代码块执行初始化工作。 5.怎么判断对象是否可以被回收，如何确定垃圾 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。 6.垃圾回收算法 标记-清除算法（Mark-Sweep）：最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。 复制算法（Copying）：为了解决标记-清除算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。 标记-整理算法（Mark-Compact）：结合了Mark-Sweep和Copying两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同。标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象。 分代算法：分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域。一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。 7.JVM垃圾回收器 Serial：最早的单线程串行垃圾回收器。 Serial Old：Serial 垃圾回收器的老年代版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。 ParNew：是 Serial 的多线程版本。 Parallel ：和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。 Parallel Old：是 Parallel 老年代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。 CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理算法进行垃圾回收。 默认垃圾收集器： JDK1.7：Parallel Scavenge + Serial Old JDK1.8：Parallel Scavenge + Serial Old JDK1.9：G1 JDK10：G1 8.分代垃圾回收器工作原理 分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下： 把 Eden + From Survivor 存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记-整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。 9.JVM调优工具 JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。 jconsole：用于对 JVM 中的内存、线程和类等进行监控； jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。 10.JVM调优常用的参数 -Xms2g：堆最小内存为 2G -Xmx2g：堆最大内存为 2G -Xss128k：栈（不区分虚拟机栈和本地方法栈）内存容量 -XX:PermSize=10M -XX:MaxPermSize=10M 限制方法区从而间接限制常量池的容量 -XX:MaxDirectMemorySize=10M 本地直接内存容量 -XX:NewRatio=4：设置新生代(Eden+2个Survivor)和老年代的内存比例为 1:4 -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2 -XX:+UseSerialGC：虚拟机运行在Client模式下的默认值，Serial+Serial Old -XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合 -XX:+UseParallelGC：虚拟机运行在Server模式下的默认值，Parallel Scavenge+Serial Old（PS MarkSweep） -XX:+UseParallelOldGC：指定使用 Parallel Scavenge+ Parallel Old 垃圾回收器组合 -XX:+UseConcMarkSweepGC：指定使用 ParNew+CMS+Serial Old 垃圾回收器组合，Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 -XX:+PrintGC：开启打印 gc 信息 -XX:+PrintGCDetails：打印 gc 详细信息 参考： 1.JVM 的 工作原理，层次结构 以及 GC工作原理 2.JVM结构、GC工作机制详解 3.JVM结构、GC工作机制详解 4.Jvm 系列(二):Jvm 内存结构]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2Fbae4ff13.html</url>
    <content type="text"><![CDATA[1.Redis使用场景 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 Redis 使用场景： 数据高并发的读写 海量数据的读写 对扩展性要求高的数据 2.Redis功能 数据缓存 分布式锁 分布式事务 数据持久化 消息队列 3.Redis和memecache的区别 memcached所有的值均是简单的字符串。Redis作为其替代者，支持更为丰富的数据类型 Redis的速度比memcached快很多 Redis可以持久化其数据 4.Redis为什么是单线程的 因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。 关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。 而且单线程并不代表就慢，nginx 和 node.js 也都是高性能单线程的代表。 5.什么是缓存穿透？如何解决 缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决方案：最常见的则是采用布隆过滤器：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 缓存穿透，缓存击穿，缓存雪崩解决方案分析 6.Redis支持的数据类型String、List、Hash、Set、Zset。 7.Redis支持的Java客户端Redisson、Jedis、lettuce等等，官方推荐使用Redisson。 8.Jedis和Redisson区别 Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。 Redisson实现了分布式和可扩展的Java数据结构。和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。 9.如何保证缓存和数据库数据的一致性 合理设置缓存的过期时间。 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。 10.Redis持久化方式Redis 的持久化有两种方式，或者说两种策略： RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。 AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。 11.Redis如何实现分布式锁 Redis分布式锁其实就是在系统里面占一个“坑”，其他程序要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。 Redis分布式锁缺陷：Redis分布式锁不能解决超时的问题。分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。 redis系列：分布式锁 12.Redis内存优化 尽可能使用散列表（hashes）。散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。 13.Redis淘汰策略 volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。 volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。 allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。 allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。 no-enviction（驱逐）：禁止驱逐数据。 14.Redis常见的性能问题有哪些？该如何解决？ 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。 Redis 主从复制的性能问题。为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】4. Median of Two Sorted Arrays]]></title>
    <url>%2F2a84b609.html</url>
    <content type="text"><![CDATA[1.题目描述There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 2.Solutions原文链接：Share my O(log(min(m,n)) solution with explanation) LeetCode#4. 寻找两个有序数组的中位数 123456789101112131415161718192021222324252627282930313233343536373839404142public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length; int n = B.length; if (m &gt; n) &#123; return findMedianSortedArrays(B, A); &#125; int i = 0, j = 0, imin = 0, imax = m, half = (m + n + 1) / 2; double maxLeft = 0, minRight = 0; while (imin &lt;= imax) &#123; i = (imin + imax) / 2; j = half - i; if (j &gt; 0 &amp;&amp; i &lt; m &amp;&amp; B[j - 1] &gt; A[i]) &#123; imin = i + 1; //i的值太小， 增加它 &#125; else if (i &gt; 0 &amp;&amp; j &lt; n &amp;&amp; A[i - 1] &gt; B[j]) &#123; imax = i - 1; //i的值过大， 减小它 &#125; else &#123; //i is perfect if (i == 0) &#123; maxLeft = (double) B[j - 1]; &#125; else if (j == 0) &#123; maxLeft = (double) A[i - 1]; &#125; else &#123; maxLeft = (double) Math.max(A[i - 1], B[j - 1]); &#125; break; &#125; &#125; if ((m + n) % 2 == 1) &#123; return maxLeft; &#125; if (i == m) &#123; minRight = (double) B[j]; &#125; else if (j == n) &#123; minRight = (double) A[i]; &#125; else &#123; minRight = (double) Math.min(A[i], B[j]); &#125; return (double) (maxLeft + minRight) / 2;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[消息队列]]></title>
    <url>%2Ffec99276.html</url>
    <content type="text"><![CDATA[1.RabbitMQ使用场景 跨系统的异步通信。所有需要异步交互的地方都可以使用消息队列。 多个应用之间的耦合。由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，不需要发送方和接收方同时在线。在企业应用集成（EAI）、文件传输、共享数据库、消息队列、远程过程调用都可以作为集成的方法。 应用内的同步变异步。比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。 消息驱动的架构（EDA），系统分解为消息队列、消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。 应用需要更灵活的耦合方式。如发布订阅，比如可以指定路由规则。 跨局域网，甚至跨城市的通讯（CDN行业）。比如北京机房与广州机房的应用程序的通信。 2.RabbitMQ重要角色RabbitMQ 中重要的角色有：生产者、消费者和代理： 生产者：消息的创建者，负责创建和推送数据到消息服务器； 消费者：消息的接收方，用于处理数据和确认消息； 代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。 3.RabbitMQ的重要组件 ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。 Channel（信道）：消息推送使用的通道。 Exchange（交换器）：用于接受、分配消息。 Queue（队列）：用于存储生产者的消息。 RoutingKey（路由键）：用于把生成者的数据分配到交换器上。 BindingKey（绑定键）：用于把交换器的消息绑定到队列上。 4.RabbitMQ中vhost的作用 vhost 可以理解为虚拟broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等。但最重要的是其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。 5.RabbitMQ的消息发送原理 首先客户端必须连接到 RabbitMQ服务器才能发布和消费消息。客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（用户名和密码匹配），客户端和 RabbitMQ就创建了一条 amqp 信道（channel）。信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。 6.RabbitMQ如何保证消息的稳定性 提供了事务的功能。 通过将 channel 设置为 confirm（确认）模式。 7.RabbitMQ如何避免消息丢失 消息持久化 ACK确认机制 设置集群镜像模式 消息补偿机制 其实个人感觉，RabbitMQ就是通信协议的翻版，可能这样子说有点过了，但是不得不说的是，RabbitMQ里面的很多东西借鉴了通信协议的思想、也用了数据结构、数据库的一些技术，所以再一次证明了学习底层原理有多么重要！ 8.保证消息持久化成功的条件 声明队列必须设置持久化， durable 设置为 true。 消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。 消息已经到达持久化交换器。 消息已经到达持久化队列。 以上四个条件都满足才能保证消息持久化成功。 9.RabbitMQ持久化缺点 持久化的缺点就是降低了服务器的吞吐量。因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。 10.RabbitMQ的广播类型三种广播模式： fanout：所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）； direct：通过routingKey和exchange决定的那个唯一的queue可以接收消息； topic：所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息； 11.RabbitMQ如何实现延迟消息队列 通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能； 使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。 12.RabbitMQ集群作用集群主要有以下两个用途： 高可用：某个服务器出现问题，整个 RabbitMQ还可以继续使用； 高容量：集群可以承载更多的消息量。 13.RabbitMQ节点的类型 磁盘节点：消息会存储到磁盘。 内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。 14.RabbitMQ每个节点是否是其他节点的完整拷贝不是，原因有以下两个： 存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据； 性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。 15.RabbitMQ集群中唯一一个磁盘节点崩溃了会发生什么情况如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作： 不能创建队列 不能创建交换器 不能创建绑定 不能添加用户 不能更改权限 不能添加和删除集群节点 唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。 16.RabbitMQ对集群节点停止顺序有要求吗 RabbitMQ对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】6. ZigZag Conversion]]></title>
    <url>%2Fd0654adb.html</url>
    <content type="text"><![CDATA[1.题目描述The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;PAYPALISHIRING&quot; 行数为 3 时，排列如下： 123P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot; 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: 12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 2.Solutions123456789101112131415161718192021public static String convert(String s, int numRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[numRows]; for (int i = 0; i &lt; sb.length; i++) sb[i] = new StringBuffer(); int i = 0; while (i &lt; len) &#123; for (int row = 0; row &lt; numRows &amp;&amp; i &lt; len; row++) sb[row].append(c[i++]);// vertically down 垂直向下 for (int row = numRows - 2; row &gt;= 1 &amp;&amp; i &lt; len; row--) &#123; sb[row].append(c[i++]);// obliquely up 斜向上 &#125; &#125; for (int row = 1; row &lt; sb.length; row++) sb[0].append(sb[row]); return sb[0].toString();&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mybatis&Hibernate]]></title>
    <url>%2F1cde7558.html</url>
    <content type="text"><![CDATA[1.Mybatis中 #{} 和 ${} 的区别 #{}是预编译处理，${}是字符串替换； Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； Mybatis在处理\${}时，就是把​\${}替换成变量的值； 使用#{}可以有效的防止SQL注入，提高系统安全性。 2.实体类中的属性名和表中的字段名不一样的处理方式 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致 通过&lt;resultMap&gt;来映射字段名和实体类属性名的一一对应的关系 12345678910&lt;select id="getOrder" parameterType="int" resultMap="orderresultmap"&gt; select * from orders where order_id=#&#123;id&#125;&lt;/select&gt;&lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt; &lt;!–用id属性来映射主键字段–&gt; &lt;id property=”id” column=”order_id”&gt; &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt; &lt;result property = “orderno” column =”order_no”/&gt; &lt;result property=”price” column=”order_price” /&gt; &lt;/reslutMap&gt; 3.如何获取自动生成的(主)键值 第一是在数据库获得通过自带方法。在数据插入之后输入“select @@indentity”通常需要结合存储过程，比较复杂。 第二是在后台插入时获得。这里我们主要说后台刚插入时得到主键值。 对于支持自动生成主键的数据库，如Mysql、sqlServer，可以通过 Mybatis元素useGeneratedKeys返回当前插入数据主键值到输入类中。 12345&lt;insert id="insertTest" useGeneratedKeys="true" keyProperty="id" parameterType="com.kq.domain.IdentityTest"&gt; insert into identity_test(name) values(#&#123;name,jdbcType=VARCHAR&#125;)&lt;/insert&gt; 当执行此条插入语句以后，实体类IdentityTest中的Id会被当前插入数据的主键自动填充。 对于不支持自动生成主键的数据库。Oracle、DB2等，可以用元素selectKey 回当前插入数据主键值到输入类中。（同时生成一个自定义的随机主键） 通过LAST_INSERT_ID()获取刚插入记录的自增主键值，在insert语句执行后，执行select LAST_INSERT_ID()就可以获取自增主键。 12345678&lt;insert id="insertTest" useGeneratedKeys="true" keyProperty="id" parameterType="com.kq.domain.IdentityTest"&gt; &lt;selectKey keyProperty="id" resultType="String" order="BEFORE"&gt; SELECT REPLACE(UUID(),'-','') &lt;/selectKey&gt; insert into identity_test(name) values(#&#123;name,jdbcType=VARCHAR&#125;)&lt;/insert&gt; 当执行此条插入语句以后，实体类IdentityTest中的Id也会被当前插入数据的主键自动填充。 4.在mapper中如何传递多个参数 使用占位符的思想。在映射文件中使用#{0},#{1}代表传递进来的第几个参数（如果使用的是JDK8的话，那么会有Bug），使用@param注解:来命名参数，#{0},#{1}方式 使用Map集合作为参数来装载 5.Mybatis不同的XML映射文件，id是否可以重复 如果配置了namespace那么当然是可以重复的，因为我们的Statement实际上就是namespace+id。 如果没有配置namespace的话，那么相同的id就会导致覆盖了。 6.Xml映射文件对应的Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？ Dao接口，就是人们常说的Mapper接口。接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。 Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。 Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。 Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。 7.Mybatis分页方式 数组分页、sql分页、拦截器分页、RowBounds分页 Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。根据dialect方言，添加对应的物理分页语句和物理分页参数。 8.Mybatis物理分页和逻辑分页的区别 两者在速度上，没有谁比谁快之分； 物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势，然而其它性能上的优点足以弥补这个缺点。 9.Mybatis 是否支持延迟加载？延迟加载的原理是什么？ Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法。比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来。然后调用a.setB(b)，于是a的对象b属性就有值了。接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。 当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 10.Mybatis 的一级缓存和二级缓存 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 二级缓存与一级缓存其机制相同，默认也是采用PerpetualCache的HashMap 存储。不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)，可在它的映射文件中配置&lt;cache/&gt;。 对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 11.Mybatis执行器（Executor）Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor： SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建。用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()）。它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。 12.Mybatis 分页插件的实现原理 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件。在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 13.Mybatis 编写自定义插件 Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为： Executor：拦截执行器的方法(log记录) StatementHandler ：拦截Sql语法构建的处理 ParameterHandler ：拦截参数的处理 ResultSetHandler ：拦截结果集的处理 前两种应用较为广泛。 Mybatis自定义插件必须实现Interceptor接口： 12345public interface Interceptor &#123; Object intercept(Invocation invocation) throws Throwable; Object plugin(Object target); void setProperties(Properties properties);&#125; intercept方法：拦截器具体处理逻辑方法 plugin方法：根据签名signatureMap生成动态代理对象 setProperties方法：设置Properties属性 Mybatis自定义插件 14.Mybatis 和 Hibernate 的区别 Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发。因为这类软件需求变化频繁，一旦需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件。如果用hibernate开发可以节省很多代码，提高效率。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F6c92115f.html</url>
    <content type="text"><![CDATA[1.为什么要使用 Spring？ 目的：解决企业应用开发的复杂性 功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能 范围：任何Java应用 简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。 2.Spring主要模块 来源：Spring思维导图，让spring不再难懂（一） 3.解释AOP AOP（Aspect-Oriented Programming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 而AOP技术则恰恰相反，AOP代表的是一个横向的关系，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或业务封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。比如权限认证、日志、事务处理、性能代码。 使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。Aop的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。” 4.解释IOC 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。 IoC是一种思想，将原本在程序中手动创建对象的控制权，交由Spring框架来管理。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 浅谈IOC–说清楚IOC是什么 5.Spring 常用的注入方式Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种： 构造方法注入 setter注入 基于注解注入 6.Spring中Bean的作用域 当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域： singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例 prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例 request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例。即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效 session：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效 globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效 其中比较常用的是singleton和prototype两种作用域。如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。 7.Spring自动装配Bean的方式spring中bean装配有两种方式： 隐式的bean发现机制和自动装配 在java代码或者XML中进行显示配置 8.Spring事务实现方式 编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。 基于 TransactionProxyFactoryBean 的声明式事务管理 基于 @Transactional 的声明式事务管理 基于 Aspectj AOP 配置事务 9.Spring事务隔离 事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题： 脏读：一个事务读到另一个事务未提交的更新数据。 幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。 不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。 TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT： 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别，Oracle默认采用的READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 TransactionDefinition.ISOLATION_READ_COMMITTED： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 TransactionDefinition.ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 Spring事务隔离级别和传播特性 10.Spring MVC运行流程 用户发送请求&rarr;DispatcherServlet：用户向服务器发送请求，请求被Spring 前端控制DispatcherServlet捕获； DispatcherServlet&rarr;HandlerMapping：DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； DispatcherServlet&rarr;HandlerAdapter：根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法） HandlerAdapter&rarr;处理方法的调用：提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler&rarr;ModelAndView的逻辑视图名：Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象； ModelAndView的逻辑视图名&rarr;ViewResolver：根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ； View&rarr;渲染：ViewResolver 结合Model和View，来渲染视图； 返回控制器DispatcherServlet：给将渲染结果返回给客户端。 SpringMVC系列（一）核心：处理请求流程 11.Spring MVC的核心组件 DispatcherServlet：中央控制器，把请求给转发到具体的控制类 Controller：具体处理请求的控制器 HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略 ModelAndView：服务层返回的数据和视图层的封装类 ViewResolver：视图解析器，解析具体的视图 Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作 12.Spring用到的设计模式 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。 适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。 …… Spring中都用到了那些设计模式 13.Spring Boot Spring Boot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。 Spring Boot使编码、配置、部署、监控变得简单，并且借鉴了Spring的不足。 14.Spring Boot 配置文件类型和区别 Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。相对于properties文件而言，yml文件后来，但是有很多不足。可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。 15.Spring Boot实现热部署的方式SpringBoot热部署实现有两种方式： 使用spring loaded 使用spring-boot-devtools]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】5. Longest Palindromic Substring]]></title>
    <url>%2F96028b45.html</url>
    <content type="text"><![CDATA[1.题目描述Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example 2: Input: “cbbd”Output: “bb” 2.Solutions dp(i, j) represents whether s(i ... j) can form a palindromic substring, dp(i, j) is true when s(i) equals to s(j) and s(i+1 ... j-1) is a palindromic substring. When we found a palindrome, check if it’s the longest one. Time complexity O(n^2). 123456789101112131415161718192021public static String longestPalindrome(String s) &#123; int n = s.length(); int palindromeStartsAt = 0, maxLen = 0; //dp[i][j]表示从i开始到j结束的子串是否是回文 boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; //找到(i,j)中最大的回文串 //s.charAt(i)==s.charAt(j)：判断在(i,j)区间中是否是回文串 //j-i&lt;3:如果(i,j)的范围小于等于3，那么只有结束字符匹配 //dp[i+1][j-1]:如果范围大于3，那么(i+1,j-1)也是回文串 dp[i][j] = s.charAt(i)==s.charAt(j) &amp;&amp; (j-i&lt;3 || dp[i+1][j-1]); //更新最大回文字符串 if (dp[i][j] &amp;&amp; (j-i+1 &gt; maxLen)) &#123; palindromeStartsAt = i; maxLen = j-i+1; &#125; &#125; &#125; return s.substring(palindromeStartsAt, palindromeStartsAt+maxLen);&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F364ea8cc.html</url>
    <content type="text"><![CDATA[1.说一下你熟悉的设计模式常用的设计模式汇总，超详细！ 2.简单工厂、工厂模式、抽象工厂模式 简单工厂 这个模式本身很简单而且使用在业务较简单的情况下。一般用于小项目或者具体产品很少扩展的情况（这样工厂类才不用经常更改）。 它由三种角色组成： 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑不同，产生具体的工厂产品。如例子中的Driver类。 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。由接口或者抽象类来实现。如例中的Car接口。 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现，如例子中的Benz、Bmw类。 工厂模式 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。在同一等级结构中，支持增加任意产品。 抽象工厂方法 抽象工厂是应对产品族概念的。比如说，每个汽车公司可能要同时生产轿车，货车，客车，那么每一个工厂都要有创建轿车，货车和客车的方法。应对产品族概念而生，增加新的产品线很容易，但是无法增加新的产品。 可以这么说，它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象。 小结 工厂模式中，重要的是工厂类，而不是产品类。产品类可以是多种形式，多层继承或者是单个类都是可以的。但要明确的，工厂模式的接口只会返回一种类型的实例，这是在设计产品类的时候需要注意的，最好是有父类或者共同实现的接口。 使用工厂模式，返回的实例一定是工厂创建的，而不是从其他对象中获取的。 工厂模式返回的实例可以不是新创建的，返回由工厂创建好的实例也是可以的。 区别 简单工厂：用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力） 工厂模式：用来生产同一等级结构中的固定产品。（支持增加任意产品） 抽象工厂：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） 以上三种工厂 方法在等级结构和产品族这两个方向上的支持程度不同。所以要根据情况考虑应该使用哪种方法。 参考： 简单工厂、工厂方法模式、抽象工厂模式 设计模式：简单工厂、工厂方法、抽象工厂之小结与区别]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识总结]]></title>
    <url>%2Fb3287aa2.html</url>
    <content type="text"><![CDATA[1.HTTP响应码 301 和 302 的意思及区别301，302 都代表着某个URL发生了转移（重定向）。 区别： 301 redirect: 301 代表永久性转移(Permanently Moved)。 302 redirect: 302 代表暂时性转移(Temporarily Moved )。 2.forward 和 redirect 的区别Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。 直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求。在请求对象request中，保存的对象对于每个信息资源是共享的。 间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。 3.TCP和UDP的区别 TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。 TCP提供可靠的服务。Tcp通过校验和重传控制、序号标识、滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 UDP尽最大努力交付，即不保证交付的可靠；UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。 TCP对系统资源要求较多，UDP对系统资源要求较少。 4.TCP为什么要三次握手 为了实现可靠数据传输，TCP 协议的通信双方， 都必须维护一个序列号（Seq）， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。 5.OSI 的七层模型 应用层：网络服务与最终用户的一个接口。（协议：HTTP、FTP、DNS、SMTP、Telnet） 表示层：数据的表示、安全、压缩。 会话层：建立、管理、终止会话。 传输层：定义传输数据的协议端口号，以及流控和差错校验。（协议：TCP、UDP） 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。（协议：IP） 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。 物理层：建立、维护、断开物理连接。 6.GET和POST的区别使用上的区别： GET使用URL或Cookie传参，而POST将数据放在BODY中。 GET方式提交的数据有长度限制，则POST的数据则可以非常大。 POST比GET安全，因为数据在地址栏上不可见。 GET产生一个TCP数据包；POST产生两个TCP数据包。 终极区别：GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。 W3School GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET参数通过URL传递，POST放在Request body中。 GET请求在URL中传送的参数是有长度限制的，而POST没有。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 7.从浏览器中输入URL到页面展示的流程 输入URL：智能匹配（浏览器）、浏览器解析URL 浏览器查找域名IP地址：hosts文件——缓存——最近的DNS服务器——根域DNS服务器——域名服务器——域名解析器地址——缓存 浏览器根据获得的IP向web服务器发送一个HTTP请求：TCP连接请求（三次握手）——内核的TCP/IP协议栈——防火墙 服务器永久重定向：301、302 浏览器跟踪重定向地址：发送另一个HTTP请求到新地址 服务器处理请求：反向代理（Nginx）、负载均衡——MVC、是否调用其他RPC服务/异步消息——缓存——分库分表数据库（系统架构） 服务器响应HTTP请求，返回一个HTTP响应：状态行、响应头、响应正文 浏览器显示HTML：自上而下加载、渲染、DOM树 浏览器请求嵌入在HTML中的资源：CSS、JS、图片、音频、视频 8.如何实现跨域方式一：图片ping或script标签跨域 图片ping常用于跟踪用户点击页面或动态广告曝光次数。script标签可以得到从其他来源数据，这也是JSONP依赖的根据。 方式二：JSONP跨域 JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 &lt;script&gt;元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。 缺点： 只能使用Get请求 不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败 JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保 方式三：CORS Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种： Access-Control-Allow-Origin: *Access-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400 跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数： “Access-Control-Allow-Credentials”: true // Ajax设置 “withCredentials”: true 方式四：window.name+iframe window.name通过在iframe（一般动态创建）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。 iframe标签的跨域能力； window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。 每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回&lt;iframe&gt;元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。 方式五：window.postMessage() HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。 方式六：修改document.domain跨子域 前提条件：这两个域名必须属于同一个基础域名！而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域。 在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” ，但不能设置为 “xxx.org” 或者”com”。 方式七：WebSocket WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：WebSocket、WebSocket-SockJS 需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。 方式八：代理 同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题 DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器） 9.JSONP实现原理 jsonp 即 json+padding，动态创建script标签。利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返回json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web]]></title>
    <url>%2Ffb60fea1.html</url>
    <content type="text"><![CDATA[1.JSP和Servlet的区别 jsp经编译后就变成了servlet。（jsp的本质就是servlet。JVM只能识别java的类，不能识别jsp的代码，Web容器将JSP的代码编译成JVM能够识别的java类） jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。 servlet中没有内置对象，jsp中的内置对象必须通过HttpServletRequest对象、HttpServletResponse对象以及HttpServlet对象得到。 jsp是servlet的一种简化，使用jsp只需要完成输出到客户端的内容。Jsp中的Java脚本如果镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。 2.JSP的内置对象及作用JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 3. JSP的 4 种作用域JSP中的四种作用域包括page、request、session和application，具体来说： page：与一个页面相关的对象和属性。 request：与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session：与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application：与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 4.session和cookie的区别由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个session是保存在服务端的，有一个唯一标识。在服务端保存session的方法很多，内存、数据库、文件都有。集群的时候也要考虑session的转移，在大型的网站，一般会有专门的session服务器集群，用来保存用户会话，这个时候 session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 session。 思考一下服务端如何识别特定的客户？这个时候cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的cookie信息到服务端。实际上大多数的应用都是用 cookie 来实现session跟踪的，第一次创建session的时候，服务端会在HTTP协议中告诉客户端，需要在 cookie 里面记录一个session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是cookie名称的由来，给用户的一点甜头。所以，总结一下：session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现session的一种方式。 区别： cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的； cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session； session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE； 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K； 5.session的工作原理 session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。 6.客户端禁用cookie，session是否还能用 cookie与 session，一般认为是两个独立的东西，session采用的是在服务器端保持状态的方案，而cookie采用的是在客户端保持状态的方案。但为什么禁用cookie就不能得到session呢？因为session是用session ID来确定当前对话所对应的服务器session，而session ID是通过cookie来传递的，禁用cookie相当于失去了session ID，也就得不到session了。 假定用户关闭cookie的情况下使用session，其实现途径有以下几种： 手动通过URL传值、隐藏表单传递session ID。 用文件、数据库等形式保存session ID，在跨页过程中手动调用。 7.Spring mvc和Struts的区别 拦截机制的不同 Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。 SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又和一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModelMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，没有共享的属性，所以是线程安全的。如果要改变默认的作用域，需要添加@Scope注解修改。 Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 底层框架的不同 Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化，服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。 性能方面 Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。 配置方面 spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。 8.避免sql注入 PreparedStatement（简单又有效的方法） 使用正则表达式过滤传入的参数 字符串过滤 JSP中调用该函数检查是否包含非法字符 JSP页面判断代码]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】31. Next Permutation]]></title>
    <url>%2F4b8a6c10.html</url>
    <content type="text"><![CDATA[1.题目描述Implement next permutation, which rearranges numbers into the lexicographically(字典序) next greater permutation(排列) of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant(不变的) extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 2.相关知识全排列的生成算法方法是将给定的序列中所有可能的全排列无重复无遗漏地枚举出来。此处全排列的定义是：从n个元素中取出m个元素进行排列，当n=m时这个排列被称为全排列。字典序、邻位对换法、循环左移法、循环右移法、递增进位制法、递减进位制法都是常见的全排列生成算法。 例子：对于元素集合{1，2，3}按字典序生成的全排列是 [1, 2, 3][1, 3, 2][2, 1, 3][2, 3, 1][3, 2, 1][3, 1, 2] 3.SolutionsAccording to Wikipedia, a man named Narayana Pandita presented the following simple algorithm to solve this problem in the 14th century. Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, just reverse nums and done. Find the largest index l &gt; k such that nums[k] &lt; nums[l]. Swap nums[k] and nums[l]. Reverse the sub-array nums[k + 1:]. 1234567891011121314151617181920212223242526272829303132333435363738394041public static void nextPermutation(int[] nums) &#123; int len = nums.length, k, l; for (k = len - 2; k &gt;= 0; k--) &#123; if (nums[k] &lt; nums[k + 1]) &#123; break; &#125; &#125; if (k &lt; 0) &#123; reverse(nums,0,len-1); &#125; else &#123; for (l = len - 1; l &gt; k; l--) &#123; if (nums[l] &gt; nums[k]) &#123; break; &#125; &#125; swap(nums, k, l); reverse(nums, k + 1, len-1); &#125;&#125;private static void reverse(int[] nums,int start,int end)&#123; int len = nums.length; if(len &lt; 0 || start &gt; len || end &gt; len || start&gt;end)&#123; return; &#125; // two pointer for( ;start &lt; end; start++,end--)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125; /*for (int i = 0; i &lt; len &gt;&gt; 1; i++) &#123; int temp = nums[i]; nums[i] = nums[len-i-1]; nums[len-i-1] = temp; &#125;*/&#125;private static void swap(int[] nums,int i,int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】27. Remove Element]]></title>
    <url>%2Ff08ce37d.html</url>
    <content type="text"><![CDATA[1.题目描述Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary(随意). It doesn’t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy)int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) { print(nums[i]);} 2.Solutions 从数组左边开始，每当找到一个目标值时，与数组右边的值交换。同时，把右指针递减；并且当当前值不是目标值时，递增左指针。一旦左指针达到右指针，我们就知道左指针后面的值都是目标值，而左指针前面的值是非目标值，返回左指针就是移除后的数组长度。 1234567891011121314public static int removeElement(int[] nums, int val) &#123; int left = 0,right = nums.length - 1; while(left &lt;= right)&#123; if(nums[left] == val)&#123; int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; right--; &#125;else&#123; left++; &#125; &#125; return left;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】26. Remove Duplicates from Sorted Array]]></title>
    <url>%2F727ca1de.html</url>
    <content type="text"><![CDATA[1.题目描述Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 2.Solutions1234567public static int removeDuplicates(int[] nums) &#123; int i = nums.length &gt; 0 ? 1 : 0; for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】18. 4Sum]]></title>
    <url>%2Fa3390c29.html</url>
    <content type="text"><![CDATA[1.题目描述Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b+ c + d = target? Find all unique quadruplets（四胞胎） in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 2.Solutions If you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: 2sum Problem Reduce K sum problem to K – 1 sum Problem Therefore, the ideas is simple and straightforward. We could use recursive（递归） to solve this problem. Time complexity is O(N^(K-1)). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); return kSum(nums, target, 4, 0);&#125;private static List&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int target, int k,int index) &#123; int len = nums.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (index &gt;= len) &#123; return res; &#125; if (k == 2) &#123; int left = index, right = len - 1; while (left &lt; right) &#123; // find a pair if (target - nums[left] == nums[right]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[left]); temp.add(target - nums[left]); res.add(temp); // skip duplication while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while (left &lt; right &amp;&amp; nums[right - 1] == nums[right]) right--; left++; right--; &#125; else if (target - nums[left] &gt; nums[right]) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; else &#123; for (int i = index; i &lt; len - k + 1; i++) &#123; // use current number to reduce ksum into k-1sum List&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i],k-1,i+1); if (temp != null) &#123; // add previous results for (List&lt;Integer&gt; t : temp) &#123; t.add(0, nums[i]); &#125; res.addAll(temp); &#125; while (i &lt; len - 1 &amp;&amp; nums[i] == nums[i + 1]) i++; &#125; &#125; return res;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程、反射与克隆]]></title>
    <url>%2F12275479.html</url>
    <content type="text"><![CDATA[1.并行和并发的区别 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 并行是在多台处理器上同时处理多个任务，如hadoop分布式集群；并发是在一台处理器上“同时”处理多个任务。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 2.线程和进程的区别 进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。 3.守护进程 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他线程的线程。在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 。只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。 Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)。 User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 4.创建线程的方式① 继承Thread类创建线程类 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 创建Thread子类的实例，即创建线程对象。 调用线程对象的start()方法来启动该线程。 ② 通过Runnable接口创建线程类 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 ③ 通过Callable和Future创建线程类 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 5.runnable 和 callable 有什么区别 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已； Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 6.线程状态线程通常都有五种状态：新建、运行、阻塞、等待、超时等待和终止。 新建(New)：新创建了一个线程对象，但还没有调用start()方法。 运行(Runable)：Java线程中将就绪（Ready）和运行中（Running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（Ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（Running）。 阻塞(Blocked)：表示线程阻塞于锁。线程正在运行的时候，被暂停，通常是为了等待某个事件的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend,wait等方法都可以导致线程阻塞。 等待(Waiting)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(Timed Waiting)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(Terminated)：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 Java线程的6种状态及切换(透彻讲解) 7.sleep() 和 wait()的区别sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。 wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程 8.notify()和 notifyAll()的区别 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 9.线程的 run()和 start()的区别 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。 start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已。直接调用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。 10.创建线程池的几种方式在java doc中，并不提倡直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池： ①newSingleThreadExecutor() 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会创建一个新的来替代它 ②newFixedThreadPool(int nThreads) 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 ③newCachedThreadPool() 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池的规模不存在任何限制。 ④newScheduledThreadPool(int corePoolSize) 创建一个定长线程池，支持定时及周期性任务执行。 Java并发编程：线程池的使用 如何优雅的使用和理解线程池 Java 四种线程池的用法分析 11.线程池状态线程池有5种状态：Running、ShutDown、Stop、Tidying（收拾、整理）、Terminated。 12.在 java 程序中怎么保证多线程的安全运行线程安全在三个方面体现： 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作（synchronized） 可见性：一个线程修改了共享变量的值，其他线程能够立即得知这个修改（synchronized,final） 有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的（happens-before原则，synchronized，volatile）。 13.多线程锁的升级原理 在Java中，锁共有4种状态，级别从低到高依次为：无锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。 锁升级的图示过程： 14.死锁 死锁，是进程死锁的简称，是指两个或两个以上的进程在执行过程中，由于资源竞争或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误。 最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。 15.怎么防止死锁死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放 循环等待条件：进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。 所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。 16.ThreadLocal 是什么？有哪些使用场景？ 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式，实现了线程的数据隔离。 但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 17.Synchronized 底层实现原理 synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 深入理解Java并发之synchronized实现原理 18.Synchronized 和 volatile 的区别 volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量修改的可见性和原子性。 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 19.Synchronized 和 Lock 的区别 synchronized是java内置关键字；在jvm层面，Lock是个java类 锁的状态：synchronized无法判断是否获取锁的状态；Lock可以判断是否获取到锁 释放锁：synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)；Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁 等待与阻塞：用synchronized关键字的两个线程1和线程2，如果线程1获得锁，则线程2等待；如果线程1阻塞，线程2则会一直等待下去；而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了 重入、中断、公平：synchronized的锁可重入、但不可中断、非公平；而Lock锁可重入、可中断、可公平（两者皆可） synchronized锁适合少量代码的同步问题；Lock锁适合大量代码的同步问题 20.Synchronized 和 ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的：ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的是对象头中mark word。 21.Atomic的原理 Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性。即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。 Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用。而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果。例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。 22.反射反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。 在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？ Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 23.Java序列化以及什么情况下需要序列化？ 序列化简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 什么情况下需要序列化： 想把内存中的对象状态保存到一个文件中或者数据库中时候 想用套接字在网络上传送对象的时候 想通过RMI传输对象的时候 24.动态代理及应用 动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理，比如说加日志，加事务等，可以给这个类创建一个代理。顾名思义就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活、扩展性强。 动态代理的应用： Spring的AOP 加事务 加权限 加日志 25.如何实现动态代理 必须定义一个接口 有一个InvocationHandler(将实现接口的类的对象传递给它)处理类 一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类） 利用InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回 26.为什么要克隆 想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。 27.如何实现对象克隆有两种方式： 1)实现Cloneable接口并重写Object类中的clone()方法； 2)实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常。这种是方案明显优于使用Object类的clone方法克隆对象：让问题在编译的时候暴露出来总是好过把问题留到运行时。 28.深拷贝和浅拷贝的区别 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址。所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()） 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2F4509351.html</url>
    <content type="text"><![CDATA[1.Collection 和 Collections 有什么区别？ java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。 Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。 2.List、Set、Map 之间的区别是什么？ 3.Arraylist默认分配多少？如果数据已满，自动增长多少？默认分配10，当前容量*1.5 12345678910111213141516171819202122/** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 4.Hashmap的实现原理 HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null键和null值。 HashMap使用“链表散列”数据结构，即数组和链表的结合体。 当我们往Hashmap中put元素时，首先根据key的hashcode重新计算hash值，根据hash值得到这个元素在数组中的位置(下标)，如果该数组在该位置上已经存放了其他元素，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放入链尾。Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)。 对HashMap遍历Entry对象的顺序和Entry对象的存储顺序之间没有任何关系。但是，我们有时候想要遍历HashMap的元素Entry的顺序和其存储的顺序一致，HashMap显然不能满足条件了。而LinkedHashMap则可以满足这个需要。 5.HashMap 和 Hashtable 有什么区别？ hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。 hashTable是同步的，而HashMap是非同步的，效率上比hashTable要高。 hashMap允许空键值，而hashTable不允许。 6.如何决定使用 HashMap 还是 TreeMap？ 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。TreeMap是SortedMap接口基于红黑树的实现，该类保证了映射按照升序排列关键字。 7.说一下 HashSet 的实现原理？ HashSet底层由HashMap实现 HashSet的值存放于HashMap的key上 HashMap的value统一为PRESENT 8.ArrayList 和 LinkedList 的区别是什么？ ArrrayList底层的数据结构是数组，支持随机访问。而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。 9.在 Queue 中 poll()和 remove()有什么区别？ poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。 10.ArrayDeque就其实现而言，ArrayDeque采用了循环数组的方式来完成双端队列的功能。 无限的扩展，自动扩展队列大小的。（当然在不会内存溢出的情况下。） 非线程安全的，不支持并发访问和修改。 支持fast-fail. 作为栈使用的话比比栈要快. 当队列使用比linklist要快。 null元素被禁止使用。 1.添加元素 addFirst(E e) 在deque前面添加元素 addLast(E e) 在deque后面添加元素 offerFirst(E e) 在deque前面添加元素，并返回是否添加成功 offerLast(E e) 在deque后面添加元素，并返回是否添加成功 2.删除元素 removeFirst() 删除第一个元素，并返回删除元素的值，如果元素为null，将抛出异常 pollFirst() 删除第一个元素，并返回删除元素的值，如果元素为null，将返回null removeLast() 删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常 pollLast() 删除最后一个元素，并返回删除元素的值，如果为null，将返回null removeFirstOccurrence(Object o) 删除第一次出现的指定元素 removeLastOccurrence(Object o) 删除最后一次出现的指定元素 3.获取元素 getFirst() 获取第一个元素,如果没有将抛出异常 getLast() 获取最后一个元素，如果没有将抛出异常 4.队列操作 add(E e) 在队列尾部添加一个元素 offer(E e) 在队列尾部添加一个元素，并返回是否成功 remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst()) poll() 删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst()) element() 获取第一个元素，如果没有将抛出异常 peek() 获取第一个元素，如果返回null 5.栈操作 push(E e) 栈顶添加一个元素 pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常 6.其他 size() 获取队列中元素个数 isEmpty() 判断队列是否为空 iterator() 迭代器，从前向后迭代 descendingIterator() 迭代器，从后向前迭代 contain(Object o) 判断队列中是否存在该元素 toArray() 转成数组 clear() 清空队列 clone() 克隆(复制)一个新的队列 11.哪些集合类是线程安全的？ Vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。 Stack：堆栈类，先进后出。 HashTable：就比HashMap多了个线程安全。 Enumeration：枚举，相当于迭代器。 12.迭代器 Iterator 是什么？ 迭代器是一种设计模式，它是一个对象，可以遍历并选择序列中的对象。而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】16. 3Sum Closest]]></title>
    <url>%2F458f351f.html</url>
    <content type="text"><![CDATA[1.题目描述Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 2.Solutions Similar to 3 Sum problem, use 3 pointers to point current element, next element and the last element. If the sum is less than target, it means we have to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise keep iterating. 123456789101112131415161718192021222324252627282930public static int threeSumClosest(int[] nums, int target)&#123; Arrays.sort(nums); int len = nums.length; int sum = nums[0]+nums[1]+nums[len-1]; int closest = sum; for (int i = 0; i &lt; len - 2; i++) &#123; if(i==0 || nums[i]!=nums[i-1])&#123; int left = i+1,right = len - 1; while(left &lt; right)&#123; sum = nums[i]+nums[left]+nums[right]; if(sum &lt; target)&#123; while(left&lt;right &amp;&amp; nums[left]==nums[left+1]) left++; left++; &#125;else if (sum &gt; target)&#123; //去除重复值 while(left&lt;right &amp;&amp; nums[right]==nums[right-1]) right--; right--; &#125;else&#123; return sum;//及时退出循环 &#125; //更新closest if(Math.abs(sum-target) &lt; Math.abs(closest-target))&#123; closest = sum; &#125; &#125; &#125; &#125; return closest;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2Ff7ede91d.html</url>
    <content type="text"><![CDATA[1.JDK 和 JRE 的区别JDK：Java Development Kit 的简称，提供了 java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，提供了java的运行环境。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。 2.== 和 equals 的区别== 对于基本类型来说是值比较，对于引用类型来说比较的是引用；而 equals本质上就是 == ，默认情况下是引用比较，只是很多类重写了 equals 方法。比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ 不一定！两个对象的 hashCode()相同，equals()不一定 true。 在Java里，equals()和hashCode()都是用来对比两个对象是否相等一致。它们的区别主要体现在性能和可靠性上：重写的equals（）比较全面比较复杂，但是效率低；而利用hashCode()进行对比，只要生成一个hash值进行比较就可以了，效率很高。 equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。一般的地方不需要重写hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重写hashCode。 4.final 在 java 中的作用 final 修饰的类叫最终类，该类不能被继承。 final 修饰的方法不能被重写。 final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。 5.java 中操作字符串类及其区别 操作字符串的类有：String、StringBuffer、StringBuilder。 String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象。而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。 StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer。所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。 6.String str=”i”与 String str=new String(“i”)是否一样 不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。 7.普通类和抽象类的区别 抽象方法：普通类不能包含抽象方法，抽象类可以包含抽象方法。 实例化：抽象类不能直接实例化，普通类可以直接实例化。 8.抽象类和接口的区别①实现：抽象类可以被继承，接口需要被实现。一个类只能继承一个抽象类，但是可以实现多个接口； ②抽象方法：抽象类可以有成员变量和非抽象的方法，而接口只能存在公共抽象方法； ③静态代码块：抽象类可以有静态代码块和静态方法，而接口中不能含有静态代码块以及静态方法； ④抽象：抽象类是对对象的抽象，然而接口是一种行为规范； ⑤main方法：抽象类可以有main方法，而接口不能有。 9.BIO、NIO、AIO 的区别 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2.0。实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 10.final、finally、finalize 的区别 final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize是一个方法，属于Object类的一个方法。而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize()，回收垃圾。 11.try-catch-finally 中哪个部分可以省略答：catch 可以省略 原因： 更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。 理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。 至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。 12.常见的异常类 NullPointerException：当应用程序试图访问空对象时，则抛出该异常。 SQLException：提供关于数据库访问错误或其他错误信息的异常。 IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。 IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。 ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。 ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。 IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。 ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。 NoSuchMethodException：无法找到某一特定方法时，抛出该异常。 SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。 UnsupportedOperationException：当不支持请求的操作时，抛出该异常。 RuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识总结]]></title>
    <url>%2F5fa0fed8.html</url>
    <content type="text"><![CDATA[操作系统思维导图 1.进程和线程以及它们的区别 进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发； 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发； 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在； 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。 2.进程间的通信的几种方式 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，命名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等； 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段； 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。 参考： https://blog.csdn.net/justloveyou_/article/details/78304294 https://blog.csdn.net/L664675249/article/details/47271941 https://zhuanlan.zhihu.com/p/23755202 https://juejin.im/entry/592257b62f301e006b183b95]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】15. 3Sum]]></title>
    <url>%2F5f395550.html</url>
    <content type="text"><![CDATA[1.题目描述Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets（三胞胎） in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 2.SolutionsThe idea is to sort an input array and then run through all indices（指数） of a possible first element of a triplet. For each possible first element we make a standard bi-directional（双向） 2Sum sweep（扫描） of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or something like that. 123456789101112131415161718192021222324public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length-2; i++) &#123; if (i == 0 || nums[i] != nums[i-1] ) &#123; int left = i+1, right = nums.length-1, sum = 0 - nums[i]; while (left &lt; right) &#123; if (nums[left] + nums[right] == sum) &#123; res.add(Arrays.asList(nums[i], nums[left], nums[right])); //去除重复 while (left &lt; right &amp;&amp; nums[left] == nums[left+1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right-1]) right--; left++; right--; &#125;else if (nums[left] + nums[right] &lt; sum)&#123; //排序过，所以这里小于必须left++ left++; &#125;else&#123; right--; &#125; &#125; &#125; &#125; return res;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】11. Container With Most Water]]></title>
    <url>%2F2a1c4f05.html</url>
    <content type="text"><![CDATA[1.题目描述 Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant（倾斜） the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: Input: [1,8,6,2,5,4,8,3,7]Output: 49 2.理解 The O(n) solution with proof by contradiction doesn’t look intuitive enough to me. Before moving on, read any example of the algorithm first if you don’t know it yet. Here’s another way to see what happens in a matrix（矩阵） representation: Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6. In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal（对角线）, the two lines are overlapped（重叠）; (2) The lower left triangle area of the matrix is symmetric（对称） to the upper right area. We start by computing the volume at (1,6), denoted（记） by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don’t need to compute those cases (crossed by ---). 1234567 1 2 3 4 5 61 x ------- o2 x x3 x x x 4 x x x x5 x x x x x6 x x x x x x Next we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated（消除、淘汰）. 1234567 1 2 3 4 5 61 x ------- o2 x x o3 x x x |4 x x x x |5 x x x x x |6 x x x x x x And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases. 1234567 1 2 3 4 5 61 x ------- o2 x x - o o o3 x x x o | |4 x x x x | |5 x x x x x |6 x x x x x x Hope this helps. I feel more comfortable seeing things this way. 3.Solutions AKA, the general idea to find some max is to go through all cases where max value can possibly occur and keep updating the max value. The efficiency of the scan depends on the size of cases you plan to scan. To increase efficiency, all we need to do is to find a smart way of scan to cut off the useless cases and meanwhile 100% guarantee the max value can be reached through the rest of cases. In this problem, the smart scan way is to set two pointers（双指针） initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan. Following is a brief prove of this. Given a1,a2,a3…..an as input array. Lets assume a10 and a20 are the max area situation. We need to prove that a10 can be reached by left pointer and during the time left pointer stays at a10, a20 can be reached by right pointer. That is to say, the core problem is to prove: when left pointer is at a10 and right pointer is at a21, the next move must be right pointer to a20. Since we are always moving the pointer with the smaller value, i.e. if a10 &gt; a21, we should move pointer at a21 to a20, as we hope. Why a10 &gt;a21? Because if a21&gt;a10, then area of a10 and a20 must be less than area of a10 and a21. Because the area of a10 and a21 is at least height[a10] (21-10) while the area of a10 and a20 is at most height[a10] (20-10). So there is a contradiction（矛盾） of assumption a10 and a20 has the max area. So, a10 must be greater than a21, then next move a21 has to be move to a20. The max cases must be reached. 1234567891011121314public static int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int maxArea = 0; while (left &lt; right) &#123; maxArea = Math.max(maxArea, Math.min(height[left],height[right]) * (right-left)); if (height[left] &lt; height[right]) left++; else right--; &#125; return maxArea; &#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机类专业学习路线杂谈]]></title>
    <url>%2F3564263.html</url>
    <content type="text"><![CDATA[最近帮弟弟选高考志愿专业，最后敲定计算机类专业（计算机科学与技术、软件工程、网络工程）。和主席在一起的时候就聊起了以前也经常聊的话题：计算机该如何学习？把这个问题的讨论记录下来，给自己深入学习指明方向，也给后来学习计算机的人一个方向。主席本科网络工程、研究生计算机技术，到现在计算机领域学习了6年。他自己说本科完全是被逼着、被动学习计算机；终于在研究生期间找到自己的学习方向，为他庆幸。而我，高中文科、大学非计算机专业理科、中途转行跨专业进入计算机领域学习软件工程工科，相信在回答如何从一个完全不懂计算机的门外汉到进入这个领域学习并不断深入研究，算是有一些自己的想法和理解；也能理解那些在学习过程中的困惑与迷惘。希望我们之间的闲谈、思想经验碰撞的火花能够提供一下学习计算机的启迪。 先放上一张计算机的思维导图： 如果在学习一个新知识体系前，就已经了解了这个知识的产生的原因、发展历程，那么对于学习肯定有帮助。如果一上来就讲解譬如分布式事务的CAP、BASE、两阶段提交等理论知识，而不是先讲解这个的产生以及发展或者说对你来说有什么用。我想，对于大部分没有了解过这个的来说，肯定会觉得枯燥、进而产生逆反心理；如果不是为了考试，我想一下课就恨不得还给老师。 譬如解释为什么苹果机运行流畅，而安卓机越用越卡的问题。原因是安卓基于Linux的宏内核、为了兼容各种配置的手机，代码需要跨平台，需要使用虚拟机解决这个问题。通过使用虚拟机翻译应用程序为机器码来运行。并且由于需要做内存管理，虚拟机需要做内存碎片化整理，这个时候整个系统都会卡顿一会。即使安卓通过优化提高系统运行速度，但是这个本质不会变。而苹果手机因为其封闭性，不用考虑兼容，应用程序直接翻译成高效的机器码来运行，并且苹果可以提供高效率的底层API给APP开发者调用，不用经过虚拟机的环节，每发布一个新机器就可以针对新机器进行优化，系统运行流畅度可以得到显著提高。这就是为什么“苹果机越升级越卡，安卓机越升级越流畅”的来历。如果你使用的还是当年诺基亚的功能机，根本没有接触这些手机。你就会想：教我这些有何用？只有真的用起来卡顿，才会有亲身体会，才会觉得学习这些真的有用。同样的对于一个完全没接触过类似只是或者没有碰到需要这些知识解决问题的场景，那么学这些到底有何用？ 所以基于这样的思路，对于刚进入大学学习计算机专业的学生来说，我和主席认为大致的安排可以这样： 第一阶段（一年半）：先学习应用于“上层”、可以交互的语言，比如Java、Python，做一两个网站或者爬虫，学会集成开发工具（IDE）的使用，能够解决常见的bug，积累一些获取相关知识的网站、论坛，懂得如何通过搜索引擎解决自己遇到的问题（使用Google），对计算机有一个感性的认识，培养自己的成就感。 第二阶段（一年）：通过一年半的学习，已经大概知道计算机的运行方式了。只不过到目前来讲，计算机相对来说还是一个黑盒：只知道这样子输入进去、会得到那样的结果，至于为什么会这样、中间程序出现了问题如何定位等等这些可能就不那么清楚了。如果只是停留在这一阶段，估计最终的结果就是面向搜索引擎、面向github编程。不生产代码、只做代码的搬运工了。所以这一阶段，需要深入学习计算机核心原理：包括操作系统（应用程序是跑在操作系统之上的，了解了操作系统原理，从而能够设计出优秀的代码；并且操作系统里面的很多思想也可以借鉴到解决其他问题中去）、计算机网络（计算机间数据如何通信的问题）、算法与数据结构（解决问题、提高计算效率的必备，而不是每次都是用暴力求解；同时学习这门课程，你会为有些算法思想的设计而感叹精妙绝伦）、数据库（数据存储的仓库，如今的计算机系统没有一个能够离开数据库的）、分布式（随着计算机成本的下降而对系统计算力的要求越来越高，计算机系统从过去的工作站、单机步入到大规模廉价的分布式集群。这涉及到分布式存储——数据库、计算机之间的通信——网络、节点之间的设计如数据热点等问题——算法以及操作系统的支持，几乎设计到计算机核心知识的方方面面）等。通过学习这些，知道计算机是如何运作的；并且学习前辈为了解决一个问题设计的算法和数据结构，从而举一反三，把这些思想用到解决自己的问题当中。 第三阶段（半年）：通过前面两年半的学习，已经对计算机有深入的理解了，这个时候再来学习晦涩难懂的编译原理等课程，也就有了更好的基础，而不是囫囵吞枣式的学习。 可以看出来，学习方向是自上而下学习的。从最开始的计算机语言到最底层的编译原理等，我觉得这样的学习路线可以为大多数人所接受而不是一开始学习就产生抗拒心理或者觉得发出——“计算机太难了”的感慨。 关于第一和第二阶段之间的过渡，引用之前微博上一位工作过人所提出的问题： 无头苍蝇说明的事实是：一方面业务代码已经很熟悉了，但是工作中碰到了目前所掌握的技术无法解决问题的焦虑。也就是说：功夫中的剑法已经很熟练了，但是内功不够。而想成为技术大神，必须苦练内功。而对于计算机的内功就是：计算机系统、网络、算法和数据结构，以及现在流行的分布式技术。独孤九剑很精湛，但是没有吸星大法的令狐冲照样不能持久。 优秀的计算机类书籍： Java/C：《深入理解Java虚拟机》、《Java并发编程实战》、《C程序设计语言》 架构：《大型网站技术结构：核心原理与案例分析》 操作系统：《深入理解计算机系统》、《UNIX环境高级编程》 计算机网络：《计算机网络（第5版）》、《Wireshark网络分析就这么简单》、《TCP/IP详解 卷1：协议》 算法与数据结构：算法竞赛入门经典（第2版）、LeetCode刷题、《剑指Offer》、《数据结构与算法分析：Java语言描述》、《数据结构与算法分析：C语言描述》、《算法设计与分析基础》 计算机组成原理：《编码 : 隐匿在计算机软硬件背后的语言》 科普及其他：《码农翻身》、《计算机是怎样跑起来的》、《网络是怎样连接的》、《程序是怎样跑起来的》、《黑客与画家 : 来自计算机时代的高见》、《人月神话》 英语：《六级词汇》、《红宝书·考研英语词汇》、《考研词汇速记指南》（为什么计算机类书籍中有英语？连编程语言都是用英语写的，更不用说浩如瀚海的英文doc、编程语言源码中的英文注释以及英文论坛、论文了。学习计算机要学习英语的重要性就不用再强调了吧。） 书籍列表持续更新…… 参考： 性能之殇（一）– 天才冯·诺依曼与冯·诺依曼瓶颈 我的Java后端书架 (2016年暖冬版) （完）]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】3.Longest Substring Without Repeating Characters]]></title>
    <url>%2Fd9fa86f8.html</url>
    <content type="text"><![CDATA[1.题目描述Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. Example 2: Input: “bbbbb”Output: 1Explanation: The answer is “b”, with the length of 1. Example 3: Input: “pwwkew”Output: 3Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 乍一看这道题目的时候，直接哇的一声，因为今年投大厂实习的时候，在线笔试碰到这道题。日拱一卒！加油！ 附上一段LeetCode评论： By the way, I was offered a job at Google, and I work there as a SWE now. Guys, practice leet code oj online, it really really helps! 2.Solutions 作者思路：使用一个HashMap存储字符串：key为字符，value为位置。并且使用两个指针i、j用来定义最大子串。使用指针i遍历整个数组，同时更新hashmap：如果字符出现在hashmap中，则移动指针j到上次找到的同样字符串加1的位置。注意：两个指针只能往前移动。 12345678910111213141516public static int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max=0; for (int i=0, j=0; i&lt;s.length(); ++i)&#123; if(map.containsKey(s.charAt(i)))&#123; //这里为什么要这么写，光看是很难看懂的 //引用一句话：This issue is hard to explain unless you write it! j = Math.max(j, map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】2.Add Two Numbers]]></title>
    <url>%2Fcaf13328.html</url>
    <content type="text"><![CDATA[1.题目描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 2.Solutions123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class AddTwoNumbers02 &#123; public static void main(String[] args) &#123; int[] arr1 = &#123;2,4,3&#125;; int[] arr2 = &#123;5,6,4&#125;; ListNode l1 = new ListNode(arr1[0]); ListNode l2 = new ListNode(arr2[0]); ListNode cur = l1; int i = 0; while(++i&lt;arr1.length)&#123; cur.next = new ListNode(arr1[i]); cur = cur.next; &#125; i = 0; cur = l2; while(++i&lt;arr2.length)&#123; cur.next = new ListNode(arr2[i]); cur = cur.next; &#125; cur = addTwoNumbers(l1,l2); while(cur != null)&#123; System.out.print(cur.val+" "); cur = cur.next; &#125; &#125; public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode sentinel = head; int sum = 0; while (l1 != null || l2 != null) &#123; sum /= 10; if (l1 != null) &#123; sum += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; sum += l2.val; l2 = l2.next; &#125; sentinel.next = new ListNode(sum % 10); sentinel = sentinel.next; &#125; if (sum / 10 == 1) sentinel.next = new ListNode(1); return head.next; &#125;&#125;class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【排序】计数排序、桶排序与基数排序]]></title>
    <url>%2Fbd8893db.html</url>
    <content type="text"><![CDATA[一、计数排序（Counting Sort） 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序的时间复杂度为 O(n + m )，m指的是数据量，说的简单点，计数排序算法的时间复杂度约等于O(n)，快于任何比较型的排序算法。 1.算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 2.动图演示 3.代码实现123456789101112131415161718192021222324public static int[] countingSort(int[] arr) &#123; int maxValue = 0; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; int bucketLen = maxValue + 1; int[] bucket = new int[bucketLen]; for (int value : arr) &#123; bucket[value]++; &#125; int sortedIndex = 0; for (int i = 0; i &lt; bucketLen; i++) &#123; while (bucket[i] &gt; 0) &#123; arr[sortedIndex++] = i; bucket[i]--; &#125; &#125; return arr;&#125; 4.算法分析 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 m 之间的整数时，时间复杂度是O(n+m)，空间复杂度也是O(n+m)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 二、桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快？当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢？当输入的数据被分配到了同一个桶中。 1.算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 2.动图演示 3.代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243public static int[] bucketSort(int[] arr, int bucketSize)&#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; //桶的数量 int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; //利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; //对每个桶进行排序，这里使用了插入排序 InsertionSort.insertionSort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr;&#125;//自动扩容，并保存数据public static int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr;&#125; 桶的数量我认为设置为原数组的长度是合理的，因为理想情况下每个数据装一个桶。 数据入桶的映射算法其实是一个开放性问题。 桶内排序为了方便起见使用了当前语言提供的排序方法，如果对于稳定排序有所要求，可以选择使用自定义的排序算法。 4.算法分析 桶排序最好情况下使用线性时间O(n)。桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 三、基数排序（Radix Sort） 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 假设说，我们要对 100 万个手机号码进行排序，应该选择什么排序算法呢？排的快的有归并、快排时间复杂度是 O(nlogn)。计数排序和桶排序虽然更快一些，但是手机号码位数是11位，那得需要多少桶？内存条表示不服。这个时候，我们使用基数排序是最好的选择。 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 基数排序：根据键值的每位数字来分配桶 1.算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 2.动图演示 3.代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public static void main(String[] args) &#123; int[] arr = &#123;22,1,55,7,20&#125;; int maxDigit = getMaxDigit(arr); arr = radixSort(arr, maxDigit); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+" "); &#125;&#125;//获取最高位数public static int getMaxDigit(int[] arr) &#123; int maxValue = getMaxValue(arr); return getNumLenght(maxValue);&#125;//获取最大值public static int getMaxValue(int[] arr) &#123; int maxValue = arr[0]; for (int value : arr) &#123; if (maxValue &lt; value) &#123; maxValue = value; &#125; &#125; return maxValue;&#125;public static int getNumLenght(long num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (long temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght;&#125;public static int[] radixSort(int[] arr, int maxDigit) &#123; int mod = 10; int dev = 1; for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; for (int j = 0; j &lt; arr.length; j++) &#123; int bucket = ((arr[j] % mod) / dev) + mod; counter[bucket] = arrayAppend(counter[bucket], arr[j]); &#125; int pos = 0; for (int[] bucket : counter) &#123; for (int value : bucket) &#123; arr[pos++] = value; &#125; &#125; &#125; return arr;&#125;//自动扩容，并保存数据private static int[] arrayAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr;&#125; 参考： hustcc/JS-Sorting-Algorithm 1.0 十大经典排序算法 十大经典排序算法（动图演示） 这或许是东半球分析十大排序算法最好的一篇文章 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【LeetCode】1.Two Sum]]></title>
    <url>%2Fe5726db5.html</url>
    <content type="text"><![CDATA[开启 LeetCode 刷题的旅程，这将是一段漫长而又艰辛的旅程，这是一条攀登珠穆朗玛的皑皑雪山路，这是通向 One Piece 宝藏的伟大航路，这是成为火影的无比残酷的修罗场，这是打破吊丝与高富帅之间界限的崩玉。但请不要害怕，在老船长 Grandyang 博主的带领下，必将一路披荆斩棘，将各位带到成功的彼岸。不过一定要牢记的是，不要下船，不要中途放弃，要坚持，要自我修炼，不断成长！ 这道 Two Sum 的题目作为 LeetCode 的开篇之题，乃是经典中的经典，正所谓“平生不识 TwoSum，刷尽 LeetCode 也枉然”，就像英语单词书的第一个单词总是 Abandon 一样，很多没有毅力坚持的人就只能记住这一个单词，所以通常情况下单词书就前几页有翻动的痕迹，后面都是崭新如初，道理不需多讲，鸡汤不必多灌，明白的人自然明白。 1.题目描述Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 2.Solutions暴力求解1234567891011121314//选择排序思想public static int[] twoSum(int[] nums, int target) &#123; int[] results = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i+1; j &lt; nums.length; j++) &#123; if(nums[i]+nums[j] == target)&#123; results[0] = i; results[1] = j; return results; &#125; &#125; &#125; return results;&#125; 时间复杂度：O(n2) 算法改进 一般来说，我们为了提高时间的复杂度，需要用空间来换，这算是一个 trade off 吧。我们只想用线性的时间复杂度来解决问题，那么就是说只能遍历一个数字，那么另一个数字呢？我们可以事先将其存储起来，使用一个 HashMap，来建立数字和其坐标位置之间的映射。我们都知道 HashMap 是常数级的查找效率，这样，我们在遍历数组的时候，用 target 减去遍历到的数字，就是另一个需要的数字了，直接在 HashMap 中查找其是否存在即可。 12345678910111213public static int[] twoSum2(int[] nums, int target) &#123; int[] results = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(map.containsKey(target-nums[i]))&#123; results[0] = map.get(target-nums[i]); results[1] = i; return results; &#125; map.put(nums[i], i); &#125; return results;&#125; 参考： LeetCode All in One 题目讲解汇总(持续更新中…) （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【排序】归并排序]]></title>
    <url>%2F5cb4dc3b.html</url>
    <content type="text"><![CDATA[一、归并排序（Merge Sort） 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 1.算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序（递归）； 将两个排序好的子序列合并成一个最终的排序序列。 具体为： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 2.动图演示 3.代码实现123456789101112131415161718192021222324252627282930313233343536public static int[] sort(int[] arr)&#123; if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right));&#125;protected static int[] merge(int[] left, int[] right) &#123; //申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result;&#125; 4.算法分析 归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 参考： 十大经典排序算法（动图演示） hustcc/JS-Sorting-Algorithm （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【排序】插入排序与希尔排序]]></title>
    <url>%2Fa3d61d56.html</url>
    <content type="text"><![CDATA[一、插入排序（Insertion Sort） 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。 1.算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 2.动图演示 3.代码实现1234567891011121314151617public static void insertionSort(int[] arr)&#123; int len = arr.length; int preIndex,current; //从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的序列 for (int i = 1; i &lt; len; i++) &#123; preIndex = i-1;//从已经排序的序列最右边的开始比较，找到比其小的数 current = arr[i];//记录要插入的数据 while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; //存在比其小的数，插入 if (preIndex != i-1) &#123; arr[preIndex + 1] = current; &#125; &#125;&#125; 4.算法分析 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 二、希尔排序（Shell Sort） 1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序（递减增量排序算法）。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 1.算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。 2.动图演示 3.代码实现版本一： 12345678910111213141516public static void shellSort(int[] arr)&#123; int len = arr.length; for (int gap=(int)Math.floor(len/2); gap &gt; 0; gap=(int)Math.floor(gap / 2)) &#123; //注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 //分别使用插入排序 for (int i = gap; i &lt; len; i++) &#123; int j = i; int current = arr[i]; while (j - gap &gt;= 0 &amp;&amp; arr[j - gap] &gt; current) &#123; arr[j] = arr[j - gap]; j = j - gap; &#125; arr[j] = current; &#125; &#125;&#125; 版本二： 123456789101112131415161718public static void shellSort2(int[] arr)&#123; int len = arr.length; int gap = 1; while (gap &lt; len) &#123; gap = gap * 3 + 1; &#125; for ( ; gap &gt; 0; gap=(int)Math.floor(gap / 3)) &#123; for (int i = gap; i &lt; len; i++) &#123; int current = arr[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; arr[j] &gt; current) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = current; &#125; &#125;&#125; 可能你会问为什么区间要以 gap = gap*3 + 1 去计算，其实最优的区间计算方法是没有答案的，这是一个长期未解决的问题，不过差不多都会取在二分之一到三分之一附近。 来源： hustcc/JS-Sorting-Algorithm 1.0 十大经典排序算法 十大经典排序算法（动图演示） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【排序】选择排序与堆排序]]></title>
    <url>%2F6b1a8360.html</url>
    <content type="text"><![CDATA[一、选择排序（Selection Sort） 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 1.算法步骤n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.动图演示 3.代码实现12345678910111213141516171819public static void selectionSort(int[] arr)&#123; // 总共要经过 length-1 轮比较 for (int i=0; i&lt;arr.length-1; i++) &#123; int min = i; // 每轮需要比较的次数 N-(i+1) for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125;&#125; 4.时间复杂度 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 性能分析 交换元素的代码写在内循环之外，每次交换都能排定一个元素，因此交换的总次数是 N。所以算法的时间效率取决于比较的次数。 查看代码可以精准得到，0 到 N-1 的任意 index都会进行一次交换和 N-1-index 次比较，所以对于长度为 N 的数组，选择排序需要大约 N²/2 次比较和 N 次交换。 选择排序的特点 ①运行时间和输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息； ②数据移动是最小的。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交换次数和数组的大小是线性关系。（其他大部分排序算法的增长数量级都是线性对数或是平方级别的） 5.优化 试想，上述方案中的主要思路是，每次遍历剩余元素，找出其中最小值，只排定最小值。（原有方案） 我们这样，每次遍历剩余元素的时候，找出其中最小值和最大值，并排定最小值和最大值。（优化方案） 这样遍历的次数会减少一半。时间复杂度是O（N/2 * N /2），还是平方级别的。但是运行时间有了相应的减少。 优化方案之后的运行轨迹 优化代码 1234567891011121314151617181920212223242526public static void selectionSortPlus(int[] arr) &#123; for (int left = 0, right = arr.length - 1; left &lt; right; left++, right--) &#123; int min = left; // 记录最小值 int max = right; // 记录最大值 for (int index = left; index &lt;= right; index++) &#123; if (arr[index]&lt;arr[min]) &#123; min = index; &#125; if (arr[max]&lt;arr[index]) &#123; max = index; &#125; &#125; // 将最小值交换到 left 的位置 swap(arr, left, min); //此处是先排最小值的位置，所以得考虑最大值（arr[max]）在最小位置（left）的情况。 if (left == max) &#123; max = min; &#125; swap(arr, right, max); &#125;&#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 二、堆排序（Heap Sort） 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 1.算法步骤 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 2.算法演示 3.代码实现1234567891011121314151617181920212223242526272829303132333435public static void heapSort(int[] arr)&#123; int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125;&#125;private static void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125;&#125;private static void heapify(int[] arr, int i, int len) &#123; int left = 2*i + 1; int right = 2*i + 2; int largest = i; //大顶堆：Key[i]&gt;=Key[2i+1]&amp;&amp;key[i]&gt;=key[2i+2] if (left&lt;len &amp;&amp; arr[left]&gt;arr[largest]) &#123; largest = left; &#125; if (right&lt;len &amp;&amp; arr[right]&gt;arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125;&#125;private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 来源： hustcc/JS-Sorting-Algorithm 1.0 十大经典排序算法 十大经典排序算法（动图演示） 参考： 选择排序及其优化 【算法】堆，最大堆（大顶堆）及最小堆（小顶堆）的实现 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【排序】冒泡排序与快速排序]]></title>
    <url>%2Fadd08081.html</url>
    <content type="text"><![CDATA[一、冒泡排序（Bubble Sort） 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 从序列的一端开始往另一端冒泡（你可以从左往右冒泡，也可以从右往左冒泡，看心情），依次比较相邻的两个数的大小（到底是比大还是比小也看你心情）。 作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是建立一个标志 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。 1.算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 外层循环每比较一次，这一趟中最大的数就沉底，而较小的数则上升一个位置。 2.动图演示 3.代码实现1234567891011121314151617181920public static int[] bubbleSort(int[] array) &#123; int len = array.length; if (len == 0) return array; for (int i = 0; i &lt; len - 1; i++)&#123;//一共要排序len-1次 //如果len=5 //第1次：i=0,需要比较4次，也就是len-1(len-1-i)次 //第2次：i=1,需要比较3次，也就是len-2(len-1-i)次 //第3次：i=2,需要比较2次，也就是len-3(len-1-i)次 //第4次：i=3,需要比较1次，也就是len-4(len-1-i)次，比较完毕 for (int j = 0; j &lt; len - 1 - i; j++)&#123;//选出该趟排序的最大值往后移动 if (array[j] &gt; array[j+1]) &#123;//相邻元素两两对比 int temp = array[j+1]; //元素交换 array[j+1] = array[j]; array[j] = temp; &#125; &#125; &#125; return array;&#125; 时间复杂度 最好：O(n)，最坏：O(n2)，平均：O(n2) 4.优化优化1：优化外层循环 若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。设置一个flag来判断当前数组是否已经有序，如果有序则退出循环，这样可以明显提高冒泡排序的表现。 12345678910111213141516171819202122public static int[] bubbleSortOptimize1(int[] array) &#123; int len = array.length; if (len == 0) return array; boolean flag = false; for (int i = 0; i &lt; len - 1; i++)&#123; flag = true;//每次遍历标志位都要先置为true，才能判断后面的元素是否发生了交换 for (int j = 0; j &lt; len - 1 - i; j++)&#123; if (array[j] &gt; array[j+1]) &#123; flag = false;//只要有发生了交换，flag就置为false int temp = array[j+1]; array[j+1] = array[j]; array[j] = temp; &#125; &#125; //如果为true，说明后面的元素已经有序，就直接break if(flag)&#123; break; &#125; &#125; return array; &#125; 优化2：优化内层循环 记住最后一次交换发生位置lastExchange的冒泡排序。 在每趟扫描中，记住最后一次交换发生的位置lastExchange（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数。 12345678910111213141516171819202122232425public static int[] bubbleSortOptimize2(int[] array) &#123; int len = array.length; if (len == 0) return array; boolean flag = false; int k = len - 1; int pos = 0;//pos变量用来标记循环里最后一次交换的位置 for (int i = 0; i &lt; len - 1; i++)&#123; flag = true; for (int j = 0; j &lt; k; j++)&#123; if (array[j] &gt; array[j+1]) &#123; flag = false; int temp = array[j+1]; array[j+1] = array[j]; array[j] = temp; pos = j;//循环里最后一次交换的位置 j赋给pos &#125; &#125; k = pos; if(flag)&#123; break; &#125; &#125; return array;&#125; 二、快速排序（Quick Sort） 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个数据要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序的核心思想是分治法（Divide and conquer），分而治之，策略是把一个串行（list）分为两个子串行（sub-lists），通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 它的实现方式是每次从序列中选出一个基准值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边。然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动。重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(nlogn) 的排序算法表现要更好，可是这是为什么呢？我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 1.算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 2.动图演示 3.代码实现123456789101112131415161718192021222324252627private static int[] quickSort(int[] arr, int startIndex, int endIndex) &#123; if (startIndex &lt; endIndex) &#123; int partitionIndex = partition(arr, startIndex, endIndex);//切分 quickSort(arr, startIndex, partitionIndex - 1); quickSort(arr, partitionIndex + 1, endIndex); &#125; return arr;&#125;//分区操作private static int partition(int[] arr, int startIndex, int endIndex) &#123; int pivot = arr[startIndex];//设定基准值（pivot） int mark = startIndex + 1;//Mark初始化为起始下标 for (int i = mark; i &lt;= endIndex; i++) &#123; if (arr[i] &lt; pivot) &#123; swap(arr, i, mark); mark++;//小于基准值 则mark+1，并交换位置。 &#125; &#125; swap(arr, startIndex, mark - 1); return mark - 1;&#125;private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 1234567public static void main(String[] args) &#123; int[] arr = &#123;55,22,1,7,20&#125;; quickSort(arr,0,arr.length-1); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+" "); &#125;&#125; 4.双边扫描 另外还有一种双边扫描的做法，看起来比较直观：我们随意抽取一个数作为基准值，然后从数组左右两边进行扫描，先从左往右找到一个大于基准值的元素，将下标指针记录下来，然后转到从右往左扫描，找到一个小于基准值的元素，交换这两个元素的位置，重复步骤，直到左右两个指针相遇，再将基准值与左侧最右边的元素交换。 我们来看一下实现代码，不同之处只有 partition 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void sort(int[] arr) &#123; sort(arr， 0， arr.length - 1);&#125;private static void sort(int[] arr， int startIndex， int endIndex) &#123; if (endIndex &lt;= startIndex) &#123; return; &#125; //切分 int pivotIndex = partition(arr， startIndex， endIndex); sort(arr， startIndex， pivotIndex-1); sort(arr， pivotIndex+1， endIndex);&#125;private static int partition(int[] arr， int startIndex， int endIndex) &#123; int left = startIndex; int right = endIndex; int pivot = arr[startIndex];//取第一个元素为基准值 while (true) &#123; //从左往右扫描 while (arr[left] &lt;= pivot) &#123; left++; if (left == right) &#123; break; &#125; &#125; //从右往左扫描 while (pivot &lt; arr[right]) &#123; right--; if (left == right) &#123; break; &#125; &#125; //左右指针相遇 if (left &gt;= right) &#123; break; &#125; //交换左右数据 int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; &#125; //将基准值插入序列 int temp = arr[startIndex]; arr[startIndex] = arr[right]; arr[right] = temp; return right;&#125; 快速排序的时间复杂度和归并排序一样，O(nlogn)。但这是建立在每次切分都能把数组一刀切两半差不多大的前提下。如果出现极端情况，比如排一个有序的序列，如[ 9，8，7，6，5，4，3，2，1 ]，选取基准值 9 ，那么需要切分 n - 1 次才能完成整个快速排序的过程。这种情况下，时间复杂度就退化成了 O(n2)，当然极端情况出现的概率也是比较低的。 所以说，快速排序的时间复杂度是 O(nlogn)，极端情况下会退化成 O(n2)。为了避免极端情况的发生，选取基准值应该做到随机选取，或者是打乱一下数组再选取。 另外，快速排序的空间复杂度为 O(1)。 来源： hustcc/JS-Sorting-Algorithm 1.0 十大经典排序算法 十大经典排序算法（动图演示） 参考： 冒泡排序算法及其两种优化 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[十大经典排序算法]]></title>
    <url>%2F827ca9cd.html</url>
    <content type="text"><![CDATA[一、算法分类十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。 计数排序、桶排序、基数排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 二、算法复杂度 排序方法 平均情况 最好情况 最坏情况 空间复杂度 稳定性 排序方式 冒泡排序 O(n2) O(n) O(n2) O(1) 稳定 内排序 选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 内排序 插入排序 O(n2) O(n) O(n2) O(1) 稳定 内排序 快速排序 O(nlogn) O(nlogn) O(n2) O(nlogn) 不稳定 内排序 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 内排序 希尔排序 O(n1.3) O(nlog2n) O(n2) O(1) 不稳定 内排序 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 外排序 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 外排序 桶排序 O(n+k) O(n) O(n2) O(n+k) 稳定 外排序 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 稳定 外排序 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 内排序：所有排序操作都在内存中完成。 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。 n: 数据规模。 m: “桶”的个数。 排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。 来源： hustcc/JS-Sorting-Algorithm 1.0 十大经典排序算法 参考： 这或许是东半球分析十大排序算法最好的一篇文章 十大经典排序算法最强总结（含JAVA代码实现） 十大经典排序算法（动图演示） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 TCP/IP 协议栈]]></title>
    <url>%2F3f8cb005.html</url>
    <content type="text"><![CDATA[TCP/IP 协议栈是一系列网络协议的总和，是构成网络通信的核心骨架，它定义了电子设备如何连入因特网，以及数据如何在它们之间进行传输。TCP/IP 协议采用4层结构，分别是应用层、传输层、网络层和链路层，每一层都呼叫它的下一层所提供的协议来完成自己的需求。由于我们大部分时间都工作在应用层，下层的事情不用我们操心；其次网络协议体系本身就很复杂庞大，入门门槛高，因此很难搞清楚TCP/IP的工作原理，通俗一点讲就是，一个主机的数据要经过哪些过程才能发送到对方的主机上。 接下来，我们就来探索一下这个过程。 0、物理介质 物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号(0和1)的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。 TCP/IP协议栈分为四层，每一层都由特定的协议与对方进行通信，而协议之间的通信最终都要转化为 0 和 1 的电信号，通过物理介质进行传输才能到达对方的电脑，因此物理介质是网络通信的基石。 下面我们通过一张图先来大概了解一下TCP/IP协议的基本框架： 当通过http发起一个请求时，应用层、传输层、网络层和链路层的相关协议依次对该请求进行包装并携带对应的首部，最终在链路层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。 网络通信就好比送快递，商品外面的一层层包裹就是各种协议，协议包含了商品信息、收货地址、收件人、联系方式等，然后还需要配送车、配送站、快递员，商品才能最终到达用户手中。 一般情况下，快递是不能直达的，需要先转发到对应的配送站，然后由配送站再进行派件。 配送车就是物理介质，配送站就是网关， 快递员就是路由器，收货地址就是IP地址，联系方式就是MAC地址。 快递员负责把包裹转发到各个配送站，配送站根据收获地址里的省市区，确认是否需要继续转发到其他配送站，当包裹到达了目标配送站以后，配送站再根据联系方式找到收件人进行派件。 有了整体概念以后，下面我们详细了解一下各层的分工。 1、链路层 网络通信就是把有特定意义的数据通过物理介质传送给对方，单纯的发送 0 和 1 是没有意义的，要传输有意义的数据，就需要以字节为单位对 0 和 1 进行分组，并且要标识好每一组电信号的信息特征，然后按照分组的顺序依次发送。以太网规定一组电信号就是一个数据包，一个数据包被称为一帧， 制定这个规则的协议就是以太网协议。一个完整的以太网数据包如下图所示： 整个数据帧由首部、数据和尾部三部分组成，首部固定为14个字节，包含了目标MAC地址、源MAC地址和类型；数据最短为46个字节，最长为1500个字节，如果需要传输的数据很长，就必须分割成多个帧进行发送；尾部固定为4个字节，表示数据帧校验序列，用于确定数据包在传输过程中是否损坏。因此，以太网协议通过对电信号进行分组并形成数据帧，然后通过物理介质把数据帧发送给接收方。那么以太网如何来识接收方的身份呢？ 以太网规协议定，接入网络的设备都必须安装网络适配器，即网卡， 数据包必须是从一块网卡传送到另一块网卡。而网卡地址就是数据包的发送地址和接收地址，也就是帧首部所包含的MAC地址，MAC地址是每块网卡的身份标识，就如同我们身份证上的身份证号码，具有全球唯一性。MAC地址采用十六进制标识，共6个字节， 前三个字节是厂商编号，后三个字节是网卡流水号，例如 4C-0F-6E-12-D2-19 有了MAC地址以后，以太网采用广播形式，把数据包发给该子网内所有主机，子网内每台主机在接收到这个包以后，都会读取首部里的目标MAC地址，然后和自己的MAC地址进行对比，如果相同就做下一步处理，如果不同，就丢弃这个包。 所以链路层的主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。 2、网络层对于上面的过程，有几个细节问题值得我们思考： 发送者如何知道接收者的MAC地址？ 发送者如何知道接收者和自己同属一个子网？ 如果接收者和自己不在同一个子网，数据包如何发给对方？ 为了解决这些问题，网络层引入了三个协议，分别是IP协议、ARP协议、路由协议。 【1】IP协议 通过前面的介绍我们知道，MAC地址只与厂商有关，与所处的网络无关，所以无法通过MAC地址来判断两台主机是否属于同一个子网。 因此，网络层引入了IP协议，制定了一套新地址，使得我们能够区分两台主机是否同属一个网络，这套地址就是网络地址，也就是所谓的IP地址。 IP地址目前有两个版本，分别是IPv4和IPv6，IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。由于各类地址的分法不尽相同，以C类地址192.168.24.1为例，其中前24位就是网络地址，后8位就是主机地址。因此， 如果两个IP地址在同一个子网内，则网络地址一定相同。为了判断IP地址中的网络地址，IP协议还引入了子网掩码， IP地址和子网掩码通过按位与运算后就可以得到网络地址。 由于发送者和接收者的IP地址是已知的(应用层的协议会传入)， 因此我们只要通过子网掩码对两个IP地址进行AND运算后就能够判断双方是否在同一个子网了。 【2】ARP协议 即地址解析协议，是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下： ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。cmd输入 arp -a 就可以查询本机缓存的ARP数据。 【3】路由协议 通过ARP协议的工作原理可以发现，ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议，首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据包；如果不在同一个子网，以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据包转发到目标IP所在的子网中，然后再通过ARP获取目标机MAC，最终也是通过广播形式将数据包发送给接收方。 而完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据包。 【4】IP数据包 在网络层被包装的数据包就叫IP数据包，IPv4数据包的结构如下图所示： IP数据包由首部和数据两部分组成，首部长度为20个字节，主要包含了目标IP地址和源IP地址，目标IP地址是网关路由的线索和依据；数据部分的最大长度为65515字节，理论上一个IP数据包的总长度可以达到65535个字节，而以太网数据包的最大长度是1500个字符，如果超过这个大小，就需要对IP数据包进行分割，分成多帧发送。 所以，网络层的主要工作是定义网络地址，区分网段，子网内MAC寻址，对于不同子网的数据包进行路由。 3、传输层 链路层定义了主机的身份，即MAC地址， 而网络层定义了IP地址，明确了主机所在的网段，有了这两个地址，数据包就从可以从一个主机发送到另一台主机。但实际上数据包是从一个主机的某个应用程序发出，然后由对方主机的应用程序接收。而每台电脑都有可能同时运行着很多个应用程序，所以当数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包。 因此传输层引入了UDP协议来解决这个问题，为了给每个应用程序标识身份，UDP协议定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，并且规定网络中传输的数据包必须加上端口信息。 这样，当数据包到达主机以后，就可以根据端口号找到对应的应用程序了。UDP定义的数据包就叫做UDP数据包，结构如下所示： UDP数据包由首部和数据两部分组成，首部长度为8个字节，主要包括源端口和目标端口；数据最大为65527个字节，整个数据包的长度最大可达到65535个字节。 UDP协议比较简单，实现容易，但它没有确认机制， 数据包一旦发出，无法知道对方是否收到，因此可靠性较差，为了解决这个问题，提高网络可靠性，TCP协议就诞生了，TCP即传输控制协议，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说TCP就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。 为了保证传输的可靠性，TCP 协议在 UDP 基础之上建立了三次对话的确认机制，也就是说，在正式收发数据前，必须和对方建立可靠的连接。由于建立过程较为复杂，我们在这里做一个形象的描述： 主机A：我想发数据给你，可以么？ 主机B：可以，你什么时候发？ 主机A：我马上发，你接着！ 经过三次对话之后，主机A才会向主机B发送正式数据，而UDP是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发过去了。所以 TCP 能够保证数据包在传输过程中不被丢失，但美好的事物必然是要付出代价的，相比 UDP，TCP 实现过程复杂，消耗连接资源多，传输速度慢。 TCP 数据包和 UDP 一样，都是由首部和数据两部分组成，唯一不同的是，TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过IP数据包的长度，以确保单个 TCP 数据包不必再分割。 总结一下，传输层的主要工作是定义端口，标识应用程序身份，实现端口到端口的通信，TCP协议可以保证数据传输的可靠性。 4、应用层 理论上讲，有了以上三层协议的支持，数据已经可以从一个主机上的应用程序传输到另一台主机的应用程序了，但此时传过来的数据是字节流，不能很好的被程序识别，操作性差。因此，应用层定义了各种各样的协议来规范数据格式，常见的有 HTTP、FTP、SMTP 等，HTTP 是一种比较常用的应用层协议，主要用于B/S架构之间的数据通信，其报文格式如下： 在 Resquest Headers 中，Accept 表示客户端期望接收的数据格式，而 ContentType 则表示客户端发送的数据格式；在 Response Headers 中，ContentType 表示服务端响应的数据格式，这里定义的格式，一般是和 Resquest Headers 中 Accept 定义的格式是一致的。 有了这个规范以后，服务端收到请求以后，就能正确的解析客户端发来的数据，当请求处理完以后，再按照客户端要求的格式返回，客户端收到结果后，按照服务端返回的格式进行解析。 所以应用层的主要工作就是定义数据格式并按照对应的格式解读数据。 5、全流程首先我们梳理一下每层模型的职责： 链路层：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据； 网络层：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发； 传输层：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序； 应用层：定义数据格式，并按照对应的格式解读数据。 然后再把每层模型的职责串联起来，用一句通俗易懂的话讲就是： 当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。 6、总结 以上内容是对TCP/IP四层模型做了简单的介绍，而实际上每一层模型都有很多协议，每个协议要做的事情也很多，但我们首先得有一个清晰的脉络结构，掌握每一层模型最基本的作用，然后再去丰富细枝末节的东西，也许会更容易理解。 原创发布 @一像素 2017.06.29 更新： 2018.06.06 参考文献： [1] 互联网协议入门（一） [2] TCP/IP协议知识科普 （完）]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【树】平衡二叉树(AVL树)的设计与实现]]></title>
    <url>%2Fff266de3.html</url>
    <content type="text"><![CDATA[一、普通二叉查找树的问题 基于二叉查找树的特性，即对于树中的每个结点T（T可能是父结点）,它的左子树中所有项的值小T中的值，而它的右子树中所有项的值都大于T中的值。这意味着该树所有的元素可以用某种规则进行排序(取决于Comparable接口的实现)，以致于二叉树查找树能够胜任快速地查找过程，这个查找的过程的时间复杂度为O(logN)。但是这个时间复杂度并不是严格意义上的O(logN)，在某些情况下还是会上升到O(N)。显然这并不是一件好事情，因此本篇我们将来讨论另一种更为稳定的二叉树，它就是AVL树。 如果利用上篇实现的二叉搜索树将一段已排序好的数据一个个插入后，就会发现如下情况了： 从图中我们可以发现，把已排序的1-9数据进行正序和倒序插入后，树的结构已变成单向左子树或者右子树了。如果我们在往里插入已排序的数据，那么单向左子树或者右子树越来越长，此时已跟单链表没有什么区别了。因此对此结构的操作时间复杂度自然就由O(logn)变成O(n)了，这也就是普通二叉查找树不是严格意义上O(logn)的原因。 那么该如何解决这个问题呢？事实上一种解决的办法就是要有一个称为平衡的附加结构条件：任何结点的深度不得过深。而这种数据结构就是我们本篇要分析的平衡二叉树（AVL），它本身也是一种二叉查找树，只不过不会出现前面我们分析的情形罢了。 二、平衡二叉树的定义 通过上面的分析，我们明白的普通二叉查找树的不足，也知道了如何去解决这个缺点，即构建树时要求任何结点的深度不得过深（子树高度相差不超过1），而最终这棵树就是平衡二叉树（Balanced Binary Tree）。它是G.M. Adelson-Velsky 和 E.M. Landis在1962年在论文中发表的，因此又叫AVL树。这里我们还需要明确一个概念，AVL树只是实现平衡二叉树的一种方法，它还有很多的其他实现方法如红黑树、替罪羊树、Treap、伸展树等。 接着来了解一下AVL树的特性：一棵AVL树是其每个结点的左子树和右子树的高度最多相差1的二叉查找树(空树的高度为-1)，这个差值也称为平衡因子（其取值可以是1，0，-1，平衡因子是某个结点左右子树层数的差值，有的书上定义是左边减去右边，有的书上定义是右边减去左边，这样可能会有正负的区别，但是这个并不影响我们对平衡二叉树的讨论）。如下图 理解了平衡二叉树的概念后，我们再思考一下，那些操作可能引起平衡发生变化呢？显然只有那些引起结点数量变化的操作才可能导致平衡被改变，也就是删除和插入操作了。如下图，我们把6插入到图a后，结构变成了图b，这时原本的平衡二叉树就失去平衡了。 显然图b已失去平衡。如果发生这样的情况，我们就必须考虑插入元素后恢复二叉树的平衡性质。实际上也总是可以通过对树进行简单的修复来让其重新恢复到平衡，而这样的简单操作我们就称之为旋转。当然旋转也有单旋转和双旋转之分，下面我们将会一一分析。 这里有点需要明白的是，无论是插入还是删除，只有那些从插入或者删除点到根结点路径上的结点的平衡才有可能被改变，上图中也就是从结点6到根结点5的平衡被改变了。因为只有这些结点的子树才可能发生变化，所以最终也只需针对这些点进行平衡修复操作即可。 三、平衡二叉树的设计与实现 ok~，有了旋转的概念后，我们接着了解如何通过旋转来修复一棵失衡的二叉树。这里假设结点X是失衡点，它必须重新恢复平衡。由于任意结点的孩子结点最多有两个，而且导致失衡的必要条件是X结点的两棵子树高度差为2(大于1)，因此一般只有以下4种情况可能导致X点失去平衡： ① 在结点X的左孩子结点的左子树中插入元素 ② 在结点X的左孩子结点的右子树中插入元素 ③ 在结点X的右孩子结点的左子树中插入元素 ④ 在结点X的右孩子结点的右子树中插入元素 以上4种情况，其中第①情况和第④情况是对称的，可以通过单旋转来解决。而第②种情况和第③情况是对称的，需要双旋转来解决。在分析这四种情况前，我们先看看AVL的结点该如何设计的，其声明如下： 12345678910111213141516171819202122232425/** * Created by zejian on 2016/12/25. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] * 平衡二叉搜索树(AVL树)节点 */public class AVLNode&lt;T extends Comparable&gt; &#123; public AVLNode&lt;T&gt; left;//左结点 public AVLNode&lt;T&gt; right;//右结点 public T data; public int height;//当前结点的高度 public AVLNode(T data) &#123; this(null,null,data); &#125; public AVLNode(AVLNode&lt;T&gt; left, AVLNode&lt;T&gt; right, T data) &#123; this(left,right,data,0); &#125; public AVLNode(AVLNode&lt;T&gt; left, AVLNode&lt;T&gt; right, T data, int height) &#123; this.left=left; this.right=right; this.data=data; this.height = height; &#125;&#125; 可以看出，为了满足平衡二叉树的特性，需要在原来的二叉搜索树(BST)的结点中添加一个height的字段表示高度，方便我们计算。这里强调一下，高度和深度是一组相反的概念。高度是指当前结点到叶子结点的最长路径，如所有叶子结点的高度都为0；而深度则是指从根结点到当前结点的最大路径，如根结点的深度为0。这里约定空结点（空子树）的高度为-1，叶子结点的高度为0，非叶子节点的高度则根据其子树的高度而计算获取。如下图： 四、平衡二叉树的旋转算法与实现1.左左单旋转(LL)：情景①分析 从下图可以看出，结点X并不能满足AVL树的性质，因为它的左子树比右子树深2层。这种情况就是典型的LL情景，此时需要通过右向旋转来修复失衡的树。 如下图1，X经过右旋转后变成图2，W变为根结点，X变为W的右子树；同时W的右子树变为X的左子树，树又重新回到平衡，各个结点的子树高度差都已在正常范围。一般情况下，我们把X结点称为失衡点。修复一棵被破坏的AVL树时，找到失衡点是很重要的，并把通过一次旋转即可修复平衡的操作叫做单旋转。 从图3和图4可知，在原始AVL树插入7结点后，结点9变为失衡点，树不再满足AVL性质，因此需要对9结点进行左左单旋转（即向右旋转）后，得到图4。我们发现此时并没有操作树的根结点(6)。实际上这是因为正常情况下，不必从树的根结点进行旋转，而是从插入结点处开始，向上遍历树，并更新和修复在这个路径上的每个结点的平衡及其平衡信息(高度)即可。 其代码实现如下，比较简单： 12345678910//左左单旋转(LL旋转) W变为X的根结点, X变为W的右子树private AVLNode&lt;T&gt; singleRotateLeft(AVLNode&lt;T&gt; x)&#123; AVLNode&lt;T&gt; w=x.left;//把w结点旋转为根结点 x.left=w.right; //同时w的右子树变为x的左子树 w.right=x; //x变为w的右子树 //重新计算x/w的高度 x.height=Math.max(height(x.left),height(x.right))+1; w.height=Math.max(height(w.left),x.height)+1; return w;//返回新的根结点&#125; 2.右右单旋转(RR)：情景④分析 接着再来看看右右单旋转(RR)的情景。如下图，可以发现与左左单旋转的情况恰好是一种镜像关系，同样结点X并不能满足AVL树的性质。在这样的情景下，需要对X结点进行左旋转来修复树的平衡， 如图1经左旋转后变了图2，此时X变为了根结点，W变为X的左孩子，X的左子树变为W的右子树，而树又重新恢复了平衡。 如图3和图4的实例情景，原始的AVL树在12处插入结点18后，结点10就变成了失衡点。因为10的左子树和右子树的高度相差2，显然不符合AVL树性质，需要对结点10进行右右单旋转修复(向左旋转)。然后得到图4，此时树重新回到了平衡，这便是右右单旋转(RR)的修复情景。 1234567891011//右右单旋转(RR旋转) x变为w的根结点, w变为x的左子树private AVLNode&lt;T&gt; singleRotateRight(AVLNode&lt;T&gt; w)&#123; AVLNode&lt;T&gt; x=w.right; w.right=x.left; x.left=w; //重新计算x/w的高度 x.height=Math.max(height(x.left),w.height)+1; w.height=Math.max(height(w.left),height(w.right))+1; //返回新的根结点 return x;&#125; 3.左右双旋转(LR)：情景②分析 前面两种情景都已分析完，它们都是基于单旋转的算法。但这种算法存在一个问题，那就是对情景②③无法生效，根本问题在于子树Y太深了。如下图所示： 显然经过一次单旋转的修复后无论是X或者W作为根结点都无法符合AVL树的性质。此时就需要用双旋转算法来实现了。由于子树Y是在插入某个结点后导致X结点的左右子树失去平衡，那么就说明子树Y肯定是非空的。因此为了易于理解，我们可以把子树Y看作一个根结点和两棵子树，如下图所示： 为了重新平衡，通过上述的分析显然不能把X作为根结点，而X与W间的旋转也解决不了问题。那唯一的旋转就是把Y作为新根。这样的话，X、W就不得不成为Y的孩子结点，其中W作为Y的左孩子结点，而X成为Y的右孩子结点。 这里我们以下图为例来分析。为了达到以上结果，需要W、Y进行单旋转（图1）。这里我们可把WY组成的子树看成前面的右右旋转情景，然后进行左向旋转，得到图2：W变为Y的左子树同时Y的左子树B变成W的右子树，其他不变到此第一次旋转完成。（右右单旋转，RR） 然后进行第二次旋转，以X结点向右进行旋转(同样可看作左左情景)，由图2得到图3：X变成Y的右孩子结点并且Y的右子树C变成X的左子树，第二次旋转完成，树也重新恢复到平衡。（左左单旋转，LL） 在左右双旋转实例图123中，在原AVL树种插入结点7后，结点8变成了失衡点，此时需要把6结点变为根结点才能重新恢复平衡。因此先进行左向旋转再进行右向旋转，最后树恢复平衡。算法代码实现如下： 1234567//左右旋转(LR旋转) x(根) w y 结点 把y变成根结点private AVLNode&lt;T&gt; doubleRotateWithLeft(AVLNode&lt;T&gt; x)&#123; //w先进行RR旋转 x.left=singleRotateRight(x.left); //再进行x的LL旋转 return singleRotateLeft(x);&#125; 4.右左双旋转(RL)：情景③分析 对于右左双旋转(RL)情景和左右双旋转(LR)情景是一对镜像，旋转的原理上一样的。这里就不废话了，给出下图协助理解即可(已很清晰了)： 1234567//右左旋转(RL旋转)private AVLNode&lt;T&gt; doubleRotateWithRight(AVLNode&lt;T&gt; w)&#123; //先进行LL旋转 w.right=singleRotateLeft(w.right); //再进行RR旋转 return singleRotateRight(w);&#125; 五、平衡二叉树插入操作的实现 实际上，有了上述四种情况后，编写插入操作的编码细节并不会太困难。这里我们给出主要思路和代码实现，与BST（二叉查找树）的插入实现原理一样，使用递归算法，根据值大小查找到插入位置，然后进行插入操作。插入完成后，我们需要进行平衡判断。评估子树是否需要进行平衡修复，需要则利用上述的四种情景套入代码即可。最后要记得重新计算插入结点路径上的高度。代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//插入方法@Overridepublic void insert(T data) &#123; if (data==null) throw new RuntimeException("data can\'t not be null "); this.root=insert(data,root);&#125;private AVLNode&lt;T&gt; insert(T data , AVLNode&lt;T&gt; p)&#123; //说明已没有孩子结点,可以创建新结点插入了. if(p==null)&#123; p=new AVLNode&lt;T&gt;(data); &#125; int result=data.compareTo(p.data); if(result&lt;0)&#123;//向左子树寻找插入位置 p.left=insert(data,p.left); //插入后计算子树的高度,等于2则需要重新恢复平衡,由于是左边插入,左子树的高度肯定大于等于右子树的高度 if(height(p.left)-height(p.right)==2)&#123; //判断data是插入点的左孩子还是右孩子 if(data.compareTo(p.left.data)&lt;0)&#123; p=singleRotateLeft(p);//LL旋转 &#125;else &#123; p=doubleRotateWithLeft(p); //进行左右旋转 &#125; &#125; &#125; if (result&gt;0)&#123;//向右子树寻找插入位置 p.right=insert(data,p.right); if(height(p.right)-height(p.left)==2)&#123; if (data.compareTo(p.right.data)&lt;0)&#123; p=doubleRotateWithRight(p);//进行右左旋转 &#125;else &#123; p=singleRotateRight(p);//RR旋转 &#125; &#125; &#125; //重新计算各个结点的高度 p.height = Math.max( height( p.left ), height( p.right ) ) + 1; return p;//返回根结点&#125; 六、平衡二叉树删除操作的实现 关于平衡二叉树的删除，我们这里给出一种递归的实现方案。和二叉查找树中删除方法的实现类似，但是在移除结点后需要进行平衡检测，以便判断是否需要进行平衡修复。主要明白的是，这种实现方式在删除时效率并不高，不过我们并不打算过多讨论它，更复杂的删除操作过程将放在红黑树中进行讨论。下面给出实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//删除方法@Overridepublic void remove(T data) &#123; if (data==null) throw new RuntimeException("data can\'t not be null "); this.root=remove(data,root);&#125;//删除操作private AVLNode&lt;T&gt; remove(T data,AVLNode&lt;T&gt; p)&#123; if(p ==null) return null; int result=data.compareTo(p.data); //从左子树查找需要删除的元素 if(result&lt;0)&#123; p.left=remove(data,p.left); //检测是否平衡 if(height(p.right)-height(p.left)==2)&#123; AVLNode&lt;T&gt; currentNode=p.right; //判断需要那种旋转 if(height(currentNode.left)&gt;height(currentNode.right))&#123; //RL p=doubleRotateWithRight(p); &#125;else&#123; //RR p=singleRotateRight(p); &#125; &#125; &#125; //从右子树查找需要删除的元素 else if(result&gt;0)&#123; p.right=remove(data,p.right); //检测是否平衡 if(height(p.left)-height(p.right)==2)&#123; AVLNode&lt;T&gt; currentNode=p.left; //判断需要那种旋转 if(height(currentNode.right)&gt;height(currentNode.left))&#123; //LR p=doubleRotateWithLeft(p); &#125;else&#123; //LL p=singleRotateLeft(p); &#125; &#125; &#125; //已找到需要删除的元素,并且要删除的结点拥有两个子节点 else if(p.right!=null&amp;&amp;p.left!=null)&#123; //寻找替换结点 p.data=findMin(p.right).data; //移除用于替换的结点 p.right = remove( p.data, p.right ); &#125;else&#123; //只有一个孩子结点或者只是叶子结点的情况 p=(p.left!=null)? p.left:p.right; &#125; //更新高度值 if(p!=null) p.height = Math.max( height( p.left ), height( p.right ) ) + 1; return p;&#125; 七、平衡二叉树的最少结点数和最多结点数问题 关于最少结点数和最多结点数的问题，为了方便理解和简单化问题，这里我们假设AVL树的高度是h，N(h)表示高度为h的AVL树的结点数。对于求解高度为h的AVL树的最少结点数，则应该尽可能用最少结点数来填充该树，现在假设左子树填充到的高度为h-1，根据AVL树的特性，右子树的高度只能填充到h-2，因此高度为h的AVL树的最小结点数为： N(h) = N(h-1) + N(h-2) + 1 其中： N(h-1) 代表高度为h-1的左子树的最小结点数 N(h-2) 代表高度为h-2的右子树的最小结点数 1 代表当前结点(根)。 求解上述递归公式可得（计算过程涉及线性代数的知识点，这里就不详细分析求解过程，毕竟我们主要求时间复杂度相关问题）其中n是AVL树的节点数： N(h)=O(1.618h)=&gt;h=1.44logn≈O(logn) 通过上述的递推公式，我们也可以发现最少结点数的求解公式恰好符合斐波那契数列的规律（F(n)=F(n-1)+F(n-2)），因此求解最少结点数也就变得容易多了。 接着，我们采用同样的方法计算最大结点数。为了得到最大结点数，则左右子树的高必须相等，即都填充到h-1。由于结点都充满了，那么该树不仅是AVL树而且还是一个完全二叉树了，则会有如下公式： N(h) = N(h-1) + N(h-1) + 1 = 2N(h-1) + 1 最终求解该递归公式得： N(h)=O(2h)=&gt;h=logn≈O(logn) 因此在两种情况下，AVL树的性质可以确保带有n个结点的AVL树的高度为O(logn)。这也意味着AVL树的操作在时间复杂度上近乎于O(logn)，也就不可能出现BST(二叉查找树)的最糟糕情况O(n)。 作者github源码下载（含文章列表） 来源：java数据结构与算法之平衡二叉树(AVL树)的设计与实现 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【树】二叉树的构建]]></title>
    <url>%2F228ea7da.html</url>
    <content type="text"><![CDATA[一、完全二叉树的构建 明白了层次遍历算法后，我们可以利用层次遍历算法来构建一棵完全二叉树。为什么是完全二叉树而不是二叉树呢？因为层次遍历不能确定唯一的一棵二叉树，但是可以确定一棵完全二叉树，这是由完全二叉树的特性所决定的。 如果对一颗有n个结点的完全二叉树（其深度为[log2n]+1）的结点按层序编号（从第1层到第[log2n]+1，每层从左到右），对任一结点i（1≤i≤n）有： 1.如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是节点[i/2]（向下取整） 2.如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是节点2i 3.如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1 因此很容易知道第1个结点就是完全二叉树，而左孩子结点序号为2i，否则没有左孩子；右结点序号为2i+1，否则没有右孩子，这样的编号恰好符合层次遍历的访问顺序。因此层次遍历确实可以确定一棵完全二叉树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Created by zejian on 2016/12/17. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] * 利用层次遍历原理构造完全二叉树 */public class CompleteBinaryTree&lt;T extends Comparable&gt; extends BinarySearchTree &lt;T&gt; &#123; //构建空完全二叉树 public CompleteBinaryTree()&#123; super(); &#125; //以层序遍历构造完全二叉树 public CompleteBinaryTree(T[] levelOrderArray)&#123; this.root = create(levelOrderArray, 1); &#125; //层次遍历构造完全二叉树 public BinaryNode&lt;T&gt; create(T[] levelOrderArray ,int i)&#123; if(levelOrderArray ==null)&#123; throw new RuntimeException("the param 'array' of create method can\'t be null !"); &#125; BinaryNode&lt;T&gt; p = null; if (i &lt; levelOrderArray.length)&#123;//递归结束条件 p=new BinaryNode&lt;&gt;(levelOrderArray[i],null,null); p.left=create(levelOrderArray,2*i); //根据完全二叉树的性质 2*i为左孩子结点 p.right=create(levelOrderArray,2*i+1); //2*i+1为右孩子结点 &#125; return p; &#125; /** * 搜索二叉树的包含操作和移除操作不适合层次遍历构造的完全二叉树 * 根据层次遍历构建的二叉树必须用层次遍历来判断(仅适用层次遍历构建的完全二叉树) */ @Override public boolean contains(T data) &#123; //存放需要遍历的结点,左结点一定优先右节点遍历 Queue&lt;BinaryNode&lt;T&gt;&gt; queue=new LinkedList&lt;&gt;(); BinaryNode&lt;T&gt; p=this.root; while (p!=null)&#123; //判断是否存在data if(data.compareTo(p.data)==0)&#123; return true; &#125; //先按层次遍历结点,左结点一定在右结点之前访问 if(p.left!=null)&#123; queue.add(p.left);//孩子结点入队 &#125; if (p.right!=null)&#123; queue.add(p.right); &#125; //访问下一个结点 p=queue.poll(); &#125; return false; &#125;&#125; 二、二叉树的构建 了解了完全二叉树的构造，现在我们回过头来看看二叉树又该如何构造呢？显然从完全二叉树的分析中发现，无论是前序遍历或者是中序遍历还是后序遍历，都无法唯一确定一棵树。都将面临之前的问题，遍历顺序为AB的树都可能有两种情况。因此已知二叉树的一种遍历顺序，不能唯一确定一棵二叉树。这是因为后序和前序次序反映的都是父母与孩子结点间的关系而没有反映兄弟间的关系，而中序次序反映的则是兄弟结点间的关系。既然这样，我们能不能考虑结合两种遍历顺序来构造一个二叉树呢？答案是肯定的。确实可以通过前序遍历和中序遍历次序或者后序和中序遍历次序唯一确定一棵二叉树，而先序和后序遍历反应的都是父母与孩子结点的关系，自然也就无法确定一棵唯一二叉树了。如给出先序顺序AB和后序顺序BA，可以确定A是根结点，但B呢，是左孩子还是右孩子呢？无法确定。 1.前序与中序构建二叉树及其代码实现 已知先根序列preList=ABDGCEFH和中根序列inList=DGBAECHF，确定二叉树的过程如下： 从图中我们可以发现整个构建过程都是在不断递归，即将复杂树简化为子树进行求解。上述过程我们可以这样描述，设数组preList和inList分别表示一个二叉树的先根和中根遍历次序，两个序列的长度都为n，则二叉树构建过程分如下步骤： ①由先根遍历次序可知，二叉树的根结点为preList[0],该根结点也肯定在中根序列中，设中根序列inList中根结点的位置为root(0≤root≤n-1),则有preList[0]=inList[root] ②根据中根遍历次序可知，inList[root]之前的结点都为根结点的左子树，inList[root]之后的结点都为根结点的右子树，因此根结点的左子树由root个结点组成，子序列如下： 左子树的先根序列：preList[1] , … , preList[root]左子树的中根序列：inList[0] , … , inList[root-1] 根结点的右子树有n-root-1个结点组成，子序列如下： 右子树的先根序列：preList[root+1] , … , preList[n-1]右子树的中根序列：inList[root+1] , … , inList[n-1] ③ 循环递归步骤①②，即可确定二叉树 以上3个步骤便是通过先根次序和中根次序确定一棵二叉树的过程，大家可结合图理解这过程，这里顺带给出实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 根据先根和中根遍历算法构造二叉树 * @param preList 先根遍历次序数组 * @param inList 中根遍历次序数组 * @param preStart 先根数组中，左/右子树开始下标 * @param preEnd 先根数组中，左/右子树结束下标 * @param inStart 中根数组中，左/右子树开始下标 * @param inEnd 中根数组中，左/右子树结束下标 * return root 最终返回的根结点 */public BinaryNode&lt;T&gt; buildBSTreeByPreIn(T[] preList,T[] inList,int preStart,int preEnd,int inStart,int inEnd)&#123; //preList[preStart]必须根结点数据,创建根结点root BinaryNode&lt;T&gt; p=new BinaryNode&lt;&gt;(preList[preStart]); //如果没有其他元素,就说明结点已构建完成 if (preStart == preEnd &amp;&amp; inStart == inEnd) &#123; return p; &#125; int root=0;//找出中根次序中，根结点的下标 for (root = inStart; root &lt; inEnd; root++) &#123; //如果中根次序中的元素值与先根次序中根结点的值相等,则该下标index即为inList中的根结点下标 if (preList[preStart].compareTo(inList[root])==0) break; &#125; //获取左子树的长度 int leftLength=root-inStart; //获取右子树的长度 int rightLength=inEnd-root; //递归构建左子树 if(leftLength&gt;0)&#123; //左子树的先根序列：preList[1] , ... , preList[i] //左子树的中根序列：inList[0] , ... , inList[i-1] //A:root=3 preStart=0 leftLength=3 //B:root=2 preStart=1 leftLength=2 //所以preStart+leftLength不能换成root p.left=buildBSTreeByPreIn(preList,inList,preStart+1,preStart+leftLength,inStart,root-1); &#125; //递归构建右子树 if (rightLength&gt;0)&#123; //右子树的先根序列：preList[i+1] , ... , preList[n-1] //右子树的中根序列：inList[i+1] , ... , inList[n-1] p.right=buildBSTreeByPreIn(preList,inList,preStart+leftLength+1,preEnd,root+1,inEnd); &#125; return p;&#125; 2.后根与中根次序构建二叉树及其代码实现 同样的情况，根据中根次序和后根次序，我们也可以确定唯一一棵二叉树，后根次序为GDBEHFCA，中根次序为DGBAECHF，其确定二叉树执行过程如下： 上述过程我们也可以这样描述，设数组postList和inList分别表示一个二叉树的后根和中根遍历次序，两个序列的长度都为n，则二叉树构建过程分如下步骤： ①由后根遍历次序可知，二叉树的根结点为postList[n-1]，该根结点也肯定在中根序列中，设中根序列inList中根结点的位置为root(0≤root≤n-1),则有postList[n-1]=inList[root] ②根据中根遍历次序可知，inList[root]之前的结点都为根结点的左子树，inList[root]之后的结点都为根结点的右子树，因此根结点的左子树由i个结点组成，子序列如下： 左子树的后根序列：postList[0] , … , preList[root-1]左子树的中根序列：inList[0] , … , inList[root-1] 根结点的右子树有n-root-1个结点组成，子序列如下： 右子树的后根序列：postList[root] , … , postList[n-2]右子树的中根序列：inList[root+1] , … , inList[n-1] ③ 循环递归步骤①②，即可确定二叉树 到此利用后根、中根遍历算法构建二叉树的过程就已全部描述完成了，实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 后根/中根遍历构建二叉树 * @param postList 后根遍历数组 * @param inList 中根遍历数组 * @param postStart 后根数组中，左/右子树开始下标 * @param postEnd 后根数组中，左/右子树结束下标 * @param inStart 中根数组中，左/右子树开始下标 * @param inEnd 中根数组中，左/右子树结束下标 * @return 根结点 */public BinaryNode&lt;T&gt; buildBSTreeByPostIn(T[] postList,T[] inList,int postStart,int postEnd,int inStart,int inEnd)&#123; //构建根结点 BinaryNode&lt;T&gt; p=new BinaryNode&lt;&gt;(postList[postEnd]); if(postStart==postEnd &amp;&amp; inStart==inEnd)&#123; return p; &#125; //查找中根序列的根结点下标root int root=0; for (root=inStart;root&lt;inEnd;root++)&#123; if (postList[postEnd].compareTo(inList[root])==0) break; &#125; //左子树的长度 int leftLenght=root-inStart; //右子树的长度 int rightLenght=inEnd-root; //递归构建左子树 if(leftLenght&gt;0)&#123; //左子树的后根序列：postList[0] , … , preList[root-1] //左子树的中根序列：inList[0] , … , inList[root-1] //postStart+leftLenght-1:后根左子树的结束下标 p.left=buildBSTreeByPostIn(postList,inList,postStart,postStart+leftLenght-1,inStart,root-1); &#125; //递归构建右子树 if(rightLenght&gt;0)&#123; //右子树的后根序列：postList[root] , … , postList[n-2] //右子树的中根序列：inList[root+1] , … , inList[n-1] p.right=buildBSTreeByPostIn(postList,inList,postStart+leftLenght,postEnd-1,root+1,inEnd); &#125; return p;&#125; 测试代码 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String args[])&#123; String[] preList=&#123;"A","B","D","G","C","E","F","H"&#125;; String[] inList=&#123;"D","G","B","A","E","C","H","F"&#125;; String[] postList=&#123;"G","D","B","E","H","F","C","A"&#125;; //先根/中根 BinarySearchTree&lt;String&gt; cbtree = new BinarySearchTree&lt;&gt;(preList,inList,true); //后根/中根 BinarySearchTree&lt;String&gt; cbtree = new BinarySearchTree&lt;&gt;(postList,inList,false); System.out.println("先根遍历:"+cbtree.preOrder()); //System.out.println("非递归先根遍历:"+cbtree.preOrderTraverse()); System.out.println("中根遍历:"+cbtree.inOrder()); //System.out.println("非递归中根遍历:"+cbtree.inOrderTraverse()); System.out.println("后根遍历:"+cbtree.postOrder()); //System.out.println("非递归后根遍历:"+cbtree.postOrderTraverse()); System.out.println("树的结构如下:"); cbtree.print();&#125;/** * 根据先根和中根遍历算法构造二叉树 * @param pList 先根/后根遍历次序数组 * @param inList 中根遍历次序数组 * @param isPreOrder 是否为先根遍历次序数组,true:先根,false:后根 * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */public BinarySearchTree(T[] pList,T[] inList,boolean isPreOrder )&#123; if(pList==null||inList==null)&#123; throw new RuntimeException("preList or inList can not be null"); &#125; if(isPreOrder) &#123; //先根/中根次序构建二叉树 this.root = buildBSTreeByPreIn(pList,inList,0,pList.length-1,0,inList.length-1); &#125;else &#123; //后根/中根次序构建二叉树 this.root = buildBSTreeByPostIn(pList,inList,0,pList.length-1,0,inList.length-1); &#125;&#125; 来源：java数据结构与算法之树基本概念及二叉树（BinaryTree）的设计与实现 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【树】二叉树的设计、实现与遍历]]></title>
    <url>%2Fd9b9e86b.html</url>
    <content type="text"><![CDATA[一、树的基本概念与术语树是数据元素之间具有次层关系的非线性的结构，树是由n(n≥0)个结点组成的有限集合，n=0的树是空树，n大于0的树T由以下两个条件约定构成： 1.有一个特殊的结点，称为根结点（root），它没有前驱结点只有后继结点。2.除了根结点之外的其他结点分为m(0≤m≤n)个互不相交的集合T0,T1,T2,…,Tm-1，其中吧每个集合Ti也是一个树型结构，称之为子树(Subtree)。 （该定义源于java数据结构书） 以下是树的图形都是树的结构： 这里我们需要明白树是递归定义，这也是博主在开头强调的在递归的基础上学习树的原因，如果对于递归还不明白的，建议先看看博主的上一篇文章，毕竟在本篇内容中，递归是随处可见的。嗯，接下来我们先来认识一下树的一些常用术语，这些术语并不要求我们去死记硬背，但在看到这些术语时，我们必须有所了解或者明白其主要含义（以上图为例介绍以下的术语）。 根结点： 根结点是没有双亲的结点，一棵树中最多有一个根结点（如上图的A结点）。 孩子结点：一棵树中，一个结点的子树的根结点称为其孩子结点，如上图的A的孩子结点右B、C、D。 父母结点：相对于孩子结点而已其前驱结点即为父母结点，如上图的B、C、D 三个结点的父母结点都为A，当然E、F结点的父母结点则是B。 兄弟结点：拥有相同的父母结点的所有孩子结点叫作兄弟结点，如上图B、C、D 三个结点共同父结点为A，因此它们是兄弟结点，E、F也是兄弟结点，但是F、G就肯定不是兄弟结点了。 祖先结点：如果存在一条从根结点到结点Q的路径，而且结点P出现在这条路径上，那么P就是Q的祖先结点，而结点Q也称为P的子孙结点或者后代。如上图的E的祖先结点有A和B，而E则是A和B的子孙结点。 叶子结点：没有孩子结点的结点叫作叶子结点，如E、F、G、H等。 结点的度：指的是结点所拥有子树的棵数。如A的度为3，F的度为0，即叶子结点的度为0，而树的度则是树中各个结点度的最大值，如图（d）树的度为3（A结点） 树的层：又称结点的层，该属性反映结点处于树中的层次位置，我们约定根结点的层为1，如上图所示，A层为1，B层为2，E的层为3。 树的高度(深度)：是指树中结点的最大层数，图（d）的高度为3。 边：边表示从父母结点到孩子结点的链接线，如上图（d）中A到B间的连线则称为边。 二、二叉树的定义及其基本性质在树的数据结构中，二叉树可谓是重中之重，因此我们必须好好学习它！以下是二叉树的定义（源于java数据结构原文） 关于二叉树的定义：二叉树（Binary Tree）是n(n≥0)个结点组成的有限集合，n=0时称为空二叉树；n&gt;0的二叉树由一个根结点和两棵互不相交、分别称为左子树和右子树的子二叉树构成，二叉树也是递归定义的，在树种定义的度、层次等术语，同样适用于二叉树。 关于二叉树的定义：二叉树（Binary Tree）是n(n≥0)个结点组成的有限集合，n=0时称为空二叉树；n&gt;0的二叉树由一个根结点和两棵互不相交、分别称为左子树和右子树的子二叉树构成，二叉树也是递归定义的。在树中定义的度、层次等术语，同样适用于二叉树。 二叉树主要有以下5种基本形态： 二叉树的性质（可以用等比数列理解） 性质1：在二叉树的第i层上至多有2i-1个结点（i≥1）。层 性质2：深度为k的二叉树至多有2k-1个结点。 深度（和） 性质3：对任何一颗二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。 性质4：具有n个结点的完全二叉树的深度为[log2n]+1（[x]表示不大于x的最大整数） 性质5：如果对一颗有n个结点的完全二叉树（其深度为[log2n]+1）的结点按层序编号（从第1层到第[log2n]+1，每层从左到右），对任一结点i（1≤i≤n）有： 1.如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是节点[i/2]（向下取整） 2.如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是节点2i 3.如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1 三、二叉树抽象数据类型及其存储结构1.二叉树抽象数据类型与链表、栈、队列等抽象数据类型相似，二叉树抽象数据类型也有插入、删除、查找等操作，同时二叉树还有4种遍历算法，这个我们后面会详细分析。现在我们声明二叉树的抽象数据类型顶级接口Tree如下：T表示结点元素的类型，该类型必须实现了Comparable接口，方便比较数据。而 BinaryNode是二叉树的结点类。Tree接口声明如下： 123456789101112131415161718192021222324252627282930public interface Tree&lt;T extends Comparable&gt; &#123; //判空 boolean isEmpty(); //二叉树的结点个数 int size(); //返回二叉树的高度或者深度,即结点的最大层次 int height(); //先根次序遍历 String preOrder(); //中根次序遍历 String inOrder(); //后根次序遍历 String postOrder(); //层次遍历 String levelOrder(); //将data 插入 void insert(T data); //删除 void remove(T data); //查找最大值 T findMin(); //查找最小值 T findMax(); //根据值找到结点 BinaryNode findNode(T data); //是否包含某个值 boolean contains(T data) throws Exception; //清空 void clear();&#125; 2.二叉树存储结构关于二叉树的存储结构主要采用的是链式存储结构，至于顺序存储结构仅适用于完全二叉树或满二叉树，这个我们后面再介绍，这里我们主要还是分析二叉树的链式存储结构。二叉树的链式存储结构主要有二叉链表和三叉链表两种，下面分别说明。 二叉树的二叉链表存储结构二叉链表结构主要由一个数据域和两个分别指向左、右孩子的结点组成。其结构如下： BinaryNode(T data , BinaryNode&lt;T&gt; left , BinaryNode&lt;T&gt; right ) 从图中可以看出，采用二叉链表存储结构，每个结点只存储了到其孩子结点的单向关系，而没有存储到父结点的关系，这样的话，每次要获取父结点时将消耗较多的时间，因为需要从root根结点开始查找，花费的时间是遍历部分二叉树的时间，而且与该结点的位置有关。为了更高效的获取父结点，三叉链表存储结构孕育而生了。 二叉树的三叉链表存储结构三叉链表主要是在二叉链表的基础上多添加了一个指向父结点的域，这样我们就存储了父结点与孩子结点的双向关系，当然这样也增加了一定的空开销其结点结构如下： ThreeNode(T data ,ThreeNode&lt;T&gt; parent,ThreeNode&lt;T&gt; left,ThreeNode&lt;T&gt; right) 二叉树的静态二/三叉链表存储结构（了解即可）除了以上两种结构，其实我们也可采用一个结点数组存储所有二叉树的所有结点，这种结构称为静态二/三叉链表，在这样的结构中，每个结点存储其（父结点）左、右孩子下标，通过下标表示结点间的关系，-1表示无此结点。二叉树静态二叉链表存储结构如下： data parent left right 0 A -1 1 2 1 B 0 3 -1 2 C 0 4 -1 3 D 1 -1 5 4 E 2 -1 -1 5 G 3 -1 -1 四、二叉树的设计为了使二叉树的实现变得更有具体意义，我们将实现一种叫二叉查找树的数据结构，二叉查找树的特性是：对于树中的每个结点T（T可能是父结点）,它的左子树中所有项的值小T中的值，而它的右子树中所有项的值都大于T中的值。这意味着该树所有的元素可以用某种规则进行排序(取决于Comparable接口的实现)。二叉查找树使用二叉链表存储结构实现。 二叉树结点BinaryNode＜T＞声明如下： 1234567891011121314151617181920212223242526272829/** * Created by zejian on 2016/12/14. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] * 二叉树结点 */public class BinaryNode&lt;T extends Comparable&gt; implements Serializable&#123; private static final long serialVersionUID = -6477238039299912313L; public BinaryNode&lt;T&gt; left;//左结点 public BinaryNode&lt;T&gt; right;//右结点 public T data; public BinaryNode(T data,BinaryNode left,BinaryNode right)&#123; this.data=data; this.left=left; this.right=right; &#125; public BinaryNode(T data)&#123; this(data,null,null); &#125; //判断是否为叶子结点 public boolean isLeaf()&#123; return this.left==null&amp;&amp;this.right==null; &#125;&#125; 二叉查找树BinarySearchTree类架构定义如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Created by zejian on 2016/12/19. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */public class BinarySearchTree&lt;T extends Comparable&gt; implements Tree&lt;T&gt; &#123; //根结点 protected BinaryNode&lt;T&gt; root; public BinarySearchTree()&#123; root =null; &#125; @Override public boolean isEmpty() &#123; return false; &#125; @Override public int size() &#123; return 0; &#125; @Override public int height() &#123; return 0; &#125; @Override public String preOrder() &#123; return null; &#125; @Override public String inOrder() &#123; return null; &#125; @Override public String postOrder() &#123; return null; &#125; @Override public String levelOrder() &#123; return null; &#125; @Override public void insert(T data) &#123; &#125; @Override public void remove(T data) &#123; &#125; @Override public T findMin() &#123; return null; &#125; @Override public T findMax() &#123; return null; &#125; @Override public BinaryNode findNode(T data) &#123; return null; &#125; @Override public boolean contains(T data) throws Exception &#123; return false; &#125; @Override public void clear() &#123; &#125;&#125; 五、二叉查找树基本操作的实现1.插入算法的实现（递归）事实上对于二叉查找树的插入操作的设计是比较简单，我们只要利用二叉查找树的特性（即对每个父结点，它的左子树中所有项的值小T中的值，而它的右子树中所有项的值都大于T中的值），找到对应的插入位置即可。假如现在我们要插入data=4的结点，那么可以这样操作：沿着树查找（比较结点的数据与data的大小从而决定往左/右子树继续前行），如果找到data（4）,则什么也不做，否则将data插入到遍历的路径上的最后一个点。 2.删除算法的实现（递归与非递归）对于二叉树来说，删除是一种比较麻烦的操作，因为涉及到了多种情况（设要删除的结点为q，其父母结点为p）： 如果要删除的结点q恰好是叶子结点，那么它可以立即被删除 如果要删除的结点q拥有一个孩子结点，则应该调整要被删除的父结点(p.left 或 p.right)指向被删除结点的孩子结点（q.left 或 q.right） 如果要删除的结点q拥有两个孩子结点，则删除策略是用q的右子树的最小的数据替代要被删除结点的数据，并递归删除用于替换的结点(此时该结点已为空)，此时二叉查找树的结构并不会被打乱，其特性仍旧生效。采用这样策略的主要原因是右子树的最小结点的数据替换要被删除的结点后可以满足维持二叉查找树的结构和特性，又因为右子树最小结点不可能有左孩子，删除起来也相对简单些。 3.最大和最小值查找算法的实现（递归）二叉查找树中的findMin和findMax方法分别返回的是树种的最小值和最大值，对于findMin()，则需要从根结点开始并且只要有左孩子就向左进行即可，其终止点即为最小值的元素；而对于findMax()，也需要从根结点开始并且只要有右孩子就向右进行即可，终止点即为值最大的元素。同样的我们使用递归实现它们。 4.深度和大小计算的实现（递归）根据前面的术语，可知树的深度即为最大层的结点所在层次，而大小就是树的结点数，关于深度，我们只需要从根结点开始寻找，然后计算出左子树的深度和右子树的深度，接着比较左子树与右子树的深度，最后返回深度大的即可。 接着在看看求解二叉树大小(size)的算法该如何实现，实际上，size的求解跟上篇文章分析递归时，汉诺塔问题求解过程十分相似（其实不止是大小求解过程，二叉查找树的所有使用递归的操作都是这样的思想）。 六、二叉查找树的遍历算法通过前面分析，我们已熟悉了二叉树的一些主要操作方法，那么现在接着来了解二叉查找树的遍历算法，二叉树的遍历规则主要有四种，深度遍历：先根次序遍历（前序遍历），中根次序遍历（中序遍历），后根次序遍历（后序遍历）以及广度遍历：层次遍历。 因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。 四种主要的遍历思想为： 前序遍历：根结点 —&gt; 左子树 —&gt; 右子树 中序遍历：左子树—&gt; 根结点 —&gt; 右子树 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点 层次遍历：只需按层次遍历即可 二叉树节点： 123456789101112131415161718public class BinaryTree &#123; private Node root; //内部节点类 private class Node &#123; private int value; private Node left; private Node right; public Node(int value) &#123; this.left = null; this.right = null; this.value = value; &#125; &#125; public BinaryTree() &#123; root = null; &#125;&#125; 二叉搜索树的构建 1234567891011121314151617181920212223242526272829303132333435//递归创建二叉搜索树public void buildTree(Node node, int value) &#123; if (root == null) &#123; root = new Node(value); &#125; else &#123; if (value &lt; node.value) &#123; if (node.left == null) &#123; node.left = new Node(value); &#125; else &#123; buildTree(node.left, value); &#125; &#125; else &#123; if (node.right == null) &#123; node.right = new Node(value); &#125; else &#123; buildTree(node.right, value); &#125; &#125; &#125;&#125;/** * 20 * / \ * 4 45 * / \ / \ * 3 12 21 111 */public static void main(String[] args) &#123; int[] a = &#123; 20, 4, 3, 12, 45, 21, 111 &#125;; BinaryTree bTree = new BinaryTree(); for (int i = 0; i &lt; a.length; i++) &#123; bTree.buildTree(bTree.root, a[i]); &#125;&#125; 1.前序遍历（根左右）先根次序遍历算法，其访问规则是先遍历根结点，再遍历左子树，最后遍历右子树。如下图先根遍历的次序为ABEFC 从图可知，先根遍历每次总是先访问根结点，再访问左子树，最后访问右子树。而对于一个复杂的树，我们可以先将其简化为三个结点的树（两个结点或者一个结点则空白填补，最后去掉即可），然后解出该子树的顺序，再求解其上层的子树。 如上图的步骤(1)(2)的过程，我们可先求出以B为根的三个结点的子树，先根遍历次序为BEF，然后再求出以A为根结点的树，然后将已解出的(2)作为左子树整体插入到A(BEF)C的序列中即可，这样整棵树的遍历顺序求出来了。事实上这里我们又再次运用递归思维(复杂化简单求解问题)。 递归算法实现前序遍历 12345678//前序遍历public void preOrder(Node node) &#123; if (node != null) &#123; System.out.print(node.data+" "); preOrder(node.left); preOrder(node.right); &#125;&#125; 根据前序遍历的顺序，优先访问根结点，然后再访问左子树和右子树。所以，对于任意结点node，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，再访问过左孩子之后，需要反过来访问其右孩子，所以，需要栈这种数据结构的支持。 对于任意一个结点node，具体步骤如下： （1）访问之，并把结点node入栈，当前结点置为左孩子 （2）判断结点node是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复（1）步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的） 非递归算法实现前序遍历 1234567891011121314151617181920212223//非递归先序遍历public static void preOrderTraversal(Node root) &#123; if(root == null)&#123; return; &#125; //用来暂存节点的栈 ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); //新建一个游标节点为根节点 Node node = root; //结束的条件：左右子树都为空，并且栈也为空 while(node!=null || !stack.isEmpty())&#123; //若当前考查节点非空，则输出该节点的值。由考查顺序得知，需要一直往左走 if(node!=null)&#123; System.out.print(node.value+" "); stack.push(node);//为了之后能找到该节点的右子树，暂存该节点 node = node.left; &#125;else&#123;//node == null &amp;&amp; !stack.isEmpty() // 左子树为空，则开始考虑右子树。如果栈已空，就不需要再考虑。 node = stack.pop(); node = node.right; &#125; &#125;&#125; 或者123456789101112131415161718192021public static void preOrderTraversal2(Node root) &#123; if(root == null)&#123; return; &#125; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); Node node = root; while(node!=null || !stack.isEmpty())&#123; while(node!=null) System.out.print(node.value+" "); stack.push(node); node = node.left; &#125; //一直到左子树为空，则开始考虑右子树 //如果栈已空，就不需要再考虑 //弹出栈顶元素，将游标等于该节点的右子树 if(!stack.isEmpty())&#123; node = stack.pop(); node = node.right; &#125; &#125;&#125; 图的原理跟先根次序的的原理是一样的，唯一不同的是根结点的遍历顺序罢了。 2.中序遍历（左根右）遍历思路：左子树 —&gt; 根结点 —&gt; 右子树 递归遍历 12345678//中序遍历public void inOrder(Node node) &#123; if (node != null) &#123; inOrder(node.left); System.out.print(node.value+" "); inOrder(node.right); &#125;&#125; 非递归遍历 1234567891011121314151617181920//非递归中序遍历public static void inOrderTraversal(Node root) &#123; if(root == null)&#123; return; &#125; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); Node node = root; //结束的条件：左右子树都为空，并且栈也为空 while(node!=null || !stack.isEmpty())&#123; if(node!=null)&#123;//由考查顺序得知，需要一直往左走 stack.push(node);//为了之后能找到该节点的右子树，暂存该节点 node = node.left; &#125;else&#123;//node == null &amp;&amp; !stack.isEmpty() node = stack.pop(); //左子树为空，则打印 System.out.print(node.value+" "); node = node.right; &#125; &#125;&#125; 3.后序遍历（左右根）遍历思路：左子树 —&gt; 右子树 —&gt; 根结点 递归遍历 12345678//后序遍历public void postOrder(Node node) &#123; if (node != null) &#123; postOrder(node.left); postOrder(node.right); System.out.print(node.value+" "); &#125;&#125; 非递归遍历 后序非递归遍历和先序、中序非递归遍历不太一样。 后序遍历在决定是否可以输出当前节点的值的时候，需要考虑其左右子树是否都已经遍历完成。 所以需要设置一个lastVisit游标。若lastVisit等于当前考查节点的右子树，表示该节点的左右子树都已经遍历完成，则可以输出当前节点。并把lastVisit节点设置成当前节点，将当前游标节点node设置为空，下一轮就可以访问栈顶元素。 否则，需要接着考虑右子树，node = node.right。 12345678910111213141516171819202122232425262728//非递归后序遍历public static void postOrderTraversal(Node root) &#123; if(root == null)&#123; return; &#125; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); Node node = root; Node lastVisit = root; //结束的条件：左右子树都为空，并且栈也为空 while(node != null || !stack.isEmpty())&#123; if(node != null)&#123; stack.push(node); node = node.left; &#125;else&#123; //node == null &amp;&amp; !stack.isEmpty() node = stack.peek();//查看当前栈顶元素 //1.左右子树都为空；2.右子树已经被访问。符合这两种情况则可以打印节点 if(node.right == null || lastVisit == node.right)&#123; System.out.print(node.value+" "); stack.pop(); lastVisit = node; node = null; &#125;else&#123; //否则，继续遍历右子树 node = node.right; &#125; &#125; &#125;&#125; 4.层次遍历二叉查找树的层次遍历特性就是兄弟结点优先访问，两个兄弟结点的访问顺序是先左后右的。同样它们的后代结点的访问次序也是先左后右，左兄弟的所有孩子结点一定优先右兄弟的孩子访问。对于二叉查找树的层次遍历算法，我们需要明确如何解决一下的存在的问题（假设p从根结点开始访问）： p点如何到达其兄弟结点? B-&gt;C p点如何到达它同层下一个结点(非兄弟结点)？D-&gt;E p点如何在访问完当前层的最后一个结点时，进入下一层的第一个结点？C-&gt;D 很显然，我们现在遇到的问题跟前面非递归算法遍历的问题有些类似，也就是二叉链表的本身根本无法满足以上任意一个问题。因为从B到C，从D到E，从C到D根本没有桥梁，此时肯定得借助第3方容器来满足需求。那么这个容器该如何选呢？该容器必须告诉我们下一个访问结点是谁？层次遍历的规则是兄弟优先，从左往右。因此，在访问时，必须先将当前正在访问的结点P的左右孩子依次放入容器，如P=C时，E、H必须已在栈中，而且先进入必须先访问。即先进E再进H，然后先访问E再访问H，显然该容器必须满足“先进先出”的原则，那也就是队列了。 层次遍历算法描述如下：p点从根结点开始访问，设一个空队列，当前p结点不为空时，重复以下操作：① 访问p结点，将p结点的左右孩子依次入队。② 使p指向一个出队结点，重复①的操作，直到队列为空。 其过程如下图所示： 层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下： 12345678910111213141516171819202122//层次遍历public static void levelOrder(Node root)&#123; if(root == null)&#123; return; &#125; //存放需要遍历的结点,左结点一定优先右节点遍历 ArrayDeque&lt;Node&gt; queue = new ArrayDeque&lt;Node&gt;(); Node node = root; while(node != null)&#123; System.out.print(node.value+" "); //先按层次遍历结点,左结点一定在右结点之前访问 if(node.left!=null)&#123; //左孩子结点入队 queue.offer(node.left); &#125; if(node.right!=null)&#123; //右孩子结点入队 queue.offer(node.right); &#125; node = queue.poll(); &#125;&#125; 来源：java数据结构与算法之树基本概念及二叉树（BinaryTree）的设计与实现 参考： 1.二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先） 2.二叉树遍历(先序、中序、后序) （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【栈】栈的设计与实现]]></title>
    <url>%2F1126d207.html</url>
    <content type="text"><![CDATA[一、栈的抽象数据类型栈是一种用于存储数据的简单数据结构，有点类似链表或者顺序表（统称线性表），栈与线性表的最大区别是数据的存取的操作，我们可以这样认为栈(Stack)是一种特殊的线性表，其插入和删除操作只允许在线性表的一端进行，一般而言，把允许操作的一端称为栈顶(Top)，不可操作的一端称为栈底(Bottom)，同时把插入元素的操作称为入栈(Push),删除元素的操作称为出栈(Pop)。若栈中没有任何元素，则称为空栈，栈的结构如下图： 由图我们可看成栈只能从栈顶存取元素，同时先进入的元素反而是后出，而栈顶永远指向栈内最顶部的元素。到此可以给出栈的正式定义：栈(Stack)是一种有序特殊的线性表，只能在表的一端(称为栈顶，top，总是指向栈顶元素)执行插入和删除操作，最后插入的元素将第一个被删除，因此栈也称为后进先出(Last In First Out,LIFO)或先进后出(First In Last Out FILO)的线性表。栈的基本操作：创建栈，判空，入栈，出栈，获取栈顶元素等，注意栈不支持对指定位置进行删除，插入，其接口Stack声明如下： 12345678910public interface IStack&lt;T&gt; &#123; //栈是否为空 boolean isEmpty(); //data元素入栈 void push(T data); //返回栈顶元素,未出栈 T peek(); //出栈,返回栈顶元素,同时从栈中移除该元素 T pop();&#125; 二、顺序栈的设计与实现顺序栈，顾名思义就是采用顺序表实现的的栈，顺序栈的内部以顺序表为基础，实现对元素的存取操作。当然我们还可以采用内部数组实现顺序栈，在这里我们使用内部数组来实现栈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class SeqStack&lt;T&gt; implements IStack&lt;T&gt;,Serializable &#123; private static final long serialVersionUID = 2835698994283027419L; //栈顶指针,-1代表空栈 private int top=-1; //容量大小默认为10 private int capacity=10; //存放元素的数组 private T[] array; private int size; public SeqStack(int capacity)&#123; array = (T[]) new Object[capacity]; &#125; public SeqStack()&#123; array= (T[]) new Object[this.capacity]; &#125; @Override public boolean isEmpty() &#123; return this.top==-1; &#125; //添加元素,从栈顶(数组尾部)插入，容量不足时，需要扩容 @Override public void push(T data) &#123; //判断容量是否充足 if(array.length==size) ensureCapacity(size*2+1);//扩容 //从栈顶添加元素 array[++top]=data; &#125; //获取栈顶元素的值,不删除 @Override public T peek() &#123; if(isEmpty()) new EmptyStackException(); return array[top]; &#125; @Override public T pop() &#123; if(isEmpty()) new EmptyStackException(); size--; return array[top--]; &#125; //扩容的方法 public void ensureCapacity(int capacity) &#123; //如果需要拓展的容量比现在数组的容量还小,则无需扩容 if (capacity&lt;size) return; T[] old = array; array = (T[]) new Object[capacity]; //复制元素 for (int i=0; i&lt;size ; i++) array[i]=old[i]; &#125;&#125; 三、链式栈的设计与实现所谓的链式栈（Linked Stack），就是采用链式存储结构的栈，由于我们操作的是栈顶一端，因此这里采用单链表（不带头结点）作为基础，直接实现栈的添加，获取，删除等主要操作即可。其操作过程如下图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class LinkedStack&lt;T&gt; implements IStack&lt;T&gt;,Serializable &#123; private static final long serialVersionUID = -7003963989918008372L; private Node&lt;T&gt; top; private int size; public LinkedStack()&#123; this.top=new Node&lt;&gt;(); &#125; public int size()&#123; return size; &#125; @Override public boolean isEmpty() &#123; return top==null || top.data==null; &#125; @Override public void push(T data) &#123; if (data==null)&#123; throw new StackException("data can not be null"); &#125; if(this.top==null)&#123;//调用pop()后，如果栈为空，则top等于null this.top=new Node&lt;&gt;(data); &#125;else if(this.top.data==null)&#123; this.top.data=data; &#125;else &#123; Node&lt;T&gt; p=new Node&lt;&gt;(data,this.top); top=p;//更新栈顶 &#125; size++; &#125; @Override public T peek() throws EmptyStackException &#123; if(isEmpty())&#123; throw new EmptyStackException("Stack empty"); &#125; return top.data; &#125; @Override public T pop() &#123; if(isEmpty())&#123; throw new EmptyStackException("Stack empty"); &#125; T data=top.data; top=top.next; size--; return data; &#125;&#125;/** * Created by zejian on 2016/10/21. * 单向链表节点 */class Node&lt;T&gt; &#123; public T data;//数据域 public Node&lt;T&gt; next;//地址域 public Node()&#123; &#125; public Node(T data)&#123; this.data=data; &#125; public Node(T data,Node&lt;T&gt; next)&#123; this.data=data; this.next=next; &#125;&#125; 四、栈的应用栈是一种很重要的数据结构，在计算机中有着很广泛的应用，如下一些操作都应用到了栈。 符号匹配 中缀表达式转换为后缀表达式（逆波兰表达式） 计算后缀表达式 实现函数的嵌套调用 HTML和XML文件中的标签匹配 网页浏览器中已访问页面的历史记录 来源：java数据结构与算法之栈（Stack）设计与实现 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>栈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡10：将搜索二叉树转换成双向链表]]></title>
    <url>%2F17af8c71.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢。 【题目描述】 对于二叉树的结点来说，有本身的值域，有指向左孩子和右孩子的两个指针；对双向链表的结点来说，有本身的值域，有指向上一个结点和下一个结点的指针。在结构上，两种结构有相似性，现有一棵搜索二叉树，请将其转为成一个有序的双向链表。 结点定义： 12345678class NodeDoubly&#123; public int value; public NodeDoubly left; public NodeDoubly right; public NodeDoubly(int value) &#123; this.value = value; &#125;&#125; 例如： 这棵二叉搜索树转换后的双向链表从头到尾依次是 1～9。对于每一个结点来说，原来的 right 指针等价于转换后的 next 指针，原来的 left 指针等价于转换后的 last 指针，最后返回转换后的双向链表的头结点。 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N)。 【难度】 尉：★★☆☆ 解答方法一：采用队列辅助 如果用一个队列来辅助的话，还是挺容易。采用中序遍历的方法，把二叉树的结点全部放进队列，之后在逐一弹出来连接成双向链表。 代码如下 1234567891011121314151617181920212223242526272829public static NodeDoubly convertUseQueue(NodeDoubly head) &#123; if(head == null)&#123; return head; &#125; Deque&lt;NodeDoubly&gt; queue = new ArrayDeque&lt;NodeDoubly&gt;(); //将结点按照中序遍历放进队列里面 inOrderToQueue(head,queue); head = queue.poll(); NodeDoubly pre = head; pre.left = null; NodeDoubly cur = null; while(!queue.isEmpty())&#123; cur = queue.poll(); pre.right = cur; cur.left = pre; pre = cur; &#125; pre.right = null; return head;&#125;private static void inOrderToQueue(NodeDoubly head, Deque&lt;NodeDoubly&gt; queue) &#123; if(head == null)&#123; return; &#125; inOrderToQueue(head.left,queue); queue.offer(head); inOrderToQueue(head.right, queue);&#125; 这种方法的时间复杂度为 O(n), 空间复杂度也为 O(n)。 测试代码 12345678910111213141516171819202122232425public static void main(String[] args) &#123; NodeDoubly head = new NodeDoubly(6); head.left = new NodeDoubly(4); head.left.left = new NodeDoubly(2); head.left.right = new NodeDoubly(5); head.left.left.left = new NodeDoubly(1); head.left.left.right = new NodeDoubly(3); head.right = new NodeDoubly(7); head.right.right = new NodeDoubly(9); head.right.right.left = new NodeDoubly(8); NodeDoubly doubleLinkedList = convertUseQueue(head); NodeDoubly cur = doubleLinkedList; while(cur.right!=null)&#123; System.out.print(cur.value+" "); cur = cur.right; &#125; System.out.print(cur.value); System.out.println(); while(cur!=null)&#123; System.out.print(cur.value+" "); cur = cur.left; &#125;&#125; 方法2：通过递归的方式 在之前打卡的9道题中，几乎超过一半都用到了递归，如果这些题目使用的递归大家都理解了，并且能够自己独立写出代码了，那么我相信大家对递归的思想、使用已经有一定的熟练性。 我们假设函数convert的功能就是把二叉树变成双向链表，例如对于这种一棵二叉树： 经过convert转换后变成这样： 注意：转换之后，把最右边结点的right指针指向了最左边的结点的。 对于下面这样一颗二叉树： 采用convert函数分别对左右子树做处理，结果如下： 之后，再把他们连接起来 了解了基本原理之后，直接看代码吧。 12345678910111213141516171819202122232425262728293031public static NodeDoubly conver(NodeDoubly head) &#123; if (head == null) &#123; return head; &#125; //head=2时 NodeDoubly leftE = conver(head.left);//1的right -&gt; 1 NodeDoubly rightE = conver(head.right);//3的rigth -&gt; 3 NodeDoubly leftB = leftE != null ? leftE.right : null;//1 NodeDoubly rightB = rightE != null ? rightE.right : null;//3 if (leftE != null &amp;&amp; rightE != null) &#123; leftE.right = head; head.left = leftE; head.right = rightB; rightB.left = head; rightE.right = leftB; return rightE; &#125; else if (leftE != null) &#123; leftE.right = head; head.left = leftE; head.right = leftB; return head; &#125; else if (rightE != null) &#123; head.right = rightB; rightB.left = head; rightE.right = head; return rightE; &#125; else &#123; head.right = head; return head; &#125;&#125; 时间复杂度为O(n),空间复杂度为O(h)，其中h是二叉树的高度。 运行过程 测试代码 因为返回的是一个环形链表，所以不能使用上面的测试代码进行测试。我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。 我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空或者结点为 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。 123456789101112131415161718192021222324public static void main(String[] args) &#123; NodeDoubly head = new NodeDoubly(6); head.left = new NodeDoubly(4); head.left.left = new NodeDoubly(2); head.left.right = new NodeDoubly(5); head.left.left.left = new NodeDoubly(1); head.left.left.right = new NodeDoubly(3); head.right = new NodeDoubly(7); head.right.right = new NodeDoubly(9); head.right.right.left = new NodeDoubly(8); NodeDoubly doubleLinkedList = conver(head); NodeDoubly cur = doubleLinkedList; Set&lt;NodeDoubly&gt; set = new HashSet&lt;NodeDoubly&gt;(); while(cur!=null)&#123; if(set.contains(cur))&#123; break; &#125; set.add(cur); System.out.print(cur.value+" "); cur = cur.right; &#125;&#125; 原理虽然不难，但写起代码，还是有挺多细节需要注意的，所以一直强调，有时间的话，一定要自己手打一遍代码，有时你以为自己懂了，可能在写代码的时候，发现自己并没有懂，一写就出现很多bug。 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡9：将单链表的每K个结点之间逆序]]></title>
    <url>%2F6d9f1a64.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢。 【题目描述】 给定一个单链表的头结点head, 实现一个调整单链表的函数，使得每K个结点之间逆序，如果最后不够K个结点一组，则不调整最后几个结点。 例如： 链表:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null, K = 3。 调整后：3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null。其中 7，8不调整，因为不够一组。 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N)。 【难度】 尉：★★☆☆ 解答对于这道题，如果你不知道怎么逆序一个单链表，那么可以看一下我之前写的【链表问题】如何优雅着反转单链表 这道题我们可以用递归来实现，假设方法reverseKNode()的功能是将单链表的每K个结点之间逆序。reverse()方法的功能是将一个单链表逆序。 那么对于下面的这个单链表，其中 K = 3。 我们把前K个结点与后面的结点分割出来： temp指向的剩余的链表，可以说是原问题的一个子问题。我们可以调用reverseKNode()方法将temp指向的链表每K个结点之间进行逆序。再调用reverse()方法把head指向的那3个结点进行逆序，结果如下： 接着，我们只需要把这两部分给连接起来就可以了。最后的结果如下： 如果不大理解，看下代码可能就比较好理解了。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041//每k个结点为一组的逆转public static Node reverseKNodes(Node head, int k) &#123; //注意要判断head.next是否为空 if(head == null || head.next == null)&#123; return head; &#125; Node cur = head; for (int i = 1;cur != null &amp;&amp; i &lt; k; i++) &#123; cur = cur.next; &#125; //判断，没有形成一组则返回 cur == null 或者 i==k if(cur == null)&#123; return head; &#125; //next指向剩余的链表 Node next = cur.next; //注意这一步要把链表给断开，断开cur其实是断开head，否则会发生StackOverflowError错误 cur.next = null; cur = head; //逆转这k个结点 Node newHead = reverse(cur); //把之后的部分链表进行每k个结点逆转 Node newTemp = reverseKNodes(next,k); //把两部分结点连接起来 cur = newHead; while(cur.next!=null)&#123; cur = cur.next; &#125; cur.next = newTemp; return newHead;&#125;//单链表逆序public static Node reverse(Node head)&#123; if(head == null || head.next == null)&#123; return head; &#125; Node newList = reverse(head.next); head.next.next = head; head.next = null; return newList;&#125; 当然，这道题一个很简单的做法就是利用栈来辅助，每K个结点入栈就把这K个结点出栈连接成一个链表，之后剩余再在进栈….. 1234567891011121314151617181920212223242526272829303132//使用栈public static Node reverseKNodesUseStack(Node head, int k)&#123; if(head == null || head.next == null)&#123; return head; &#125; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); Node cur = head; //stack的push操作比cur指针慢一步 for (int i = 1; cur!=null&amp;&amp;i&lt;k; i++) &#123; stack.push(cur); cur=cur.next; &#125; if(cur == null)&#123; return head; &#125; stack.push(cur); Node next = cur.next; cur.next = null; Node newHead = stack.pop(); cur = newHead; while(!stack.isEmpty())&#123; cur.next = stack.pop(); cur = cur.next; &#125; //可以边push边pop处理链表，但是这样需要两个循环，时间复杂度就上去了。 Node newTemp = reverseKNodesUseStack(next,k); //把两部分结点连接起来 cur.next = newTemp; return newHead;&#125; 不过这种做法的额外空间复杂度是O(K)。 测试代码 12345678910111213141516public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,4,5,6,7,8&#125;; Node head = new Node(arr[0]); Node node = head; int i = 0; while(++i&lt;arr.length)&#123; node.next = new Node(arr[i]); node = node.next; &#125; //node = reverseKNodes(head,8); node = reverseKNodesUseStack(head,9); while(node!=null)&#123; System.out.print(node.value+" "); node = node.next; &#125;&#125; 问题拓展思考：如果这是一个环形单链表呢？该如何实现呢？来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡8：复制含有随机指针结点的链表]]></title>
    <url>%2F51689965.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢。 【题目描述】 一种特殊的链表结点类描述如下： 12345678class NodeRand&#123; public int value; public NodeRand next; public NodeRand rand; public NodeRand(int data)&#123; this.value = data; &#125;&#125; NodeRand类中的value是结点值，next指针和正常单链表中next指针的意义一样，都指向下一个结点，rand指针是NodeRand类中新增的指针，这个指针可能指向链表中的任意一个结点，也可能指向null。 给定一个由NodeRand结点类型组成的无环单链表的头结点head，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头结点。例如：链表1-&gt;2-&gt;3-&gt;null，假如1的rand指针指向3，2的rand指针指向null，3的rand指针指向1。复制后的链表应该也是这种结构，比如，1’-&gt;2’-&gt;3’-&gt;null，1’的rand指针指向3’，2’的rand指针指向null，3’的rand指针指向1’，最后返回1’。 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N)。 进阶：不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N)内完成原问题要实现的函数。 【难度】 尉：★★☆☆ 解答方法一：使用额外的存储空间 这道题的难点在于我们需要定位好随机指针，一个比较简单的解法就是把原结点与复制的结点关联起来，可以使用哈希表把他们关联起来。 首先把副结点全部创建出来，然后把原结点与对应的副结点用哈希表关联起来。关联的时候原结点作为key，副结点作为value。例如对于链表 1-&gt;2-&gt;3-&gt;null。创建副结点 1’, 2’, 3’。然后用哈希表关联起来： key value NodeRand_1 NodeRand_1’ NodeRand_2 NodeRand_2’ NodeRand_3 NodeRand_3’ 之后再把所有副结点连接成一个链表。在连接的时候，我们可以通过哈希表很容易找到对应的随机结点。 代码如下 12345678910111213141516171819202122//使用哈希表关联原结点与复制的结点//时间复杂度为 O(n), 空间复杂度也为 O(n)public static NodeRand copyListWithRand(NodeRand head)&#123; if(head == null)&#123; return head; &#125; Map&lt;NodeRand, NodeRand&gt; map = new HashMap&lt;NodeRand, NodeRand&gt;(); NodeRand cur = head; //首先创建全部副结点 while(cur != null)&#123; map.put(cur, new NodeRand(cur.value)); cur = cur.next; &#125; //把副结点串起来 cur = head; while(cur!=null)&#123; map.get(cur).next = map.get(cur.next); map.get(cur).rand = map.get(cur.rand); cur = cur.next; &#125; return map.get(head);&#125; 这种方法的时间复杂度为 O(n), 空间复杂度也为 O(n)。 方法2 其实我们也可以不需要哈希表来辅助，也就是说 ，我们是可以做到空间复杂度为 O(1)的，我们可以把复制的副结点插入到原链表中去，这样也能把原结点与副结点进行关联，进而定位到随机结点。例如，对于链表 1-&gt;2-&gt;3-&gt;null。首先生成副结点 1’, 2’, 3’。然后把副结点插入到原结点的相邻位置，即把原链表变成 1-&gt;1’-&gt;2-&gt;2’-&gt;3-&gt;3’-&gt;null。 这样我们也可以在连接副结点的时候，找到相应的随机结点。例如 1 的随机结点是 3，则 1’ 的随机结点是 3’。显然，1结点的随机结点的下一个结点就是 1’的随机结点。具体代码如下： 1234567891011121314151617181920212223242526//空间复杂度O(1)public static NodeRand copyListWithRand2(NodeRand head)&#123; if(head == null)&#123; return head; &#125; NodeRand cur = head; NodeRand next = null; //创建并插入结点 while(cur!=null)&#123; next = cur.next; NodeRand copyNode = new NodeRand(cur.value); cur.next = copyNode; copyNode.next = next; cur = next; &#125; //再把复制的结点取出来连接起来 cur = head; next = null; while(cur != null)&#123; next = cur.next.next;//使用next托管原链表的下一个结点 cur.next.next = next != null ? next.next : null;//注意空结点判断 cur.next.rand = cur.rand != null ? cur.rand.next : null; cur = next; &#125; return head.next;&#125; 采用这种方法的时候，由于随机结点有可能是空指针，随意写代码的时候要注意。 问题拓展思考：如果是有两个随机指针呢？又该如何处理呢？三个呢？ 提醒：别想太多了，保持清醒。 来源：苦逼的码农（ID:di201805） 参考：算法练习day10——190328（根据指定值划分单链表、复制含有rand指针结点的链表、两个单链表相交） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡7：将单向链表按某值划分成左边小，中间相等，右边大的形式]]></title>
    <url>%2Fc17971a9.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢。 【题目描述】 给定一个单向链表的头结点head，结点的值类型是整型，再给定一个整数privot。实现一个调整链表的函数，将链表调整为左部分都是值小于privot的结点，中间部分都是值等于privot的结点，右部分都是大于privot的结点。且对某部分内部结点的顺序不做要求。 例如:链表9-0-4-5-1，pivot=3。 调整后是1-0-4-9-5， 也可以是0-1-9-5-4 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N)。 【难度】 尉：★★☆☆ 解答方法一：可用数组，转换为荷兰国旗问题，但是需要额外空间，并且不具有稳定性。 方法二：使用三个辅助结点。 这道题在思路上还是比较简单的，但是在实现上还是有一些细节需要注意的。 本题对某部分的内部结点不做要求，一种很简单的方法就是用一个数组来存链表的结点，然后像类似于快速排序的分割函数那样，按照某个值把他们进行划分。 不过这样做的话，空间复杂度为 O(N)。我们也可以采取使用3个指针，把原链表依次划分成三个部分的链表，然后再把他们合并起来，这种做法不但空间复杂度为 O(1), 而且内部结点的顺序也是和原链表一样的。虽然思路简单，但在代码实现上也是有很多细节需要注意的，有时间的话希望大家动手打下代码。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//用三个指针处理，这道题主要是要注意串联链表时的一些细节处理public static Node listPartition(Node head,int privot)&#123; if(head == null || head.next == null)&#123; return head; &#125; Node sB = null;//小于部分的指针头，small begin Node sE = null;//小于部分的指针尾，small end Node eB = null;//等于部分的指针头，equal begin Node eE = null;//等于部分的指针尾，equal end Node bB = null;//大于部分的指针头，big begin Node bE = null;//大于部分的指针尾，big end Node next = null; //分区 while(head!=null)&#123; //使用next结点接管head后面的指针 //如果直接使用head指针，会导致结点错乱 next = head.next; head.next = null; if(head.value &lt; privot)&#123; if(sB == null)&#123; sB = head; sE = head; &#125;else&#123; //不能使用sB.next = head，因为后面循环就是就是sB指向末尾了 sE.next = head; sE = sE.next; &#125; &#125; if(head.value == privot)&#123; if(eB == null)&#123; eB = head; eE = head; &#125;else&#123; eE.next = head; eE = eE.next; &#125; &#125; if(head.value &gt; privot)&#123; if(bB == null)&#123; bB = head; bE = head; &#125;else&#123; bE.next = head; bE = bE.next; &#125; &#125; head = next; &#125; //把三部分串连起来，串联的时候细节还是挺多的， //串联的过程下面代码的精简程度是最学习的部分了 //1.小的与中的串联 if(sB != null)&#123; //这样子做更精简 sE.next = eB != null ? eB : bB; //sE.next = eB; //为下部分做判断 //eE = eE == null ? sE : eE; &#125; //2.中的和大的连接 if(eB != null)&#123; eE.next = bB; &#125; return sB != null ? sB : eB != null ? eB : bB;&#125; 注意：分区时，记得断开原链表的next，否则后面再连接时判断是否为null时就会混乱。——代码实现中辅助结点next作用就是这个。 测试代码 123456789101112131415public static void main(String[] args) &#123; int[] arr = &#123;0,99,-1,-20,50,18&#125;; Node head = new Node(arr[0]); Node node = head; int i = 0; while(++i&lt;arr.length)&#123; node.next = new Node(arr[i]); node = node.next; &#125; node = listPartition(head, 0); while(node!=null)&#123; System.out.print(node.value+" "); node = node.next; &#125;&#125; 问题拓展思考：如果给你的是一个环形链表，让你来划分，又该如何实现呢？ 来源：苦逼的码农（ID:di201805） 参考：算法练习day10——190328（根据指定值划分单链表、复制含有rand指针结点的链表、两个单链表相交） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡6：三种方法带你优雅判断回文链表]]></title>
    <url>%2F6311da84.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢。 【题目描述】 给定一个链表的头结点 head, 请判断该链表是否为回文结构。 例如： 1-&gt;2-&gt;1，返回 true. 1-&gt;2-&gt;2-&gt;1, 返回 true。 1-&gt;2-&gt;3，返回 false。 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N)。 【难度】 普通解法：士：★☆☆☆ 进阶解法：尉：★★☆☆ 解答方法1 我们可以利用栈来做辅助，把链表的结点全部入栈，在一个一个出栈与链表进行对比，例如对于链表 1-&gt;2-&gt;3-&gt;2-&gt;2，入栈后如图: 然后再逐一出栈与链表元素对比。 这种解法比较简单，时间复杂度为 O(n), 空间复杂度为 O(n)。 代码如下 1234567891011121314151617181920212223//全部入栈public static boolean palindromeList1(Node head)&#123; if(head == null || head.next == null)&#123; return true; &#125; Node node = head; //使用ArrayDeque作为栈 //Stack因为集成自Vector，所以Stack类是同步的，效率不高。 //官方一般建议这样使用ArrayDeque代替Stack ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); while(node != null)&#123; stack.push(node); node = node.next; &#125; while(!stack.isEmpty())&#123; Node popNode = stack.pop(); if(popNode.value != head.value)&#123; return false; &#125; head = head.next; &#125; return true;&#125; 方法二 真的需要全部入栈吗？其实我们也可以让链表的后半部分入栈就可以了，然后把栈中的元素与链表的前半部分对比，例如 1-&gt;2-&gt;3-&gt;2-&gt;2 后半部分入栈后如图： 然后逐个出栈，与链表的前半部分(1-&gt;2)对比。这样做的话空间复杂度会减少一半。 代码如下： 1234567891011121314151617181920212223242526272829//后半部分入栈，时间复杂度O(n)public static boolean palindromeList2(Node head)&#123; if(head == null || head.next == null)&#123; return true; &#125; Node fast = head;//快指针 Node slow = head;//慢指针 //slow最终指向中间结点 while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; slow = slow.next; fast = fast.next.next; &#125; //后半部分入栈 slow = slow.next; ArrayDeque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;(); while(slow!=null)&#123; stack.push(slow); slow = slow.next; &#125; //进行判断 while(!stack.isEmpty())&#123; Node n = stack.pop(); if(n.value != head.value)&#123; return false; &#125; head = head.next; &#125; return true;&#125; 方法三：空间复杂度为 O(1)。 上道题我们有作过链表的反转的，没看过的可以看一下勒：【链表】打卡2：如何优雅着反转单链表，我们可以把链表的后半部分进行反转，然后再用后半部分与前半部分进行比较就可以了。这种做法额外空间复杂度只需要 O(1), 时间复杂度为 O(n)。 代码如下: 12345678910111213141516171819202122232425262728293031323334//反转后半部分链表public static boolean palindromeList3(Node head)&#123; if(head == null || head.next == null)&#123; return true; &#125; Node slow = head;//慢指针 Node fast = head;//快指针 //slow最终指向中间结点 while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; slow = slow.next; fast = fast.next.next; &#125; //反转后半部分 Node reverseNode = reverseNode(slow.next); //比较 while(reverseNode.next != null &amp;&amp; head.next != null)&#123; if(reverseNode.value != head.value)&#123; return false; &#125; reverseNode = reverseNode.next; head = head.next; &#125; return true;&#125;private static Node reverseNode(Node head)&#123; if(head == null || head.next == null)&#123; return head; &#125; Node newList = reverseNode(head.next); head.next.next = head; head.next = null; return newList;&#125; 测试代码 12345678910111213public static void main(String[] args) &#123; int[] arr = &#123;1,2,3,3,2,1&#125;; Node head = new Node(arr[0]); Node node = head; int i = 0; while(++i&lt;arr.length)&#123; node.next = new Node(arr[i]); node = node.next; &#125; System.out.println(palindromeList1(head)); System.out.println(palindromeList2(head)); System.out.println(palindromeList3(head));&#125; 问题拓展思考：如果给你的是一个环形链表，并且指定了头结点，那么该如何判断是否为回文链表呢？ 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用的算法技巧总结]]></title>
    <url>%2F53b29690.html</url>
    <content type="text"><![CDATA[1.巧用数组下标数组的下标是一个隐含的很有用的数组，特别是在统计一些数字，或者判断一些整型数是否出现过的时候。例如，给你一串字母，让你判断这些字母出现的次数时，我们就可以把这些字母作为下标，在遍历的时候，如果字母a遍历到，则arr[a]就可以加1了，即 arr[a]++; 通过这种巧用下标的方法，我们不需要逐个字母去判断。 我再举个例子： 问题：给你n个无序的int整型数组arr，并且这些整数的取值范围都在0-20之间，要你在 O(n) 的时间复杂度中把这 n 个数按照从小到大的顺序打印出来。 对于这道题，如果你是先把这 n 个数先排序，再打印，是不可能O(n)的时间打印出来的。但是数值范围在 0-20。我们就可以巧用数组下标了。把对应的数值作为数组下标，如果这个数出现过，则对应的数组加1。 代码如下： 12345678910111213public void f(int arr[]) &#123; int[] temp = new int[21]; for (int i = 0; i &lt; arr.length; i++) &#123; temp[arr[i]]++; &#125; //顺序打印 for (int i = 0; i &lt; 21; i++) &#123; for (int j = 0; j &lt; temp[i]; j++) &#123; System.out.println(i); &#125; &#125; &#125; 提醒：可以左右滑动 利用数组下标的应用还有很多，大家以后在遇到某些题的时候可以考虑是否可以巧用数组下标来优化。 2.巧用取余有时候我们在遍历数组的时候，会进行越界判断，如果下标差不多要越界了，我们就把它置为0重新遍历。特别是在一些环形的数组中，例如用数组实现的队列。往往会写出这样的代码： 12345678910for (int i = 0; i &lt; N; i++) &#123; if (pos &lt; N) &#123; //没有越界 // 使用数组arr[pos] else &#123; pos = 0;//置为0再使用数组 //使用arr[pos] &#125; pos++; &#125; 实际上我们可以通过取余的方法来简化代码 1234for (int i = 0; i &lt; N; i++) &#123; //使用数组arr[pos] (我们假设刚开始的时候pos &lt; N) pos = (pos + 1) % N;&#125; 3.巧用双指针对于双指针，在做关于单链表的题是特别有用，比如“判断单链表是否有环”、“如何一次遍历就找到链表中间位置节点”、“单链表中倒数第 k 个节点”等问题。对于这种问题，我们就可以使用双指针了，会方便很多。我顺便说下这三个问题怎么用双指针解决吧。 例如对于第一个问题 我们就可以设置一个慢指针和一个快指针来遍历这个链表。慢指针一次移动一个节点，而快指针一次移动两个节点，如果该链表没有环，则快指针会先遍历完这个表，如果有环，则快指针会在第二次遍历时和慢指针相遇。 对于第二个问题 一样是设置一个快指针和慢指针。慢的一次移动一个节点，而快的两个。在遍历链表的时候，当快指针遍历完成时，慢指针刚好达到中点。 对于第三个问题 设置两个指针，其中一个指针先移动k个节点。之后两个指针以相同速度移动。当那个先移动的指针遍历完成的时候，第二个指针正好处于倒数第k个节点。 你看，采用双指针方便多了吧。所以以后在处理与链表相关的一些问题的时候，可以考虑双指针哦。 4.巧用移位运算有时候我们在进行除数或乘数运算的时候，例如n / 2，n / 4, n / 8这些运算的时候，我们就可以用移位的方法来运算了，这样会快很多。 例如: n / 2 等价于 n &gt;&gt; 1 n / 4 等价于 n &gt;&gt; 2 n / 8 等价于 n &gt;&gt; 3。 这样通过移位的运算在执行速度上是会比较快的，也可以显的你很厉害的样子，哈哈。 还有一些 &amp;(与)、|(或)的运算，也可以加快运算的速度。例如判断一个数是否是奇数，你可能会这样做 123if(n % 2 == 1)&#123; dosomething();&#125; 不过我们用与或运算的话会快很多。例如判断是否是奇数，我们就可以把n和1相与了，如果结果为1，则是奇数，否则就不会。即 123if(n &amp; 1 == 1)&#123; dosomething();) 具体的一些运算技巧，还得需要你们多在实践中尝试着去使用，这样用久后就会比较熟练了。 5.设置哨兵位在链表的相关问题中，我们经常会设置一个头指针，而且这个头指针是不存任何有效数据的，只是为了操作方便，这个头指针我们就可以称之为哨兵位了。 例如我们要删除头第一个节点是时候，如果没有设置一个哨兵位，那么在操作上，它会与删除第二个节点的操作有所不同。但是我们设置了哨兵，那么删除第一个节点和删除第二个节点那么在操作上就一样了，不用做额外的判断。当然，插入节点的时候也一样。 有时候我们在操作数组的时候，也是可以设置一个哨兵的，把arr[0]作为哨兵。例如，要判断两个相邻的元素是否相等时，设置了哨兵就不怕越界等问题了，可以直接arr[i] == arr[i-1]?了。不用怕i = 0时出现越界。 当然我这只是举一个例子，具体的应用还有很多，例如插入排序，环形链表等。 6.与递归有关的一些优化（1）对于可以递归的问题考虑状态保存 当我们使用递归来解决一个问题的时候，容易产生重复去算同一个子问题，这个时候我们要考虑状态保存以防止重复计算。例如我随便举一个之前举过的问题 问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？ 这个问题用递归很好解决。假设 f(n) 表示n级台阶的总跳数法，则有 f(n) = f(n-1) + f(n - 2)。 递归的结束条件是当0 &lt;= n &lt;= 2时, f(n) = n。因此我们可以很容易写出递归的代码 1234567 public int f(int n) &#123; if (n &lt;= 2) &#123; return n; &#125; else &#123; return f(n - 1) + f(n - 2); &#125;&#125; 不过对于可以使用递归解决的问题，我们一定要考虑是否有很多重复计算。显然对于 f(n) = f(n-1) + f(n-2) 的递归，是有很多重复计算的。如 就有很多重复计算了。这个时候我们要考虑状态保存。例如用hashMap来进行保存，当然用一个数组也是可以的，这个时候就像我们上面说的巧用数组下标了。可以当arr[n] = 0时，表示n还没计算过，当arr[n] != 0时，表示f(n)已经计算过，这时就可以把计算过的值直接返回回去了。因此我们考虑用状态保存的做法代码如下： 123456789101112131415//数组的大小根据具体情况来，由于int数组元素的的默认值是0 //因此我们不用初始化 int[] arr = new int[1000]; public int f(int n) &#123; if (n &lt;= 2) &#123; return n; &#125; else &#123; if (arr[n] != 0) &#123; return arr[n];//已经计算过，直接返回 &#125; else &#123; arr[n] = f(n-1) + f(n-2); return arr[n]; &#125; &#125; &#125; 这样，可以极大着提高算法的效率。也有人把这种状态保存称之为备忘录法。 (2).考虑自底向上 对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。 不过，有时候当n比较大的时候，例如当 n = 10000时，那么必须要往下递归10000层直到 n &lt;=2 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。 对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道 f(1) = 1; f(2) = 2; 那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来做。 代码如下： 123456789101112131415public int f(int n) &#123; if(n &lt;= 2) return n; int f1 = 1; int f2 = 2; int sum = 0; for (int i = 3; i &lt;= n; i++) &#123; sum = f1 + f2; f1 = f2; f2 = sum; &#125; return sum; &#125; 我们也把这种自底向上的做法称之为递推。 总结一下 当你在使用递归解决问题的时候，要考虑以下两个问题 (1). 是否有状态重复计算的，可不可以使用备忘录法来优化。 (2). 是否可以采取递推的方法来自底向上做，减少一味递归的开销。 7.找出两个没有重复的数对于第一题【找出没有重复的数】 给你一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。 有人问如果有2个数出现了一次，其他数都出现了一次，那还能用位运算来找出这两个数吗？ 答是必须的，假如这两个出现一次的 数 分别为 A, B，则所有 数 异或后的结果为 A^B，这时我们遇到的问题是无法确定 A，B的值。 由于 A 和 B 是不一样的值，所以 A^B 的结果不为 0，也就是说，这个异或值的二进制中某一位为1。显然，A 和 B 中有且仅有一个数的相同位上也为 1。 这个时候，我们可以把所有 数 分为两类，一类在这个位上为 1，另一类为 0，那么对于这两类，一类会含有 A，另一类会含有 B。于是，我们可以分别计算这两类 数 的异或值，即可得到 A 和 B 的值。 8.找出不大于N的最大的2的幂指数传统的做法就是让 1 不断着乘以 2，代码如下： 123456789int findN(int N)&#123; int sum = 1; while(true)&#123; if(sum * 2 &gt; N)&#123; return sum; &#125; sum = sum * 2; &#125;&#125; 这样做的话，时间复杂度是 O(logn)，那如果改成位运算，该怎么做呢？我刚才说了，如果要弄成位运算的方式，很多时候我们把某个数拆成二进制，然后看看有哪些发现。这里我举个例子吧。 例如 N = 19，那么转换成二进制就是 00010011（这里为了方便，我采用8位的二进制来表示）。那么我们要找的数就是，把二进制中最左边的 1 保留，后面的 1 全部变为 0。即我们的目标数是 00010000。那么如何获得这个数呢？相应解法如下： 1、找到最左边的 1，然后把它右边的所有 0 变成 1 2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。 3、把 得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 &gt;&gt; 1 = 00010000。 那么问题来了，第一步中把最左边 1 中后面的 0 转化为 1 该怎么弄呢？我先给出代码再解释吧。下面这段代码就可以把最左边 1 中后面的 0 全部转化为 1， 123n |= n &gt;&gt; 1;n |= n &gt;&gt; 2;n |= n &gt;&gt; 4; 就是通过把 n 右移并且做或运算即可得到。我解释下吧，我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去…. 最终的代码如下 12345678int findN(int n)&#123; n |= n &gt;&gt; 1; n |= n &gt;&gt; 2; n |= n &gt;&gt; 4; n |= n &gt;&gt; 8; n |= n &gt;&gt; 16;// 整型一般是 32 位，上面我是假设 8 位。 return (n + 1) &gt;&gt; 1;&#125; 这种做法的时间复杂度近似 O(1)，重点是，高逼格。 9.判断一个正整数 N 是否为 2 的幂次方。如果一个数是 2 的幂次方，意味着 N 的二进制表示中，只有一个位 是1，其他都是0。我举个例子，例如 2^0 = 0…..0001 2^1 = 0…..0010 2^2 = 0….0100 2^3 = 0..01000 ….. 所以呢，我们只需要判断N中的二进制表示法中是否只存在一个 1 就可以了。不过我们可以用上面第七题中的做法找出不大于N的最大的2的幂指数 M，然后判断找处理的那个数M是否和N相等。这种做法，比一个一个着去统计N的二进制位中是否只有一个1快多了。 所以呢，可以写出如下的代码 12345678boolean judge(int n)&#123; n |= n &gt;&gt; 1; n |= n &gt;&gt; 2; n |= n &gt;&gt; 4; n |= n &gt;&gt; 8; n |= n &gt;&gt; 16;// 我这里假设是32位的正整数 return (n + 1) &gt;&gt; 1 == n &#125; 然后，还有更加牛逼的解法，代码如下： 123boolean judege(int n)&#123; return n &amp; (n - 1) == 0;// &#125; 卧槽，这也太牛逼了吧，一行代码解决，一行代码解决。这里我解释一下， n &amp; (n - 1) 这个运算，会把 n 的二进制位表示法中最左边的 1 变成 0。所以呢，经过这个运算之后，如果 n &amp; ( n - 1) 的结果是 0,说明 n 中只有一个 1。牛逼啊！ 来源：苦逼的码农（ID:di201805） 参考：算法数据结构中有哪些奇技淫巧？ （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡5：环形单链表约瑟夫问题]]></title>
    <url>%2Fb7f25d2f.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢。 【题目描述】 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报1，报数到3的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整个自杀过程。 一般形式： N个人围成一个圈，编号为1到N，从1号开始报数，报数为M的人出局；其他人继续围成圈，从出局人的下一个开始重新报数，报到M的人又出局。直到剩下最后一个人。 有时也称为约瑟夫斯置换，是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。又称“丢手绢问题”。 【要求】 输入：一个环形单向链表的头结点 head 和报数 m. 返回：最后生存下来的结点，且这个结点自己组成环形单向链表，其他结点都删除掉。 【难度】 士：★☆☆☆ 解答方法1：时间复杂度为 O( n * m) 这道题如果不考虑时间复杂度的话还是挺简单的，就遍历环形链表，每遍历 m 个结点就删除一个结点，直到链表只剩下一个结点就可以了。 代码如下 1234567891011121314151617181920//时间复杂度为O(n*m)的解决方法public static Node josephusKill(Node head, int m) &#123; if(head == null || m &lt; 1) return head; Node last = head; //定位到最后一个结点 while (head.next != last) &#123; head = head.next; &#125; int count = 0; while (head.next != head) &#123; if (++count == m) &#123; head.next = head.next.next; count = 0; &#125; else &#123; head = head.next; &#125; &#125; return head;&#125; 这个方法的时间复杂度为 O(n * m)。下面用时间复杂度为方法解决。 编号从0开始 通过数学方式可以提高算法的效率。可以将问题描述改为：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 注意这里的方法没有将每次报数人的编号计算出来，而是仅仅求出了胜利者的编号，下面算法的复杂度为O(n)。 当第一个人出列后（这个人的编号一定是（m - 1）% n，剩下的n - 1 个人重新构成了一个新的约瑟夫环（这个环以k = m % n开始报数）： k，k+1，k+2，……，n-2，n-1，0，1，……，k-2。 将这n-1个人依次重新编号为0，1，2，……，n-1： k —&gt; 0， k+1 —&gt; 1， k+2 —-&gt; 2， …… k-2 —&gt; n - 2 即转换映射为 x —&gt; (n + x - k - 1) % n == (x - k - 1) % n，反向的转换关系为： x &lt;— (x + k + 1 - n) % n == (x + k + 1) % n 这些人继续从0号开始报数，那么，如果这n-1个人子问题的最后胜利者编号为f(n)。如果设n个人时胜利者编号为f(n - 1)的话，那么可以得到递推关系式： f(n) = (f(n - 1) + k + 1) % n; 将 k = （m - 1）% n 代入， f(n) = ( f(n - 1) + (m - 1) % n + 1) % n = ( f(n - 1) + m) % n 也就是说，如果求得了n-1个人的胜利者根据递推关系式就可以求得n个人的胜利者，那么n-1个人的胜利者就通过求n-2个人的胜利者来求，因此这是递归过程。 解f(1) = 0; f(i) = (f(i - 1) + m) % i;(i &gt; 1) 。这里的f(i)表示的是胜利者的编号。 推导：Josephus约瑟夫问题及其变种 注意这里的方法没有将每次报数人的编号计算出来，而是仅仅求出了胜利者的编号，下面算法的复杂度为O(n)。 方法二：时间复杂度为 O(n) 这个方法的难度为： 校：★★★☆ 编号从1开始 我们可以给环形链表的结点编号，如果链表的结点数为 n, 则从头结点开始，依次给结点编号，即头结点为 1， 下一个结点为2， 最后一个结点为 n. 我们用 f(n) 表示当环形链表的长度为n时，生存下来的人的编号为 f(n)，显然当 n = 1 时，f(n) = 1。假如我们能够找出 f(n) 和 f(n-1) 之间的关系的话，我们我们就可以用递归的方式来解决了。我们假设人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为 … m - 2 m - 1 m m + 1 m + 2 … 进行了一次删除之后，删除了编号为m的结点。删除之后，就只剩下 n - 1 个结点了，删除前和删除之后的编号转换关系为： 删除前 — 删除后 … — … m - 2 — n - 2 m - 1 — n - 1 m — 无(因为编号被删除了) m + 1 — 1(因为下次就从这里报数了) m + 2 — 2 … — … 新的环中只有 n - 1 个结点。且编号为 m + 1, m + 2, m + 3 的结点成了新环中编号为 1， 2， 3 的结点。 假设 old 为删除之前的结点编号， new 为删除了一个结点之后的编号，则 old 与 new 之间的关系为 old = (new + m - 1) % n + 1。 注：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1. 这样，我们就得出 f(n) (old)与 f(n - 1)(new)之 间的关系了，而 f(1) = 1。所以我们可以采用递归的方式来做。 编号从0开始：f(n) = [f(n-1) + m] % n 编号从1开始：f(n) = [f(n-1) + m-1] % n + 1 代码如下： 12345678910111213141516171819202122232425262728//时间复杂度为O(n)public static Node josephusKill2(Node head, int m) &#123; if(head == null || m&lt;1)&#123; return head; &#125; int len = 1;//计算链表的长度 Node last = head; while(last.next != head)&#123; len++; last = last.next; &#125; //直接计算出目的结点的编号 int des = f(len,m); //把目的结点取出来 while(--des != 0)&#123;//循环des-1次 head = head.next; &#125; head.next = head; return head;&#125;private static int f(int n,int m)&#123; if(n == 1)&#123; return 1; &#125; //old:f(n)和new:f(n-1)的关系：f(n)=[f(n-1)+m-1]%n+1 return (f(n-1,m)+m-1)%n+1;&#125; 测试代码 123456789101112public static void main(String[] args) &#123; int i = 1; Node head = new Node(i); Node node = head; while(++i&lt;6)&#123; node.next = new Node(i); node = node.next; &#125; node.next = head; node = josephusKill2(head, 3); System.out.println(node.value);&#125; 问题拓展对于上道题，假设是从第 K 个结点开始报数删除呢？ 又该如何解决呢？ f(n) f(n-1) … … k+m-2 n-1 k+m-1 删除 k+m 1 k+m+1 2 … … 推导过程：关于递推算法求解约瑟夫环问题P(n,m,k,s) 两种递归方式： 123456789101112131415161718/** * Josephus 环的一个O(N)算法 * https://blog.csdn.net/sun_star1chen/article/details/17567451 * https://www.kancloud.cn/digest/pieces-algorithm/163605 * @param n 总人数 * @param m 数到m的人出列 * @param k 开始报数人的编号 * @return 最后一个出列的编号 */public static int josephusON(int n, int m, int k) &#123; int p = 0; for (int i = 2; i &lt;= n; i++) &#123; //出列的序列 //System.out.print((p + k == n ? n : (p + k) % n)+" "); p = (p + m) % i; &#125; return p + k == n ? n : (p + k) % n; // 返回最后一人的位置&#125; 123456789/** * https://blog.csdn.net/gesanghuazgy/article/details/49688433 */public static int josephusON2(int n, int m,int k) &#123; if(k==1) return (n+m-1)%n; else return (josephusON2(n-1,m,k-1)+m)%n;&#125; 来源：苦逼的码农（ID:di201805） 参考： 1.经典算法–约瑟夫环问题的三种解法 2.约瑟夫环问题的两种解法（详解） 3.Josephus约瑟夫问题及其变种 4.关于递推算法求解约瑟夫环问题P(n,m,k,s) 5.约瑟夫问题(Josephus Problem)的两种快速递归算法 6.约瑟夫环问题（josephus problem）详解 7.链表问题—环形单链表的约瑟夫问题 （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡4：删除单链表的中间结点]]></title>
    <url>%2Ff07b83a7.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢。 【题目描述】 给定链表的头结点head，实现删除链表的中间结点的函数。 例如： 步删除任何结点； 1-&gt;2，删除结点1； 1-&gt;2-&gt;3，删除结点2； 1-&gt;2-&gt;3-&gt;4，删除结点2； 1-&gt;2-&gt;3-&gt;4-5，删除结点3； 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N), 额外空间复杂度达到 O(1) 【难度】 士：★☆☆☆ 解答自己思路删除中间结点，使用一个数存储链表中间结点的计数。而这个数计算方法如下：如果长度是偶数，就除以2；如果是奇数，就除以2加1。 代码如下 1234567891011121314151617181920212223public static Node deleteMidNode(Node head)&#123; if(head == null || head.next == null)&#123; return head; &#125; int length = 0; Node node = head; while(node != null)&#123; length++; node = node.next; &#125; int mid = length % 2 == 0 ? length/2 : length/2+1; node = head; int i = 0; while(++i &lt;= mid-1)&#123; node = node.next; &#125; if(mid == 1)&#123; return head.next; &#125;else&#123; node.next = node.next.next; return head; &#125;&#125; 作者思路这道题要求删除中间结点，我们可以采用双指针的方法来做，就是用一个快指针和一个慢指针，快指针每次前进两个结点，而慢指针每次前进一个结点。当快指针遍历完结点时，慢指针刚好就在中间结点了。之前写过一篇一些常用的算法技巧总结也有所过指针使用的一些技巧。 不过在做的时候，最好是先把一些特殊情况先处理好，例如删除的可能是第一个结点，也有可能不用删除结点(只有一个结点时就不用删除了。 代码如下 123456789101112131415161718public static Node removeMidNode(Node head) &#123; if(head == null || head.next == null) return head; if (head.next.next == null) &#123; //只有两个结点时 return head.next; &#125; Node fast = head.next.next;//快指针 Node slow = head;//慢指针 //slow最终指向中间结点的前驱 while (fast.next != null &amp;&amp; fast.next.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; //进行删除 slow.next = slow.next.next; return head;&#125; 算法图片 上次那道删除倒数第 K 个结点的题（【链表问题】删除单链表中的第K个结点） 其实也是可以使用双指针的，但个人认为，那道题使用双指针的方法并没有我上次那个做法优雅，而这次删除中间结点，则用双指针比较优雅。至于原因，可以自己打下代码看看。 之所以说这个事，是因为有人跟我提双指针的建议，我是非常欢迎有人给我提建议的，不过你的建议如何。不过一上来就说我那篇文章太敷衍，我也是醉了。我开头已经说了，只提供简单的解答，而且也把刷题的文章放到次条了。 问题拓展题目：删除链表中 a / b 处的结点 【题目描述】 给定链表的头结点 head、整数 a 和 b，实现删除位于 a/b 处结点的函数。 例如： 链表：1-&gt;2-&gt;3-&gt;4-&gt;5，假设 a/b 的值为 r。 如果 r = 0，不删除任何结点； 如果 r 在区间 (0,1/5] 上，删除结点 1； 如果 r 在区间 (1/5,2/5] 上，删除结点 2； 如果 r 在区间 (2/5,3/5] 上，删除结点 3； 如果 r 在区间 (3/5,4/5] 上，删除结点 4； 如果 r 在区间 (4/5,1] 上，删除结点 5； 如果 r 大于 1，不删除任何结点。 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N), 额外空间复杂度达到 O(1) 【难度】 士：★☆☆☆ 【解答】 12345678910111213141516171819202122232425262728293031/**删除链表中 a / b 处的结点 * 这道题可以转换为删除第k=(a*n/b)个结点(公式如何得出？) * 其中n表示链表结点的个数，但由于(a*n/b)有可能出现小数，所以我们取K的上限。 * 所谓上限就是大于等于k的最小整数 */public static Node removebyRatio(Node head,int a,int b)&#123; if(a&lt;1 || a&gt;b)&#123; return head; &#125; int len = 0;//记录链表的长度 Node node = head; while(node!=null)&#123; len++; node = node.next; &#125; //问题转换为删除第k=(a*n/b)个结点 int k = (int)Math.ceil((double)(a*len)/(double)b); if(k&gt;1)&#123; node = head; //定位第K个结点的前继 while(--k != 1)&#123;//只需要循环k-2次 node = node.next; &#125; node.next = node.next.next; return head; &#125; if(k == 1)&#123; return head.next; &#125; return head;&#125; 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[收割百度、阿里、腾讯、头条、网易华为等大厂Offer的面经]]></title>
    <url>%2Fe8db5de0.html</url>
    <content type="text"><![CDATA[本文作者是跨专业考研的985硕士一枚，经历研究生两年的学习积累，有幸于2019秋季招聘中拿到几个公司的研发岗offer，包括百度，阿里，腾讯，今日头条，网易，华为等。 一路走来也遇到很多困难，也踩了很多坑，同时他自己也探索了很多的学习方法，总结了很多心得体会，并且，对校园招聘也做了一些研究和相应的准备。 在今年的秋季招聘结束以后，他把这些东西全部都写成文字，做成专题，以便分享给更多未来将要参加校招的同学。以下是他的总结。 大学时期的迷茫与坚定 我的本科专业是电子信息工程，基本没有接触过计算机专业的课程，只学过c语言，然后在大三的时候接触过java，Android，以及前端开发。 那时候我还不知道软件开发的水有多深，抱着试一试的态度去应聘了很多公司。结果可想而知。 当年我对游戏开发很有兴趣，特别是对网易游戏情有独钟，但是当我看到网易游戏研发工程师的招聘要求时，我只能望而却步，因为它要求学历至少是985的硕士。 也因为这个契机，我在大三的暑假开始准备考研，花了一个月的时间深思熟虑之后，选择了我大华科。 毕竟是跨专业，在复习过程还是有点吃力的，但是就靠着一股毅力和执着，半年之后，顺利地考上了，成绩还意外地非常好。 研究生时期的探索和规划 对于即将读研的同学来说，一般有两件事很重要，一件事是选择导师，一件事是选择方向。 我当时本着想要找实习的想法选择了我现在的导师，事实证明我的选择还是很正确的。 而选择方向这件事，我倒是折腾了好久。研一期间我做的最多的事情就是看书了，当时自己的方向还不明确，所以找了很多书来看。当别人都在专研数据挖掘和机器学习时，我还在各种方向之间摇摆不定。 我在读研之前想做游戏开发和Android开发，但我以前也学过Java Web开发。于是我在网上了解对应方向的资讯，发现游戏研发的就业面比较窄，并且基于我之前的学习经历，java开发可能更加适合我。最终在学校的实训项目中我选择了Java Web项目，从此也真正意义上地踏上了Java的学习之路。 我的Java入门之路 之前说过，在研一期间看了很多计算机专业的书籍，比如计算机网络，操作系统，数据库等等，虽然吸收得都不太好，但也算是看过了。 于是我开始踏上学习Java的道路。最开始我找了一些Java的书单，然后买了一些比较基础的书籍，先啃为敬。那时候我看过《Java从入门到精通》这种烂大街的书，也看过《Java编程思想》这种很难懂的书。 一段时间后我感觉吸收效果不好，于是开始把目光转向视频课程了。那时候听舍友力神的建议，到极客学院上看一些视频课程，我当时就觉得这个讲的比书上要好懂一些。后来我又接触到了慕课网，中国MOOC等网站，逐渐地把相关的技术课程都看完了。 那时候正好我们的项目实训还在进行，于是我就把趁热打铁把这些东西用在了项目当中，并且第一次用博客记录下我的实践经验。 现在回头想想，此时的我也只不过是刚刚入门了Java以及web开发。然而那时候不知道天高地厚的我，就开始xjb投各大公司的Java实习岗位了。结果可想而知，那叫一个惨啊。 我的Java进阶之路 上文说到我刚刚开始投递实习岗位，是在研一的下学期。当时整天躲在实验室，一边看书一边看视频，接到面试时赶紧刷面经，忙的不亦乐乎。那段时间感觉自己的复习状态和考研差不多。 然而，由于水平确实不咋地，当时我被各大公司的面试官吊打。比如我第一家面的就是百度，三个很简单的问题一个都不会，人家面试官都不好意思打击我了。后来我又面了一些大大小小的互联网公司，虽然情况有所好转，但是总的来说，我要学习的东西还很多。 在准备面试的过程中，我看了很多面经，也看了很多技术博客，发现自己的基础很薄弱，需要系统性的学习。并且这些东西是视频和入门书籍给不了我的。于是我又踏上了找书的道路。 那时候Java书单泛滥，有的书单质量低下，买来的书看两眼就看不下去了。直到我看到了“江南白衣的后端书架”这一文章，才发现Java后端书架原来应该是这样的。于是我照葫芦画瓢把相关书籍都买了，这个阶段，也算是刚刚踏上Java进阶之路吧。 这里面不得不提几本书，对学习Java的同学非常重要，一本是《深入理解JVM虚拟机》，一本是《深入分析Java技术内幕》，以及《Java并发编程艺术》。 再后来，凭着一股不到黄河心不死的精神，终于拿到了网易游戏的实习offer。于是，第一次在大厂实习的机会终于来了，我怀着即期待又忧虑的心情来到了杭州。 我的Java实习之路 在猪场实习的时间并不长，也就持续了三个月不到，当时我们部门在做数据仓库，于是我这边主要负责Java Web应用的开发，其实也就是写一些简单的后台接口。 在熟悉了工作流程以后，我很快就适应了工作的节奏，毕竟做的东西也不难，导师也会经常指导，就这样我完成了一个又一个需求，直到后来家里有事，我才临时选择辞职回家。 由于在网易实习的时间比较短，我也留下了一些遗憾，比如对整个项目的架构不够熟悉，并且很多相关技术栈也来不及学习。后来我去熊厂实习的时候，尽量避免了这些问题。 熊厂实习的时间长达半年，部门当时做的是私有云，emmm完全是全新的技术栈啊，于是我基本上又是从零开始学习云计算，但是由于之前的操作系统和网络基础不扎实，在学习相关技术时，基本是两眼一抹黑，学啥啥不会。 这也导致我在上班期间看了很多计算机基础方面的书籍，包括《计算机网络：自顶向下》，《深入理解计算机系统》等等。当然，这也是因为我的工作内容很简单。CRUD你懂的。 于是花时间自学成为了我那时候的主旋律，看书，看内网资源，参加技术分享，倒也非常充实。当然，有空我也会看看项目代码，了解一下技术架构，以便让自己对整个项目有一个更好的理解。 再后来，2018年来了。 抉择时刻：实习转正还是秋招 我是2018年1月份离开北京的。当时面临几个问题，是否续租房子，是否继续实习。还有一个小插曲就是当时养的一只猫也得带回去。再三思考后我决定回学校准备秋招。 过年后我就回到学校了，当时我本不打算参加春招，想要潜心修炼准备秋招，但是架不住春招宣传力度大，并且几个大厂都标榜着“转正容易，hc多多”等口号。于是我没忍住，上牛客投了几次简历，打算面几家大厂，心想万一过了就去吧。 简历都投出去了，那也只好复习了啊，当时我们宿舍跟打了鸡血一样，一整天都在刷题，从早到晚泡着刷LeetCode，一个月后终于刷到100多题，也算是能应付一下笔试了吧。 春招我投的公司不多，也就at，网易游戏和京东。最后阿里和京东都给了offer。但是当时阿里的流程走得特别慢，直到内推截止前一天才给我发offer，并且自己也感觉之前面试表现一般，心想我要是去了也是B+，很有可能成为拥抱变化的牺牲品，于是我咬咬牙放弃了，大不了秋招再来。 塞翁失马，焉知非福，春招的颗粒无收反而让我可以安心准备秋招，于是我有大把的时间做我想做的事，制定自己的学习计划，安排自己的生活，不需要去考虑转正这种麻烦事了。 至此，四月终了，春招告一段落。 Java修仙之路 平时经常逛牛客，我也经常发些面经啥的，于是很多牛油喜欢调侃说“看神仙”。这时候我只能尴尬又不失礼貌的微笑了0。0 在下不才，成不了神仙，最多就是打游戏的时候能修修仙罢了。 不过你还真别说，网上还真有“Java成神之路”这样的文章，真的打扰了哈哈。 科普一下修仙梗： 修仙梗的意思是喜欢熬夜的人不睡觉不猝死反而要修仙，然后就被广大的网友们互相调侃玩坏了，现在熬夜都不叫熬夜了，新潮的说法就是修仙，熬夜不会猝死啊，会增强法力。 不逗你们了，咱们还是进入正题吧。我在五月份的时候做了一个计划，打算在七月底之前完成复习工作，原因是七月底有阿里的提前批招聘，是我最最重视的一个招聘。这个计划简称三个月计划，我主要做了三个方面的学习规划。 一：首先，便是对Java后端技术栈的复习，这也是最重要的一部分，因为面试永远都是考基础考得最多。 这部分内容又可以细分为多个方面： 1 Java知识体系：包括了Java基础，集合类，设计模式，Java并发技术，Java网络编程，JVM，JavaWeb，Spring框架等等。 2 计算机基础：包括了操作系统，计算机网络，数据结构，数据库，缓存等内容。 3 后端进阶：包括了分布式理论，以及常见分布式技术比如负载均衡，zookeeper，消息队列，分布式缓存等等。当然，这里面也包括系统架构方面的知识，以及RPC，微服务等内容。 4 额外内容：这部分内容因人而异，我主要是因为实习的时候项目涉及了hadoop以及私有云技术栈，所以自己看了很多这方面的东西，譬如Hadoop生态，OpenStack生态，以及docker生态。 我在复习这部分内容的时候，一般先看优质博客，然后自己整理总结对应写一些博客，最后把能够实现的东西实现一下，这样一来一个知识点就搞定了。剩下的事情就是重复这个步骤。 下面放上我的博客：https://blog.csdn.net/a724888 二：其次，便是对算法的学习了。我也把算法的学习分为了几个部分。 1 基础数据结构与算法：主要是复习之前学过的数据结构和算法，额外再看一些算法书籍，譬如《图解算法》，以了解常见算法。 2 剑指offer：剑指offer基本上是面试必考的，所以把它刷个两三遍是很有必要的。 3 LeetCode：搞定前面两项之后，刷LeetCode也会有些底气了，我当时就刷了150题左右，主要也是刷经典的题目。 4 笔试真题：这个就不用多说了，真题是一定要刷的。毕竟各个公司出题的路子都花里胡哨。 刷题多了，就会遇到很多原题和类似题目，所以，尽早开刷，做好准备吧。 三、最后一部分，则是做项目。大概说下我做项目的几个要点吧 1 为什么这时候我还要做项目呢：一来是我觉得实习过程自己接触的东西太细碎，没有对全局做把控，二来是因为想给GitHub加点东西，顺便学点新的技术。于是我选择了当时牛客网上的两个项目来自己做做看。 2 关于项目选择：叶神这两个项目还是讲的非常棒棒的，用的东西也很新，代码也有提供，避免了自己要写前端的尴尬，另外，这两个项目模仿了知乎和头条，更加接地气。 3 把项目做到GitHub上：之前对git也比较熟了，所以想把这个项目按照正常开发的流程走一遍，于是我每天都会做一个模块，然后发布几个版本，记录一下版本更新的细节，写这些东西的时候，自己其实就已经做了思考和总结，感觉还是不错的。 下面放上我的GitHub：https://github.com/h2pl 就这么过了三个月，提前批拉开序幕。 秋招回忆录 从七月初第一次投递简历，到九月初，整整两个月的时间，大大小小投了几十家公司，其中很多都是提前批，内推，也经历了许多的笔试，面试。 期间也拿了几个offer，包括百度，腾讯，蚂蚁金服，头条，华为，网易（网易云音乐没给offer，调到了其他部门）。有几家直接收到拒信的，包括拼多多，深信服。还有几家在等待结果。包括快手，斗鱼等。 当然也有一些还没面试完的公司以及待安排面试的公司，这里就不展开说了。 八月底基本上提前批就已经结束了，所以一般这段时间正式校招也开始了，各种大规模的笔试也很多，所以大家即使没有拿到offer也不要灰心，毕竟校招是一场持久战，基本上要到九月十月才能下结论。我之前分享了很多公司的面经，其实大部分都是提前批的，很多都是直接免笔试的，因为我对算法并不是很在行，所以感觉还是比较幸运的。 从七月底第一次面试到9月基本佛系，中间经历了大大小小的面试，这里只进行简单的记录哈，要看面经的话请到我的公众号：程序员江湖。 具体的面经都比较长，这里大概介绍一下面试的情况，然后我会放上面经的链接供大家查阅。 1 阿里面经 阿里中间件研发面经 蚂蚁金服研发面经 岗位是研发工程师，直接找蚂蚁金服的大佬进行内推。 我参与了阿里巴巴中间件部门的提前批面试，一共经历了四次面试，拿到了口头offer。 然后我也参加了蚂蚁金服中间件部门的面试，经历了三次面试，但是没有走流程，所以面试中止了。 最后我走的是蚂蚁金服财富事业群的流程，经历了四次面试，包括一次交叉面，最终拿到了蚂蚁金服的意向书，评级为A。 阿里的面试体验还是比较好的，至少不要求手写算法，但是非常注重Java基础，中间件部门还会特别安排Java基础笔试。 2 腾讯面经 腾讯研发面经 岗位是后台开发工程师，我没有选择意向事业群。 SNG的部门捞了我的简历，开始了面试，他们的技术栈主要是Java，所以比较有的聊。 一共经历了四次技术面试和一次HR面试，目前正在等待结果。 腾讯的面试一如既往地注重考查网络和操作系统，并且喜欢问Linux底层的一些知识，在这方面我还是有很多不足的。 3 百度面经 百度研发面经 百度研发面经整合版 岗位是研发工程师岗位，部门包括百度智能云的三个分部门以及大搜索部门。 百度的提前批面试不走流程，所以可以同时面试好多个部门，所以我参加百度面试的次数大概有12次左右，最终应该是拿了两个部门的offer。 百度的面试风格非常统一，每次面试基本都要到电脑上写算法，所以那段时间写算法写的头皮发麻。 4 网易面经 网易研发面经 面试部门是网易云音乐，岗位是Java开发工程师。 网易是唯一一家我去外地面试的公司，也是我最早去实习的老东家。 一共三轮面试，耗时一个下午。 网易的面试比我想象中的要难，面试官会问的问题都比较深，并且会让你写一些结合实践的代码。 5 头条面经 今日头条研发面经 岗位是后台研发工程师，地点选择了上海。 我参加的是字节跳动的内推面试，当时找了一个牛友要到了白金码，再次感谢这位头条大佬。 然后就开始了一下午的视频面试，一共三轮技术面试，每一轮都要写代码，问问题的风格有点像腾讯，也喜欢问一些底层知识，让我有点懵逼。 另外，我上周还面试了一次亚马逊，因为很多知名外企到十月才开始招人，所以闲了很久之后我又重操旧业了，可能在面完大摩和微软之后，秋招才能正式结束吧 结束也是开始 中秋节刚过，国庆节又要到来了。正如每一年的秋招一样，年复一年，在时间面前我们也是渺小的尘埃。 秋招结束不代表着结局，而是新的旅程开始，马上，毕业论文，offer选择，入职准备，毕业旅行等事项也要提上日程了。 不知道明年我们看待学弟学妹的秋招时，会是怎样的一种心境呢。 本文转载自公众号『程序员江湖』，搜索『WealthyCoder』即可关注。 （完）]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡3：删除单链表中顺数、倒数第K个结点]]></title>
    <url>%2F705cc6ed.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题。每道题会提供简单的解答。 【题目描述】 在单链表中删除顺数、倒数第 K 个结点。 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N), 额外空间复杂度达到 O(1) 【难度】 士：★☆☆☆ 解答删除倒数第K个结点的时候会出现三种情况： 1、不存在倒数第 K 个结点，此时不用删除。 2、倒数第 K 个结点就是第一个结点。 3、倒数第 K 个结点在第一个结点之后。 所以我们可以用一个变量 length记录链表一共有多少个结点。 如果 length&lt; K，则属于第一种情况。 如果 length== K，则属于第二种情况。 如果 length&gt; K, 则属于第三种情况，此时删除倒数第 K 个结点等价于删除第 (length- k + 1) 个结点。 删除顺数第K个代码如下： 123456789101112131415161718192021222324252627282930313233343536//删除单链表中的第K个结点public static Node deleteKthNode(Node head,int K)&#123; if(head == null || K &lt; 1)&#123; return null; &#125; int length = 0;//链表的长度 Node node = head; while(node!=null)&#123; length++; node = node.next; &#125; if(length &lt; K)&#123; return head; &#125; node = head; //删除第一个 if(K == 1)&#123; node = node.next; return node; &#125; int i = 0; while(++i != K - 1)&#123; node = node.next; &#125; //删除最后一个 if(length == K)&#123; node.next = null; //node和head引用的是一个对象，所以返回head return head; &#125; if(length &gt; K)&#123; node.next = node.next.next; return head; &#125; return null;&#125; 删除倒数第K个代码如下： 1234567891011121314151617181920212223242526//删除倒数第K个结点public static Node deleteLastKthNode(Node head, int K) &#123; if(head == null || K &lt; 1) return head; Node node = head; int length = 0; while (node != null) &#123; length++; node = node.next; &#125; if (length == K) &#123; return head.next; &#125; if (length &gt; K) &#123; node = head; //删除第(num+1-k)个结点 //定位到这个点的前继 //只能循环length-K次，原解这里有误，多循环了一次。原解为length-K while (length - K -1 != 0) &#123; node = node.next; length--; &#125; node.next = node.next.next; &#125; return head;&#125; 测试代码 123456789101112131415public static void main(String[] args) &#123; int i = 1; Node head = new Node(i); Node node = head; while(++i&lt;6)&#123; node.next = new Node(i); node = node.next; &#125; //node = deleteKthNode(head,3); node = deleteLastKthNode(head, 2); while(node!=null)&#123; System.out.println(node.value); node = node.next; &#125;&#125; 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡2：如何优雅着反转单链表]]></title>
    <url>%2F124f68d0.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢 【题目描述】 反转单链表。例如链表为： 1-&gt;2-&gt;3-&gt;4 反转后为 4-&gt;3-&gt;2-&gt;1 【要求】 如果链表的长度为 N, 时间复杂度达到 O(n), 额外空间复杂度达到 O(1) 【难度】 士：★☆☆☆ 解答方法1 这道题还是挺简单的，当我们在反转一个结点的时候，把一个结点的后继改为指向它前驱就可以了。这里需要注意的点就是，当你把当前结点的后继指向前驱的时候，这个时候链表会被截断，也就是说后面的结点和当前结点分开了，所以我们需要一个变量来保存当前结点的后继，以防丢失。 具体代码如下： 代码如下 1234567class Node&#123; public int value; public Node next; public Node(int data)&#123; this.value = data; &#125;&#125; 主要代码 123456789101112131415//反转单链表public static Node reverseList(Node head)&#123; Node next = null;//指向当前结点的后继 Node pre = null;//指向当前结点的前驱 while(head!=null)&#123; next = head.next; //当前结点的后继指向前驱 head.next = pre; pre = head; //处理下一个结点 head = next; &#125; return pre;&#125; 运行过程 方法二 这道题也可以用递归来做，假设 方法 reverse() 的功能是将单链表进行逆转。采用递归的方法时，我们可以不断着对子链表进行递归。例如对于如下的链表： 我们对子链表 2-&gt;3-&gt;4 进行递归，即Node newList = reverse(head.next)。递归之后的结果如下： 逆转之后子链表 2-&gt;3-&gt;变为了 4-&gt;3-&gt;2。注意，我刚才假设 reverse() 的功能就是对链表进行逆转。不过此时结点 1 仍然是指向结点 2 的。这个时候，我们再把结点1 和 2逆转一下，然后 1 的下一个结点指向 null 就可以了。如图： 递归的结束条件就是：当子链表只有一个结点，或者为 null 时，递归结束。代码如下： 12345678910111213141516//用递归的方法反转链表public static Node reverseList2(Node head)&#123; if(head == null || head.next == null)&#123; return head; &#125; //递归反转子链表 //第四次递归返回结果为 1 -&gt; 2 -&gt; 3 &lt;- 4 //head:3,next=nodeList,nodeList:4 null //第三次递归返回结果为 1 -&gt; 2 &lt;- 3 &lt;- 4 //... Node nodeList = reverseList2(head.next); head.next.next = head; //head:3 nodeList,nodeList:4 head, head.next = null; //head:3 null, nodeList:4 head,head:3 null return nodeList;&#125; 测试代码 1234567891011121314public static void main(String[] args) &#123; int i = 1; Node head = new Node(i); Node node = head; while(++i&lt;5)&#123; node.next = new Node(i); node = node.next; &#125; node = reverseList2(head); while(node!=null)&#123; System.out.println(node.value); node = node.next; &#125;&#125; 运行截图 第四次递归返回： 第四次递归处理返回： 第三次递归返回： 问题拓展题目：反转部分链表结点 【题目描述】 题目：给定一个单向链表的头结点head,以及两个整数from和to ,在单项链表上把第from个结点和第to个结点这一部分进行反转 例如： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null,from=2,to=4 结果：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null 例如： 1-&gt;2-&gt;3-&gt;null from=1,to=3 结果为3-&gt;2-&gt;1-&gt;null 【要求】 1、如果链表长度为N，时间复杂度要求为O（N),额外空间复杂度要求为O（1） 2、如果不满足1&lt;=from&lt;=to&lt;=N,则不调整 【难度】 士：★☆☆☆ 【解答】 12345678910111213141516171819202122232425262728293031323334353637383940//反转部分链表结点public static Node reversePartList(Node head,int from,int to)&#123; if(head == null)&#123; return head; &#125; int length = 0;//记录链表的长度 Node node = head; Node pre = null;//记录from前一个结点 Node aft = null;//记录to后一个结点 while(node != null)&#123; length++; if(length == from-1)&#123; pre = node; &#125; if(length == to+1)&#123; aft = node; &#125; node = node.next; &#125; //判断给定的值是否合理 if(from &lt; 1 || from &gt;= to || to &gt; length)&#123; return head; &#125; //把from到to这部分链表进行反转 node = pre == null ? head : pre.next;//node指向部分链表的第一个结点 Node cur = node.next;//cur指向当前要处理的结点 node.next = aft;//先处理第一个结点 Node next = null; while(cur != aft)&#123; next = cur.next;//保存当前结点的下一个结点 cur.next = node; node = cur; cur = next; &#125; if(pre != null)&#123;//说明反转的中间 pre.next = node; return head; &#125; return node;&#125; 【运行图片】 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡1：生成窗口最大值数组]]></title>
    <url>%2F2ebd4c17.html</url>
    <content type="text"><![CDATA[做算法题了，题的难度我们分为“士，尉，校，将”四个等级。这个算法题的模块是篇幅比较小的那种模块。首先是给出一道题的描述，之后我会用我的想法来做这道题，今天算是算法题的第一道题，先来试试水。 问题描述（等级：尉）有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。 例如，数组为[4,3,1,5,4,3,7,5]，窗口大小为5时: [4 3 1 5 4] 3 7 5 max = 5 4 [3 1 5 4 3] 7 5 max = 5 4 3 [1 5 4 3 7] 5 max = 7 4 3 1 [5 4 3 7 5] max = 7 即窗口最大值数组为 result = {5, 5,7,7} 解答对于一道题，我一般会第一时间想到用暴力的方法来做，之后再来慢慢优化。 显然，对于这道题用暴力法来做还是挺简单了，窗口每次向右移动一位时，我们每次遍历窗口内的w个元素，然后求出此时窗口的最大值就可以了，用这种方法的时间复杂度是 O(w*n)。代码如下： 12345678910111213141516171819202122//暴力法求解，时间复杂度：O(n*w)//w:窗口内的w个元素public static int[] getMaxWindow(int[] arr,int w)&#123; int length = arr.length; if(w&lt;1 || arr == null || length&lt;w)&#123; return null; &#125; int[] result = new int[length-w+1]; int index = 0; //总共需要遍历result.length，也就是length-w+1次 for (int i = w-1; i &lt; length; i++) &#123; int max = arr[i]; //暴力求解直接从第 w-1个元素开始遍历 for (int j = i; j &gt; i-w; j--) &#123; if(arr[j]&gt;max)&#123; max = arr[j]; &#125; &#125; result[index++] = max; &#125; return result;&#125; 大家想一个问题，例如对于刚才例题中的数组： 第一次遍历的时候，max = 5 第二次遍历的时候，max = 5 我们刚才用暴力法的时候，无论是第一次还是第二次，我们都是把窗口内的所有元素都给遍历了一次，以此来寻找最大值，可是，真的需要这样吗？ 第一次遍历的时候，我们找出了max = 5, 那么在第二次遍历的时候，在窗口范围内，max = 5 左边的两个数1， 3 还有可能是最大值吗？也就是说，max=5 左边的窗口元素还要必要遍历吗？ 显然，max=5左边的窗口实际上是不必再遍历的了，也就是它不可能会是窗口的最大值。 而 max = 5 右边的 4 有可能会是窗口的最大值吗？由于窗口还会一直向右移动，所以 max = 5 右边的窗口元素还是有可能是某一个窗口的最大值的。 因此，我们可以用一个双向的队列，来记录有可能成为窗口最大值的下标，注意，这里指的是有可能。 像刚才的 max = 5 前面的 1,3 就不可能成为窗口的最大值了，而右边的4还是有可能成为窗口的最大值的。并且这个队列是有序的，队首存放的总是队列中的最大值， 我以这道题来演示一下，我们用result[] 数组来存放窗口最大值。 1、result[0] = 5 2、result[1] = 5; 3、result[2] = 7 其他的全部都要出队，因为7前面的5，4，3是不可能成为窗口最大值的了。 4、result[3] = 7 遍历完毕。这种方法的话时间复杂度是 O(n)。 我这里只是提供了思路与大致的做法，具体的代码实现还是有很多细节需要注意的。下面给出实现代码，代码会有详细的解释。 123456789101112131415161718192021222324252627282930313233//优化，时间复杂度：O(n)public static int[] getMaxWindow2(int[] arr,int w)&#123; int length = arr.length; if(w&lt;1 || arr == null || length&lt;w)&#123; return null; &#125; //用来保存成为最大窗口的元素 int[] result = new int[length-w+1]; int index = 0; //用链表充当双向队列 LinkedList&lt;Integer&gt; tempList = new LinkedList&lt;Integer&gt;(); //暴力法直接从i=w-1开始的 for (int i = 0; i &lt; length; i++) &#123; /*如果队列不为空，并且存放在队尾的元素小于等于当前元素，那么 队尾的这个元素就可以弹出了，因为他不可能会是窗口最大值。 当前元素指的是i增大时新加入的元素。*/ //经过检测，比较队首的元素也是可以的 while(!tempList.isEmpty() &amp;&amp; arr[tempList.peekFirst()]&lt;arr[i])&#123; tempList.pollFirst(); &#125; //把当前元素的下标加入队尾 tempList.addLast(i); //如果队首的元素的下标不在窗口范围内，则弹出 if(tempList.peekFirst() == i-w)&#123; tempList.pollFirst(); &#125; //由于队首存放的是最大值，所以队首总是对应窗口的最大值元素 if(i&gt;=w-1)&#123; result[index++] = arr[tempList.peekFirst()]; &#125; &#125; return result;&#125; 说实话，微信看代码确实有点难受，如果是在电脑浏览的话还好点，我在考虑要不要用截图的方式，不过如果是截图的话，有些人想要复制代码的话会复制不了，那我之后考虑把代码打包，你们后台回复获取。 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大三、研二的秋招备战路线（Java、大数据）]]></title>
    <url>%2F6e869c7c.html</url>
    <content type="text"><![CDATA[一、写作背景1.分享经验。从去年五月份到今年五月份，我面试了n家公司，也收了(n/2+10)家的offer，经历了两个春招一个秋招，其中有腾讯、今日头条、京东等offer。通过这篇文章分享一些经验，让后面的同学少走弯路。 2.解决问题。我有自己的学习群和知识星球，秋招快到了，避免不了被问关于秋招备战的问题。通过这篇文章把我自己能想到的路线和方法系统化先输出出来，以便于精细化提问，也为我自己节省时间。 二、秋招的意义1.秋招对于大企业是一场人才储备的战役，只有相对较大的企业才有秋招这个概念，它们有资本和资源花费大量精力进行宣传面试，可以提前发offer，坐等你毕业来上班。 2.对于学生来说，秋招是一场大型的招聘会，可能是这辈子离大厂最近的，机会最多的，也是唯一一次有精力面对这么多大厂的面试。 3.秋招offer在手，毕业时间我有。秋招拿了offer之后，对于你后面的面试也好，玩也好，都是起到非常关键的作用。至少心理负担不会那么大，面试起来也会更上手一次，不急不躁，玩起来也嗨，没有就业压力，毕业之前的时间随意安排。 三、不同的同学备战秋招的策略想要在秋招拿到offer，记住以下三点，接下去的案例都围绕这三点： 1.拿到足够多的面试机会， 别让自己的才华无处施展。 2.根据自己的简历形成系统性的知识，在面试中占据主动地位。 3.成不骄，败不馁。不断地从面试中总结经验，补自己的知识盲区。 案例1 有小公司Java实习经验，参与过两个项目的开发，算法不太行，基础一般，有大数据基础，自己做了个大数据项目。 目标：秋招想收到大数据offer，最好大厂。 分析：项目是长板，算法是短板，其他正常。所以要用最短时间把项目补扎实，成为优势，算法逐渐拉上来，其他时间扑理论基础上。 学习路线： 1.先把自己手头上的Java分布式项目弄明白，对其中的技术栈以及业务进行深入了解，并自己整理项目中的难点和亮点，最终能漂漂亮亮的写在简历上。先熟悉手头项目，一方面项目是面试的敲门砖，没有项目的简历会显得空洞，有项目可以避免项目经验不足被刷。另一方面，项目在面试中也占着很大比重，面试官比较喜欢从项目场景切入到理论知识。 2.每天安排时间刷算法，剑指offer、牛客leetcode148题，容易的先刷，刷一题整理一题到博客，先懂思路后懂代码，一天至少1题，争取重复刷几遍到会手写。大厂必问算法，而且大都剑指offer或者leetcode原题或变形题，有些只问思路。所以算法必刷，先刷思路，要整理起来，避免刷过即忘。 3.补Java集合源码、JVM、多线程。不看书，直接去网上搜面试题，最后把高频的整理了下来，直接刚面试题，借助博客辅助理解。同样，懂一题整理一题到博客。(整理的面经我学习群公告有)大数据岗位也要求Java知识，就算到时大数据面不上，面大厂Java还是妥妥的，会大数据知识可以加分。 4.熟悉大数据项目里的技术栈和流程，理解并整理常见大数据面试题。 5.对数据库、操作系统、计算机网络常见面试题进行熟悉。因为这些在面试中不会占很大比例，而且问来问去也是那几题，所以放到最后。 6.有时间再看相关书籍，系统梳理。因为准备时间有限，而我的目的又是通过秋招面试，所以都是从面试题开始刷起，零散整理，最后有时间再通过看书系统梳理。 7.投递小厂练手。当准备差不多的时候我就开始投递简历面试小公司，通过这样去补缺补漏。 案例2 目前正在公司实习，但已经确定不留在这家公司，打算秋招前夕辞职全身心备战。 目标：大厂的Java或者大数据offer 路线： 1.针对目前还在公司实习或者即将去公司实习的同学，如果已经确定不留在该公司，那么可以「面向简历实习」。面向简历实习，顾名思义，简历上需要什么就学什么。公司可以提供的资源就是项目，有文档给你看，不懂的还有老员工可以帮你讲解。你需要快速地了解项目所用的技术栈，以及应用的业务场景，尽可能多地去搜集相关资料和看源码。多听听老员工在探讨什么技术难点，以及解决方案是怎么实施的，不懂的就多问。 2.在实习期间估计也只有精力学习项目了，在职期间去刷算法或者补理论基础不太现实。当把你实习的项目有目的性地吃透之后，就可以全身而退，开始刷算法和补基础。 3.如果要找大数据相关，可以通过基础视频入门，自己做一两个项目，把简历写好。其余的可以参考案例1的学习路线。 案例3 懂点Java基础，有学校课设的管理系统项目，懂基本的数据结构。 目标：秋招能进一个知名的大厂做Java。 规划路线： 1.先用一些时间补1到2个项目，技术栈要相对好一些，这样能保证有面试大公司的机会和进小公司的机会。 2.当你能把相对较好的项目写在简历上，并且懂一部分技术栈的原理，那么先暂停对项目的学习，转战Java。先从Javase开始，到JVM，最后并发编程。se和JVM理论较多，先记住能理解的，再就是理解性的背，面试前才机械性记忆。并发编程可以从常见的多线程实现开始熟悉，自己敲敲常见的多线程实现demo，以及常用的几个线程池，再去比较每个实现方法的优缺点，参数。再由此切入到线程安全，并发锁等等。记得整理！ 3.由于数据结构算法基础不是很扎实，可以先从常见的7大选择，8大排序开始熟悉，尽量能手写代码。再就是刷剑指offer，统一先刷实现思路，遇到能理解的代码实现也可以记住，不然只记思路也可以。每天刷，记得整理！ 4.回过头深入理解项目的技术栈，常见的技术栈面试题，项目的业务场景怎么样，技术栈怎么和业务关联，可以找出哪些实现难点，有哪些可以当亮点。 5.投递小公司，收到面试通知之后刷数据库、操作系统等面试题。 案例4 非科班零基础。 目标：秋招尽量找份开发工作。 先看看Java基础视频入门，然后补项目、适当地补点Java基础，懂一些基本的JVM和多线程，数据结构和算法只看基本的排序和选择。当达到案例二的水平之后可以走它的学习路线进行进阶。 案例5 大三或研究生，机器学习或者其他方向，技术栈主要是Python，算法基础还行，有个Python小项目。由于机器学习竞争激烈，但自己又没核心竞争力，走Python后台或者爬虫岗位需求少。 目标：秋招找份大厂大数据开发或者后台开发 学习路线： 1.由于已经会Python语言了，所以学Java会比较快。可以快速地过一遍Java基础。 2.根据想走的方向针对性去准备1至2个项目，然后熟悉。可以参考案例1的学习路线去准备算法和基础。 3.把你的Python项目也写上，做大数据或者Java会Python也是加分的。 总结 秋招 = 项目 + 语言基础 + 计算机基础 + 算法 + 软实力 争取在项目中有： 微服务：SpringCloud、SpringBoot、Dubbo等 分布式服务框架：Zookeeper等 消息队列：Kafka、RabbitMQ、RocketMQ等 内存数据库：Memcached、Redis等 分布式搜索引擎：Solr、Lucene、ES等 大数据框架：Hadoop、Hive、Spark等 语言基础： Javase、集合源码、JVM、多线程、IO等 计算机基础： 数据库、计算机网络、操作系统 算法: 基本的排序和选择算法、剑指offer、牛客148题Leetcode等 四、部分面试题整理JavaJava散列表，树对应的容器类，hashmap如何解决冲突 Java实现生产者和消费者的三种方法 init方法与clinit方法的区别 Java中的引用 Java对象的创建过程 Java中创建子类实例时会创建父类实例？ Java的类加载机制 为什么会出现锁机制？ 抽象类和接口的区别 双亲委派模型：启动加载器、扩展加载器、应用程序加载器 重载与重写 Java的类型擦除 简述Java Object类中的方法有哪些 char可以存储汉字嘛？ 抽象类和接口的区别 静态分派与动态分派 HashMap与HashTable的区别 什么时候使用HashMap？它有什么特点？ HashMap的基本原理及内部数据结构 HashMap的put和get操作 简述Java中的深拷贝与浅拷贝，C++中的浅拷贝和深拷贝 解释一下static块和static变量的执行顺序 equals()的重写规则 Java中如何创建线程？ JDK1.8新特性 JVMJVM内存布局 JVM垃圾回收机制 JVM垃圾回收算法 哪些对象在老年代？ 从年轻代到老年代执行的时间以及发生转移的场景 为什么存在GC？ 简单可达性分析 Minor GC安全检查 垃圾回收器 引用记数法和可达性算法 类加载机制过程 双亲委派模型 双亲委派机制 Java集合排序算法比较 Hashmap是线程安全的吗?为什么？ ArrayList与LinkedList区别 HashMap、LinkedHashMap和TreeMap 冒泡排序的优化以及快排过程及优化 红黑树 JDK7与JDK8中hashmap的区别 hashmap的初始容量为什么设置为16？ 平衡二叉树的插入删除操作 并发编程锁分段技术、ConcurrentHashMap、扩容 Java同步线程有哪些方式？ volatile 和 synchronized的区别 讲一下同步异步（进程和IO） synchronized和volatile的区别？ 线程安全 对象的内存布局 哪些是线程安全的容器？ ConcurrentHashMap介绍 线程启动start和run HashMap为什么线程不安全？ 简述Java内存模型的happen before原则 volatile的原理和实现机制 || volatile到底如何保证可见性和禁止指令重排序的？ volatile关键字的两层语义 || 可见性 volatile保证原子性吗？ volatile能保证有序性吗？ ZookeeperDubbo简介及以Zookeeper为注册中心 Zookeeper的leader选举过程 2PC and 3PC 简述Zookeeper。。。watcher 简介ZAB 简述paxos算法 Zookeeper如何保证数据的一致性？ 叙述ZAB集群数据同步的过程 Zookeeper中的ACL Zookeeper底层实现数据一致性 Zookeeper在yarn框架中如何实现避免脑裂的? 大数据Kylin： 简介Kylin Kylin的工作原理 Kylin的技术框架 Cube、Cuboid 和 Cube Segment Kylin 对维度表的的要求 Cube的构建过程 全量构建和增量构建的区别 流式构建原理 HiveHive内部表与外部表的区别 Hive与传统数据库的区别 Hiverc文件 Hive分区 Hive分区过多有何坏处以及分区时的注意事项 Hive中复杂数据类型的使用好处与坏处 hive分桶？ Hive元数据库是用来做什么的，存储哪些信息？ 为何不使用Derby作为元数据库？ Hive什么情况下可以避免进行mapreduce？ Hive连接？ Hive MapJoin? Hive的sort by, order by, distribute by, cluster by区别？ Hadoop计算框架特性 Hive优化常用手段 数据倾斜整理(转) 使用Hive如何进行抽样查询？ StormStorm的可靠性如何实现？包括spout和bolt两部分 怎么提高Storm的并发度？ Storm如何处理反压机制？ Storm中的Stream grouping有哪几种方式？ Storm的组件介绍 Storm怎么完成对单词的计数？ 简述Strom的计算结构 SparkSpark的运行模式 RDD是如何容错的？ Spark和MapReduce的区别 说一下Spark的RDD 自己实现一个RDD，需要实现哪些函数或者部分？ MapReduce和Spark的区别 Spark的Stage是怎么划分的？如何优化？ 宽依赖与窄依赖区别 Spark性能调优 Flink、Storm与Spark Stream的区别（未） 说下spark中的transform和action RDD、DataFrame和DataSet的区别 Spark执行任务流程（standalone、yarn） Spark的数据容错机制 Spark技术栈有哪些组件，每个组件都有什么功能，适合什么应用场景？ Spark master使用zookeeper进行HA的，有哪些元数据保存在Zookeeper？以及要注意的地方 driver的功能是什么？ spark端口 RDD有哪几种创建方式 map和flatmap的区别 Spark的基本工作流程 HadoopMR的Shuffle过程 Yarn的工作机制，以及MR Job提交运行过程 MapReduce1的工作机制和过程 HDFS写入过程 Fsimage 与 EditLog定义及合并过程 HDFS读过程 HDFS简介 在向HDFS中写数据的时候，当写某一副本时出错怎么处理？ namenode的HA实现 简述联邦HDFS HDFS源码解读–create() NameNode高可用中editlog同步的过程 HDFS写入过程客户端奔溃怎么处理？（租约恢复） Kafkakafka介绍 Kafka与传统消息队列的区别？ kafka的零拷贝 kafka消息持久化和顺序读写？ 网络简述TCP和UDP的区别 七层协议每一层的任务及作用 简述http状态码 简述http协议与https协议 简述SSL协议 解析DNS过程 三次握手，四次挥手的过程？？为什么三握？？ 剑指offer常问字符串转换成整数 链表中倒数第K个结点 二维数组中的查找 替换空格 从尾到头打印链表 重建二叉树 用两个栈实现队列 斐波那契数列及变形题 二进制中1的个数 在O(1)时间删除链表结点 调整数组顺序使奇数位于偶数前面 反转链表 合并两个排序的链表 树的子结构 二叉树的镜像 顺时针打印矩阵 栈的压入、弹出序列 二叉搜索树的后序遍历序列 二叉树中和为某一值的路径 数组中出现次数超过一半的数字 最小的k个数 连续子数组的最大和 第一个只出现一次的字符 两个链表的第一个公共结点 链表中环的入口结点 二叉树的镜像 跳台阶 变态跳台阶 矩形覆盖 从上往下打印二叉树 二叉搜索树的第K个结点 五、准备过程中的注意事项1.心理压力大。怕面试，面试怕被怼，一直逃避。面试是一个会上瘾的东西，刚开始几场会比较难受，但不用怕，一个优秀的面试官会让你有一个舒适的面试体验，而且面试是一个检验自己水平的过程。刚开始可以选择小公司，即使面的不好也没事，面上了也不一定去，放轻松。 2.沉迷学习，无法自拔。秋招已经开始了，自己总想着还没准备好，想把所有的东西都学完之后再去投。参考过秋招的人都知道，知识是永远学不完的，永远没有准备好的那一刻，当你能把简历写出来的时候就开始投吧。面试不是你很厉害就一定能过的，也有运气成分在里面，而且边面试边总结会成长很快的。 3.无论学习理论，项目，还是算法，一定要边学边总结。光输入看似都会了，输出才是王道，不然脑子依然一盘散沙，东拼西凑。面试之前这些平时总结的内容就是你的杀手锏。 4.怕理论懂太多，实操太少。通过以上内容，你会发现我一直强调理论性的东西，无论是项目的学习或者是语言。在校生本来就是以理论分高低，大家都知道面试问这些，但为什么总有人回答不上来。实操的话自己在学校敲的跟公司比起来都是小儿科，都得重新学，重要的是先拿到offer。学会把面试和日常学习区分开。 5.一定要注重简历上的项目。前面提到，简历没有相关项目去支撑你求职的岗位，即使简历写自己的理论多么强，基础多么扎实都是很苍白无力的。这点我在面阿里的时候吃过亏，前几天学习群的一个小兄弟也吃了这个亏。企业说注重理论基础是建立在有项目的基础上，而不是只有理论基础。 6.在简历的排版和内容上要好好做文章。正常的面试都是从自我介绍开始，然后面试从上到下浏览简历，所以你要把你的优点尽量往前面放，而不是把兴趣爱好，个人技能这种比较虚的东西放第一第二模块，而实习经历，项目经验放最后。 7.实习经历是否影响秋招？理论上是的，有实习经历尤其是大厂实习都会在秋招中有优势的，但这种优势不是绝对性优势。实习的目的也是锻炼你的动手能力，提高你的工程能力，所以只要能把项目搞定，问题不是很大。但是建议你还是多面试，项目经历可以补，面试经验补不了，终归要出去试试水的，所以要多面试。 8.为什么零基础的人学完基础就马上学习项目？我在校园招聘的时候，打印了10个简历，投了10家，全都拿了offer，当然都是小公司。面试问什么呢？面向对象的概念，Java的特点等等这些极其基础的，剩下的都是围绕着项目问。有些公司面试都没有直接说有项目那就好办了，接着问什么时候能上班，要现场给offer。案例1的人就是我，简历有两个分布式项目和一个大数据项目。所以我经常跟那些担心找不到工作的同学说，只要你把项目鼓捣明白，总有公司会要你的，就是大和小的问题。 六、针对简历复习一直强调把简历写好，那么怎么针对简历去复习？ 1.面试前夕，打开简历，拿一张白纸，把自己当成面试官，手撸思维导图。从自我介绍开始，然后就是项目介绍，其次就是自己负责的部分以及项目难点。 2.技术面试正常两个部分，一个基础，另一个项目技术栈。基础就是网络，数据结构，算法这些，这些是无论你简历上写不写都问的。其次就是你简历描述的技术栈。 3.正常面试官会问你在项目中做了什么，然后以这个为点切入进去。 举个例子：我在项目中用了多线程，提高了读取效率。那么项目官肯定接着，你如何创建多线程的？我回答：线程池。那你知道创建线程有哪些方法吗？有哪些线程池吗？怎么保证线程安全呢？等等。 如果你项目中的问题会把自己问死，也就是挖坑，那我建议你换个。这部分写的好就是给自己开路，弄不好就自己填坑了。 4.项目技术栈来不及复习怎么办？打开谷歌搜索一下对应技术栈常问面试题，或者平时多刷牛客网，你就知道哪些题目是高频的。 5.扬长避短。对于不熟的框架，尽量不写简历上，如果写了并且被面试官问到就直接跟他说这个正在学，用的比较少。正常面试官也有数，你负责的部分用到的技术栈他会问的深一些，这块自己掂量一下。 7.针对基础，平时多积累。多整理博客也是为了临时突击，像网络，数据库，操作系统，问来问去也是那几题。多看面经几十遍，不懂原理也能吟。 8.针对技术框架，除了基本原理之外，也要准备应用场景。这块对应届生来说要求不会很高，社招的话要整理每个原理的应用场景，相对来说会细一点，源码加分。 9.针对算法。算法是贯彻在日常学习的，我刷算法的策略就是理论先上，其次代码，最后优化。是把所有的算法先刷一遍理论，第二遍再回头代码哦，也都有整理思路的。当然，也要准备常用算法，快排，冒泡的手撸代码。 大部分还是吹吹思路就可以了，所以我先前面提到了先刷实现思路。 10.公司面试题优先。去牛客、看准或拉钩查对应公司的面试题，这个命中概率比较大。 11.公司产品业务准备，最好也看看竞品，让面试官刮目相看。之前面了一家腾讯系的，从它的融资开始讲。 12.面试官正常从上到下看简历，记得布好局。自己面试自己的时候多想想怎么把上面的知识点不经意的串到你熟悉的知识点。 为什么说不经意呢？要是你直接跟面试官说，我这个框架不熟，对***比较熟，有点尴尬的。所以要不经意的。 当面试官问你hashmap原理的时候，比如说你多线程比较熟，你最后一句提一下它是线程不安全的。又或者你数据结构比较厉害，那就说它是红黑树。又或者你对Lambda，JDK1.8一些特性比较熟，那就可以说它是在JDK1.8优化的。 平时还是得多整理，面试之前复习一手博客，一手面经，一手面试的思维导图。 最后说一句：抓住学生红利期，无论机会还是精力都有可能在巅峰时期。 来源：大数据肌肉猿（ID：BigData-BigMuscle） （完）]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用GitHub+Hexo搭建这个博客平台]]></title>
    <url>%2F62ffb8b5.html</url>
    <content type="text"><![CDATA[一、为什么要写博客 当自己主动学习，主动思考其效率和对个人的提升无疑是高于被动接受的。然而使你提高最大的是主动说出自己认知，把自己的知识和理解传达给他人，这种方式是对你提升无疑是最显著的。 引用《码农翻身》里的一段话： 对自己狠一点，开始写作吧。 自己心里觉得对一个技术点已经掌握了，但是当我试图给别人讲述的时候，发现并不能轻松自如、深入浅出地讲出来，这就说明了一个问题：自以为掌握了，其实并没有真正掌握。 为什么要有这门技术、这门技术解决了什么问题，然后才是这门技术是怎么使用的。 整理资料和思考的过程是很珍贵的，只有这样才能把信息变成自身的知识。不写出来，很容易放弃深度思考。 我们已经进入了一个碎片化的时代，我们的大脑已经养成了碎片化的习惯，一天不看碎片化的信息就觉得不舒服，这样下去会慢慢的丧失深度思考的能力。写作会逼着你去思考，梳理知识体系，防止自己被碎片化所填满。 最后，能够坚持的人才更有可能成功！ 为什么你要写博客？——陈素封 二、为什么使用GitHub+Hexo 我很喜欢掘金的风格，里面也有很多大牛，但是因为没有文章分类，只好作罢。CSDN是很多人的入门博客，但是不屏蔽广告完全没法看。简书也不错，但是个人感觉总少点技术氛围。其他博客平台没有使用过，不作评论。至于为什么选择GitHub+Hexo，可能出于成就感吧，而且给我的感觉完全像一张白纸可以在上面任意发挥，而且文章有分类、没有广告、风格很简约，喜欢，所以选择这个平台。 至于其他平台的评论，参看这篇文章：程序员可以选择哪些平台写技术博客？，如果提示无法访问，使用搜狗微信平台搜索文章。 三、准备环境1.关于Hexo、Node.jsHexo的工作机制 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 Hexo基于Node.js，将/source文件夹下的资源(文章、图片、模板)，按照预定的配置文件，转换成静态页面放置到/public目录下。如果需要预览或者部署，hexo会把public作为web目录处理。具体的细节可以通过实践接下来的步骤，来逐渐明晓。 Hexo 特点 支持Markdown: 支持Markdown意味着你可以把经历从排版中解放出来 轻量: 无需拥有后台及数据库，专心写好你的文章 一键部署: 可以通过Git或者ftp来将生成的静态页面部署到服务器或者主机空间中 插件丰富: 丰富的插件可以满足你的各种需求 Node.js Node.js是一个基于Chrome V8引擎的JavaScript运行环境，为我们的Hexo提供js脚本的运行环境。而npm则 是一个JavaScript的包管理工具。主流的很多语言都会有自己的包管理器，Hexo官网教程中使用的是npm。 优势： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等。 博客搭建过程 一个博客的搭建过程分为三步： 编写：包含内容的书写与格式的配置 构建：从编写的原始内容生成可发布的最终内容 发布：让待发布的内容对读者可见 依托于博客平台（如博客园、新浪博客等）发布内容的用户只需要关注编写部分，但要搭建一个独立的个人博客则以上三方面都需要关心。幸运的是，现在有大量的工具帮助我们简化这个过程：丰富的 Markup 语言简化了编写；强大的静态站点生成器简化了构建；友好的托管平台简化了发布。 这个博客的诞生也得益于这些工具： 编写：使用 Markdown，内置大量层级、列表、超链接、代码等的简便语法支持 构建：使用 Hexo，几条命令完成生成、预览、发布步骤 发布：使用 GitHub Pages 进行托管，方便又免费 2.准备工作（1）有一个Github账户 （2）安装Node.js Node.js官网下载LTS版本，并安装，配置环境变量，在命令行中通过查看版本。 （3）安装Git Git官网下载，安装，配置环境变量，使用git –version查看是否安装成功。 （4）注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的。 3.设置使用ssh提交到Github Pages设置用户名和邮箱 初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are. 你需要运行命令来配置你的用户名和邮箱： 12$ git config --global user.name "yourName"$ git config --global user.email "your_email@example.com" 注意：引号内请输入你自己设置的名字，和你自己的邮箱。此用户名和邮箱是git提交代码时用来显示你身份和联 系方式的，并不是github用户名和邮箱。 git使用ssh密钥 git支持https和git两种传输协议。相应的，github分享链接时会有两种协议可选：git格式和https格式。使用https协议，每次pull, push都会提示要输入密码。使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦。 （1）生成密钥对 大多数 Git 服务器都会选择使用 SSH 公钥来进行授权，SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。 首先需要检查你电脑是否已经有 SSH key 运行 git Bash 客户端，输入如下命令，看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。 12$ cd ~/.ssh$ ls （2）创建一个 SSH key，直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)： 1$ ssh-keygen -t rsa -C "your_email@example.com" 添加公钥到你的远程仓库（github） （1）查看你生成的公钥： 1$ cat ~/.ssh/id_rsa.pub （2）登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key （3）然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 （4）验证 1$ ssh -T git@github.com 如果看到 1Hi helloliwen! You've successfully authenticated, but GitHub does not provide shell access. 恭喜你，你的设置已经成功了。 修改git的remote url 在hexo目录下，使用命令 git remote -v 查看你当前的 remote url 123$ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push) 如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议），你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url。 复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。 1git remote set-url origin git@github.com:someaccount/someproject.git 然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。 然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了。 4.创建仓库 新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 四、Hexo博客安装使用1.安装hexo（1）首先需要知道两个配置文件，需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 Hexo配置文件：hexo/_config.yml NeXT主题配置：hexo/themes/next/_config.yml （2）安装hexo 1npm install hexo-cli -g （3）选择一个目录作为hexo站点目录，然后进入目录，执行以下命令初始化： 1hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： （4）生成并启动服务 12hexo g #生成 或 hexo generate hexo s #启动本地服务器 或者 hexo server，这一步之后就可以通过http://localhost:4000查看了 （5）更新hexo 1npm update -g hexo （6）Windows下npm安装Hexo失败的解放方案 因为国外源网速不好的原因，安装hexo失败，可以采用如下方案： 12345678# 添加淘宝源npm install -g cnpm --registry=https://registry.npm.taobao.org# nrm类似包管理器cnpm install nrm -gnrm ls# 使用淘宝nrm use taobaonpm install -g hexo-cli 参考：(node.js)使用淘宝镜像安装hexo失败 2.安装主题（1）安装主题NexT（当然还有很多其他主题，可以去选择自己喜欢的主题：官方主题，本人选择NexT） 1git clone https://github.com/iissnan/hexo-theme-next themes/next （2）启用主题 打开Hexo配置文件：hexo/_config.yml，修改 1theme: next （3）设置语言 hexo/_config.yml 1language: zh-Hans （4）更新主题 cd 到主题文件夹，执行命令（需要隐藏的.git文件夹没有被删除） 1git pull 3.创建博客及常用命令12hexo new "文章名" #新建文章hexo new page "页面名" #新建页面 那么hexo new &#39;postName&#39;命令和hexo new page &#39;postName&#39;有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; 生成如下： 最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 常用命令及缩写 123456789hexo cl = hexo clean # 清除缓存hexo n = hexo new # 新建文章hexo g = hexo generate # 生成静态页面至public目录hexo s = hexo server # 启动服务hexo d = hexo deploy # 部署到GitHubhexo h = hexo help # 查看帮助hexo v = hexo version #查看Hexo的版本#会根据gulpfile.js中的配置，对public目录中的静态资源文件进行压缩。hexo g &amp;&amp; gulp 组合命令： 123hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo dhexo s -g #生成并本地预览hexo d -g #生成并上传 4.部署 上传之前：在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 首先安装扩展文件 1npm install hexo-deployer-git --save 其次需要配置Hexo配置文件：hexo/_config.yml 1234567891011#正确写法deploy: type: git repo: git@github.com:cczeng/cczeng.github.io.git #这里的网址填你自己的，中间有空格要注意 branch: master #错误写法deploy: type: github repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master 接下来就是使用Hexo部署到我们的Github仓库上 1hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 接下来等待几分钟就可以打开浏览器，输入：https://username.github.io就可以看到博客了。 5.常见问题（1）如何让博文列表不显示全部内容：在合适的位置加上&lt;!--more--&gt;即可 （2）电脑重装了系统/多台电脑写博客？那就赶紧戳这里：使用hexo，如果换了电脑怎么更新博客？ （3）想要给网站添加图片？方式一：使用图床。国内的有：微博图床、阿里云OSS、腾讯云COS、七牛云。具体可以查看这里：嗯，图片就交给它了。方式二：在根目录 source 下建立一个文件夹，加入取名叫upload-images，把图片放在这个文件夹下，然后在博客中连接就是：/upload-images/图片名，执行hexo g的时候此文件夹自动生成到public中。 五、Hexo配置1.基本信息配置基本信息包括：博客标题、作者、描述、语言等等。打开_config.yml，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 其他配置可参考站点配置 2.设置头像及网站的icon首先把图片放在source/images目录下，并修改配置文件themes/next/_config.yml 12avatar: /images/avatar.jpgfavicon: /images/favicon32.ico 3.Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 themes/next/_config.yml 找到Scheme Settings 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 4种风格大同小异，本人用的是Pisces风格，你们可以选择自己喜欢的风格。 4.菜单设置刚开始默认的菜单只有首页和归档两个，修改菜单设置文件： themes/next/_config.yml 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 #about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 需要哪个菜单取消注释就好了。关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题文字可以去themes/next/languages/zh-Hans.yml中参考或修改。||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 5.侧栏设置侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等。打开 themes/next/_config.yml 找到sidebar字段 1234567891011121314sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 6.添加标签页面新建页面： 1hexo new page tags 设置页面（编辑 source/tags/index.md）： 123456---title: tagsdate: 2018-09-12 10:30:31type: &quot;tags&quot;comments: false--- 修改菜单（编辑 themes/next/_config.yml）： 12menu: tags: /tags 7.添加分类页面新建页面： 1hexo new page categories 设置页面（编辑 source/categories/index.md）： 12345---title: categoriesdate: 2018-09-12 10:32:08type: &quot;categories&quot;--- 修改菜单（编辑 themes/next/_config.yml）： 12menu: categories: /categories/ 使用： 1234567---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端 #一级分类 - jQuery #二级分类--- scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你 自己的需求添加一些默认值。打开scaffolds/post.md文件，在tages:上面加入categories:，保存后，之后执行 hexo new 文章名命令生成的文件，页面里就有categories:项了。 123456title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: tags: keywords: description: 8.修改二级分类符号二级分类使用 1234categories: - 笔记- 题解- t themes\next\layout_macro\post.swig 123&#123;% if cat_length &gt; 1 and loop.index !== cat_length %&#125; &#123;&#123; __(&apos;symbol.comma&apos;) &#125;&#125;&#123;% endif %&#125; __(‘symbol.comma’)就是二级分类所使用的符号，具体定义在themes\next\languages\zh-Hans.yml 1234symbol: comma: &apos;， &apos; period: &apos;。 &apos; colon: &apos;：&apos; 9.站内搜索功能 hexo-generator-searchdb 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 hexo-generator-search 安装 hexo-generator-search 插件 1$ npm install hexo-generator-search –save 配置站点文件_config.yml: 1234# 站内搜索search: path: search.xml field: post 配置主题文件_config.yml: 12local_search: enable: true 10.修改字体大小和字体 字体大小 修改文件：\themes\next\source\css\ _variables\base.styl 1$font-size-base 字体 全局字体：\themes\next_config.yml 1family: Lato 字体文件：\themes\next\source\css_variables\base.styl 123$font-family-chinese = "PingFang SC", "Microsoft YaHei"$font-family-base = $font-family-chinese, sans-serif$font-family-base = get_font_family('global'), $font-family-chinese, sans-serif if get_font_family('global') 参考：Hexo博客之改字体 11.设置文章字体的颜色、大小如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color="#FF0000"&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color="#FF0000"&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 12.文字居中显示1&lt;center&gt;这一行需要居中&lt;/center&gt; 13.显示文章更新时间 在文章列表中我们一般都能看的文章的发布时间。对于一些文章来说，比如涉及到文章中的内容过期，或者软件的升级等等，我们都会进行一些修改。这种情况下，我们就像把文章的更新日期也显示处理，也能让读者看的我们写的之前的文章也是有更新的，不会过时的。 显示更新日期 在 Next 主题下添加显示更新时间非常简单，找到themes/next/_config.yml的 post_meta部分： 123456# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true 将 updated_at: false 修改为 updated_at: true 即可。通过 hexo s -g 预览，可以看到已经自动添加上了更新日期。 自定义显示更新日期 对于某些特殊的文章，我们也想能够自定义这个更新的日期。当然，更改起来也非常的简单，Hexo默认就支持更新日期的配置。在每一篇文章的 Front-matter 部分，只要添加 updated 参数即可。 1234---date: 2017-05-24 22:07:58updated: 2017-12-01 10:35:18--- 14.去掉文章目录标题的自动编号 我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开themes/next/_config.yml，找到 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 15.使用gulp压缩资源在站点执行以下命令 12$ npm install gulp -g$ npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save 然后查看gulp的安装版本 123$ gulp -vCLI version: 2.2.0Local version: 4.0.2 如果gulp是3.X的版本，由于函数的写法不同，所以以前的部分博客使用了以下写法，导致报错： 1234// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html', 'minify-css', 'minify-js']); 错误：AssertionError: Task function must be specified。 gulp4.x本部请在在博客根目录新建gulpfile.js文件来编写gulp task对应的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) .pipe(gulp.dest('./public'));&#125;);// 压缩jsgulp.task('minify-js', function() &#123; return gulp.src('./public/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片gulp.task('minify-images', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public/images'))&#125;);// 默认任务gulp.task('default', gulp.parallel( 'minify-html','minify-css','minify-js','minify-images')); 其中：gulp.parallel()是gulp4中的新写法。 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 参考： 运行gulp项目报错：AssertionError: Task function must be specified。 利用gulp对Hexo博客压缩并一键之部署 hexo 优化之——使用 gulp 压缩资源 16.设置一键部署在package.json中加入如下script 12345"scripts": &#123; "push": "hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d"&#125; 然后在部署的时候只需要运行 1$ npm run push 17.文章置顶 Hexo博客中，默认的情况是按照时间倒序来排列的，即新发布的文章排在前面。虽然有一种很简单的方法，就是更改文章的发布时间到一个“未来”的时间点，这样虽然能让文章一直置顶，但是给人的体验和感觉是非常不好的。今天介绍一种非常简单而且体验上也非常好的方法。 安装node插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 添加标记 在需要置顶的文章的 Front-matter 中加上 top: true（top 的值可以是 true，也可以是 n，n 越大代表级别越高） 即可。比如： 123---top: true--- 设置置顶标志 打开：/themes/next/layout/_macro/post.swig目录下的文件，定位到 &lt;div class=&quot;post-meta&quot;&gt; 标签下，插入如下代码： 12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 18.鼠标点击小红心的设置 将 love.js 文件添加到\themes\next\source\js\src文件目录下。修改\themes\next\layout\_layout.swing文件， 在文件的后面、标签之前添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 19.背景的设置 将 particle.js文件添加到\themes\next\source\js\src文件目录下。修改\themes\next\layout\_layout.swing文件， 在文件的后面、标签之前添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; 20.开启阅读进度记录themes/next/_config.yml 12345678910111213141516171819# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 自动将页面滚动到&lt;!-- more --&gt;标记下的地方。scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.# 自动保存每篇文章或页面上一次滚动的地方。save_scroll: true# Automatically excerpt description in homepage as preamble text.# 自动在首页对文章进行摘要描述作为前言文本。excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 不推荐使用自动摘要。# 请在文章中使用&lt;!-- more --&gt;标志来精确控制摘要长度。auto_excerpt: enable: true length: 200 21.添加文章字数统计一般为了让读者大概估计阅读文章的时间，有的文章在头部会显示总的字数统计。 启用字数统计 首先安装一个依赖插件： 1npm i --save hexo-wordcount 然后修改themes/next/_config.yml中的 post_wordcount 部分： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true //底部是否显示“总字数”字样 wordcount: false //文章字数统计 min2read: false //文章预计阅读时长（分钟） totalcount: false //网站总字数，位于底部 separated_meta: true //是否将文章的字数统计信息换行显示 22.使用LeanCloud添加文章阅读次数统计参考：为NexT主题添加文章阅读量统计功能 2019年6月20日，LeanCloud主站访问异常，统计的api访问失效：https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js，导致博客加载非常缓慢。最后替换域名为：https://c.lcfile.com/static/js/av-core-mini-0.6.4.js，把js下载到本地，按照参考博客更改配置，博客加载缓慢问题才得以解决。如果觉得出现这种问题非常麻烦，可以使用不蒜子统计文章阅读次数。 官方说明： 我们监测到从今天（06/20）下午开始各个地区陆续出现部分网络无法解析华北节点的 api.leancloud.cn 以及 *.lncld.net 域名的问题。通过和我们的域名注册商阿里云沟通，得知他们接到有关部门行政命令将一批域名设置为 ClientHold 状态，其中包括 leancloud.cn 和 lncld.net，但是没有可执行的其它信息可以提供给我们。目前我们仍在和阿里云沟通中。 参考：关于 LeanCloud 国内域名解析问题的情况更新（6 月 21 日） 解决：Hexo阅读量api.leancloud.cn解析失败 23.使用不蒜子统计访问次数站点访问计数有名的就是不蒜子 - 极简网页计数器，使用起来非常方便。 主题集成步骤 其实，next主题已经集成不蒜子统计工具。但是因为主题使用的旧的域名解析，需要更换过来。 更换域名。打开themes/next/layout/_third-party/analytics/busuanzi-counter.swig，更换域名： &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 更换为： &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 更改配置 打开主题配置文件themes/next/_config.yml，修改 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: false site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访客数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer: 次阅读 官网安装步骤 安装脚本。打开 themes/next/layout/_partial/footer.swig，添加脚本： 12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 显示站点总访问量 themes/next/layout/_partial/footer.swig 要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 显示单页面访问量 要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 123&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 备注：代码中文字是可以修改的，只要保留id正确即可。 24.绑定域名使用hexo+github搭建免费个人博客详细教程 25.SEO优化 SEO优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些SEO还是有必要的。但是请注意，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名。谷歌对此没有限制。 首先修改站点URL _config.yml 1url: https://helloliwen.github.io 添加 sitemap 插件 安装 hexo-generator-sitemap 插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 配置（编辑 _config.yml）： 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 注意：这个地方的空格要符合语法规范！ 提交sitemap。参考next主题官方解答：添加 Google Webmaster tools 验证 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml。其中sitemap.xml适 合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。 其次，在robots.txt中添加下面的一段代码： 12Sitemap: &lt;your-domain-name&gt;/sitemap.xmlSitemap: &lt;your-domain-name&gt;/baidusitemap.xml 参考这篇文章：hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌） 提交sitemap.xml 添加蜘蛛协议 robots.txt 新建 source/robots.txt： 12345678910111213141516User-agent: *Disallow: /CNAMEDisallow: /READMEAllow: /Allow: /about/Allow: /archives/Allow: /categories/Allow: /tags/Allow: /css/Allow: /images/Allow: /js/Allow: /lib/Sitemap: &lt;your-domain-name&gt;/sitemap.xml Hexo NexT主题首页title的优化 更改文件：\themes\next\layout\index.swig，将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页标题会更符合网站名称 - 网站描述这习惯。 进阶，做了seo优化，把关键词也显示在Title标题里，可改成 1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过chinaz的seo综合查询检查。 其他SEO优化 SEO优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，SEO优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上keyword和描述在代码中，我们应该写出能让浏览器识别的语义化HTML，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置nofollow标签，避免spider爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为spider会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样spider是很有可能爬到我们中的站点的，so…. 网站外链的推广度、数量和质量 网站的内链足够强大 网站的原创质量 网站的年龄时间 网站的更新频率（更新次数越多越好） 网站的服务器 网站的流量：流量越高网站的权重越高 网站的关键词排名：关键词排名越靠前，网站的权重越高 网站的收录数量：网站百度收录数量越多，网站百度权重越高 网站的浏览量及深度：用户体验越好，网站的百度权重越高 参考： HEXO SEO 高级优化 hexo高阶教程：SEO优化、代码同时托管github和coding、多终端编辑hexo博客、使用gulp压缩你的代码、增加七牛图床 26.添加链接持久化 SEO搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于SEO，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文。 hexo 默认的链接是http://xxx.yy.com/2013/07/14/hello-world这种类型的，这源于站点配置文件config.yml里的配置: permalink: :year/:month/:day/:title/。这种默认配置的缺点就是当我们创建的博文名包含中文的名的时候，url 链接地址经常会变成一串很长的难以理解的字符串，不利于博文的链接分享，以及搜索引擎搜索，另外就是年月日都会有分隔符。我们可以让 url 链接持久化来解决这个问。 （1）安装hexo-abbrlink插件 1$ npm install hexo-abbrlink –save （2）修改站点配置文件_config.yml：permalink: post/:abbrlink.html 添加 abbrlink: 123456permalink: post/:abbrlink.html # :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults: # 永久链接中个部分的默认值# abbrlink config 需安装插件hexo-abbrlinkabbrlink: alg: crc32 # 算法： crc16(default) and crc32 rep: hex # 进制： dec(default) and hex 27.添加评论系统Hexo博客(14)添加来必力评论系统 28.开启打赏功能编辑 themes/next/_config.yml： 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 六、其他1.自己安装插件一览123456789101112131415161718192021222324$ npm list --depth 0hexo-site@0.0.0 D:\java\hexo+-- gulp@4.0.2+-- gulp-htmlclean@2.7.22+-- gulp-htmlmin@5.0.1+-- gulp-imagemin@5.0.3+-- gulp-minify-css@1.2.4+-- gulp-uglify@3.0.2+-- hexo@3.7.1+-- hexo-abbrlink@2.0.5+-- hexo-autonofollow@1.0.1+-- hexo-deployer-git@0.3.1+-- hexo-generator-archive@0.1.5+-- hexo-generator-baidu-sitemap@0.1.5+-- hexo-generator-category@0.1.3+-- hexo-generator-index@0.2.1+-- hexo-generator-index-pin-top@0.2.2+-- hexo-generator-searchdb@1.0.8+-- hexo-generator-sitemap@1.2.0+-- hexo-generator-tag@0.2.0+-- hexo-renderer-ejs@0.3.1+-- hexo-renderer-marked@0.3.2+-- hexo-renderer-stylus@0.3.3`-- hexo-server@0.3.3 更新插件 1npm update 2.关于npmnpm小知识 npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）。使用npm安装插件：npm install &lt;name&gt; [g] [--save -dev] &lt;name&gt;:node 插件名称 -g:全局安装，会在node安装的根目录下载对应的包，在计算机的任何文件都可以使用该插件，默认的node安装目录是：C:\Users\Administrator\AppData\Roaming\npm;如果不带该属性，将会安装在当前目录，下载安装包的位置是当前目录的node_modules文件夹 --save：将配置信息保存在node项目配置文件package.json中 -dev：保存至package.json的devDependencies节点，如果没有该属性，该插件将会被保存至dependencies节点，devDependencies和dependencies有什么区别呢？其实从名字就应该可以看出来两者的区别，devDependencies中dev是development（开发）的缩写，dependencies是依赖的意思。所以 dependencies 是程序正常运行所需要安装的依赖，而devDependencies是开发所需要的依赖，比如一些单元测试的包~ 为什么要保存至package.json？因为我们使用node的时候需要很多的包，所以我们将我们的配置信息，也就是我们需要包的名称等其他信息保存至一个文件中，如果说其他开发者就可以直接使用一个命令就可以安装和我们相同的配置，这个命令就是npm install，就可以下载package.json 下所有需要的包。npm install --production则只下载dependencies下的包 使用npm卸载插件：npm unstall &lt;name&gt; [-g] [--save-dev] 在npm中要卸载插件不是将文件夹删除就可以了，因为你的配置信息还在package中，所以要使用npm unstall &lt;name&gt; [-g] [--save-dev] 命令 删除全部插件:rimraf node_modules（首先你需要先安装rimraf 插件） 更新npm插件：npm update &lt;name&gt; [g] [--save-dev] 使用cnpm 什么是cnpm呢，大家都知道，由于不可描述原因，我们访问国外的资源有时候的速度，大家懂的，所以淘宝除了一个npm镜像，服务器就在中国。c可以理解为China（应该可以这样理解吧）,cnpm使用方法和npm完全相同，只需将npm全部换成cnpm就可以。本文都是使用的npm，如果想要尝试cnpmde的麻烦自行替换~ 这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 cnpm 官网地址：npm.taobao.org；安装命令为npm install cnpm -g --registry=https://registry.npm.taobao.org 注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误； 3.参考 官网 Hexo NexT 博客搭建 git使用ssh密钥 github设置添加SSH 使用hexo+github搭建免费个人博客详细教程 我是如何利用Github Pages搭建起我的博客，细数一路的坑 Hexo搭建博客教程 主题配置 Hexo 使用入门 Hexo的Next主题详细配置 动动手指，NexT主题与Hexo更搭哦（基础篇） hexo之next主题优化整理 SEO优化 让Google搜索到搭建在Github Pages上的博客 动动手指，不限于NexT主题的Hexo优化（SEO篇） Markdow语法 Markdown——入门指南 Markdown语法汇总 （完）]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用hexo，如果换了电脑怎么保留配置和更新博客]]></title>
    <url>%2F870ed150.html</url>
    <content type="text"><![CDATA[思路还是使用git的分支来管理，@直上云霄的回答清晰明了，但是需要使用两个文件夹，而且两个文件夹会出现以后新建博客同步问题，除非使用新文件夹进行编辑、发布博客。而@CrazyMilk的回答步骤清楚，但是不够清晰。所以合并@直上云霄 和 @CrazyMilk 的回答，使用目前已有的hexo博客目录来管理。 一.备份1.在github上新建一个hexo分支 2.在仓库的设置里面，设置默认分支为hexo 3.在其他目录，打开git bash，克隆hexo仓库到本地，拿到隐藏的.git文件夹 1git clone -b hexo &lt;github的https或者ssh的URL&gt; 4.复制这个隐藏的.git文件夹到你使用hexo博客的目录下，同时删除博客主题，比如next下面的.git文件夹(因为git不能嵌套上传)，然后你之前克隆hexo仓库的文件夹就可以删除了。 5.上传 123git add .git commit –m &quot;你的备注&quot;git push origin hexo 二、编辑博客在新建博客之后 1.先备份到hexo分支 123git add .git commit –m &quot;你的备注&quot;git push origin hexo 2.再进行部署 1hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 三、更换电脑1.安装git 2.设置git全局邮箱和用户名 3.配置SSH Key 4.克隆github分支hexo到本地文件夹 5.安装nodejs 6.安装hexo(不需要初始化) 参见@直上云霄的回答 来源：使用hexo，如果换了电脑怎么更新博客？ 异地同步博客内容 现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？要解决这个问题，首先我们要清楚我们博客文件的组成： node_modules public scaffolds source themes _config_yml db.json package.json .deploy_git 以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？ 我们可以看下github上的tengzhangchao.github.io项目，发现里面只有Public目录下的内容。也就是说，我们博客上呈现的内容，其实就是public下的文件内容。那么这个Pulic目录是怎么生成的呢？ 一开始hexo init的时候是没有public目录的，而当我们运行hexo g命令时，public目录被生成了，换句话说hexo g命令就是用来生成博客文件的（会根据_config.yml，source目录文件以及themes目录下文件生成）。同样当我们运行hexo clean命令时，public目录被删除了。 好了，既然我们知道了决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成Public目录的文件即可。 以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git 同步的方式有很多种，可以每次更新后都备份到一个地址。我采用github去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。 同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？ 前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧： 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙) 我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。 git clone 我们备份的项目，生成一个文件夹，如：MyBlogData 将MyBlog里面的node_modules、scaffolds文件夹复制到MyBlogData里面。 做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo ghexo d试试，如果会报错，则往下看。 这是因为.deploy_git没有同步，在MyBlogData目录内运行:npm install hexo-deployer-git –save后再次推送即可 总结流程：当我们每次更新MyBlog内容后，先利用hexo将public推送到github，然后再将其余必须同步的文件利用git推送到github。 创建Hexo分支创建两个分支：master 与 Hexo,并将Hexo设置为默认分支（这个Hexo分支就是存放我们源文件的分支，我们只需要更新Hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的） 删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件因为有些主题是从git上clone过来的，所以我们要先删除.git缓存文件，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git文件夹被删除后整个文件对应的git仓库状态也会被清空).gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容： 123/.deploy_git/public /_config.yml复制代码 .deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去 初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制 12git initgit remote add origin &lt;server&gt;复制代码 &lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端 将博客源文件上传至Hexo分支依次执行 123git add .git commit -m &quot;...&quot;git push origin hexo复制代码 提交网站相关的文件； 对B电脑进行的操作假设B电脑现在没有我们的源文件 1234git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。git fetch --allgit reset --hard origin/master复制代码 日常改动平时我们对源文件有修改的时候记得先pull一遍代码，再将代码push到Hexo分支，就和日常的使用git一样~ 依次执行git add .、git commit -m “…”、git push origin Hexo指令将改动推送到GitHub（此时当前分支应为Hexo）； 然后才执行hexo g -d发布网站到master分支上。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之五：分支限界法]]></title>
    <url>%2F1f3dcc68.html</url>
    <content type="text"><![CDATA[一、基本描述​ 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 （1）分支搜索算法​ 所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。 ​ 选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。 1）FIFO搜索 2）LIFO搜索 3）优先队列式搜索 （2）分支限界搜索算法二、分支限界法的一般过程​ 由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。 ​ 分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 ​ 分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。 三、回溯法和分支限界法的一些区别​ 有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？ 回溯法和分支限界法的一些区别： 方法对解空间树的搜索方式 存储结点的常用数据结构 结点存储特性常用应用 回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解 分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解 来源：五大常用算法之五：分支限界法]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之四：回溯法]]></title>
    <url>%2Fb72db516.html</url>
    <content type="text"><![CDATA[1、概念 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 2、基本思想 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 3、用回溯法解题的一般步骤： 针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。 确定结点的扩展搜索规则 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 4、算法框架 问题框架： ​ 设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。 非递归回溯框架 12345678910111213141516171819int a[n],i;初始化数组a[];i = 1;while (i&gt;0(有路可走) and (未达到目标))&#123; // 还未回溯到头 if(i &gt; n)&#123; // 搜索到叶结点 搜索到一个解，输出； &#125;else&#123; // 处理第i个元素 a[i]第一个可能的值； while(a[i]在不满足约束条件且在搜索空间内)&#123; a[i]下一个可能的值； &#125; if(a[i]在搜索空间内)&#123; 标识占用的资源； i = i+1; // 扩展下一个结点 &#125;else&#123; 清理所占的状态空间； // 回溯 i = i –1; &#125;&#125; 递归的算法框架 回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下： 123456789101112131415int a[n];try(int i)&#123; if(i&gt;n) 输出结果; else&#123; for(j = 下界; j &lt;= 上界; j++)&#123; // 枚举i所有可能的路径 if(fun(j))&#123; // 满足限界函数和约束条件 a[i] = j; ... // 其他操作 try(i+1); 回溯前的清理工作（如a[i]置空值等）; &#125; &#125; &#125;&#125; 来源：五大常用算法之四：回溯法]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之三：贪心算法]]></title>
    <url>%2F400f83c6.html</url>
    <content type="text"><![CDATA[一、基本概念： ​ 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。 ​ 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。 ​ 所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 二、贪心算法的基本思路： ​ 1.建立数学模型来描述问题。 ​ 2.把求解的问题分成若干个子问题。 ​ 3.对每一子问题求解，得到子问题的局部最优解。 ​ 4.把子问题的解局部最优解合成原来解问题的一个解。 三、贪心算法适用的问题 ​ 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 ​ 实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。 四、贪心算法的实现框架 ​ 从问题的某一初始解出发； ​ while （能朝给定总目标前进一步） ​ { ​ 利用可行的决策，求出可行解的一个解元素； ​ } ​ 由所有解元素组合成问题的一个可行解； 五、贪心策略的选择 ​ 因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。 六、例题分析 ​ 下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。 ​ [背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。 ​ 要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 ​ 物品 A B C D E F G ​ 重量 35 30 60 50 40 10 25 ​ 价值 10 40 30 50 35 40 30 ​ 分析： ​ 目标函数： ∑pi最大 ​ 约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) ​ （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ ​ （2）每次挑选所占重量最小的物品装入是否能得到最优解？ ​ （3）每次选取单位重量价值最大的物品，成为解本题的策略。 ​ 值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。 ​ 贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。 ​ 可惜的是，它需要证明后才能真正运用到题目的算法中。 ​ 一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。 ​ 对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下： ​ （1）贪心策略：选取价值最大者。反例： ​ W=30 ​ 物品：A B C ​ 重量：28 12 12 ​ 价值：30 20 20 ​ 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ​ （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 ​ （3）贪心策略：选取单位重量价值最大的物品。反例： ​ W=30 ​ 物品：A B C ​ 重量：28 20 10 ​ 价值：28 20 10 ​ 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 来源：五大常用算法之三：贪心算法 comments： 题目的要求是：有7个物品，物品可以分割成任意大小。那么最后一个根据单位价值最大进行选取的贪心策略应该是对了，为什么是错的呢？ 比如我选择了A，然后再从B切下重量为2的物品出来，不就得到了最大价值为30的最优选择了吗？ 是不是题目的要求“物品可以分割成任意大小”给错了。]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法]]></title>
    <url>%2F5dc644dc.html</url>
    <content type="text"><![CDATA[Those who cannot remember the past are condemned to repeat it!——George Santayana 那些记不清过去的人注定要重蹈覆辙！——乔治·桑塔耶拿 一、基本概念 动态规划通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储（在计算机科学中，记忆化是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案），以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 二、基本思想与策略 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 三、适用的情况能采用动态规划求解的问题的一般要具有3个性质： 最优子结构：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。 在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题。比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。 动态规划算法的核心是记住已经求过的解，记住求解的方式有两种： 自顶向下的备忘录法：使用一个n+1大小的数组保存递归过程中的值。fib(n)&rarr;fib(n-1) 自底向上：先计算子问题，再由子问题计算父问题。自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。fib(1)，fib(2)，…，fib(n-1)&rarr;fib(n) 一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好。 四、求解的基本步骤 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。 ​ 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 实际应用中可以按以下几个简化的步骤进行设计： ​ （1）分析最优解的性质，并刻画其结构特征。 ​ （2）递归的定义最优解。 ​ （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 ​ （4）根据计算最优值时得到的信息，构造问题的最优解 五、算法实现的说明 动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： ​ （1）问题的阶段 ​ （2）每个阶段的状态 ​ （3）从前一个阶段转化到后一个阶段之间的递推关系 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 ​ 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 ​ f(i,j)=max{f(i-1,j), f(i-1,j-w[i])+P(i,j)} 六、动态规划算法基本框架123456789101112131415161718for(j=1; j&lt;=m; j=j+1) // 第一个阶段 xn[j] = 初始值; for(i=n-1; i&gt;=1; i--)// 其他n-1个阶段 for(j=1; j&gt;=f(i); j++)//f(i)与i有关的表达式 xi[j]=j=max（或min)&#123;g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])&#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1)&#123; t = t-xi-1[ji]; for(j=1; j&gt;=f(i); j=j+1) if(t=xi[ji]) break;&#125; 七、动态规划经典模型1.线性模型 线性模型的是动态规划中最常用的模型，钢条切割问题就是经典的线性模型。这里的线性指的是状态的排布是呈线性的。【例题1】是一个经典的面试题，我们将它作为线性模型的敲门砖。 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 2.区间模型 区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。 【例题2】给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 3.背包模型背包问题是动态规划中一个最典型的问题之一。由于网上有非常详尽的背包讲解，这里只将常用部分抽出来。 【例题3】有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。 参照： 1.五大常用算法之二：动态规划算法 2.算法-动态规划 Dynamic Programming–从菜鸟到老鸟]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之一：分治算法]]></title>
    <url>%2F7474c898.html</url>
    <content type="text"><![CDATA[一、基本概念 在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… ​ 任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。 二、基本思想及策略 分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 三、分治法适用的情况​ 分治法所能解决的问题一般具有以下几个特征： ​ 1) 该问题的规模缩小到一定的程度就可以容易地解决； ​ 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质； ​ 3) 利用该问题分解出的子问题的解可以合并为该问题的解； ​ 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。 四、分治法的基本步骤分治法在每一层递归上都有三个步骤： ​ step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； ​ step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 ​ step3 合并：将各个子问题的解合并为原问题的解。 它的一般的算法设计模式如下： ​ Divide-and-Conquer(P) if |P|≤n0 then return(ADHOC(P)) 将P分解为较小的子问题 P1 ,P2 ,…,Pk for i←1 to k do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi T ← MERGE(y1,y2,…,yk) △ 合并子问题 return(T) ​ 其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。 五、分治法的复杂性分析​ 一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有： T（n）= k T(n/m)+f(n) ​ 通过迭代法求得方程的解： 递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当 mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 六、可使用分治法求解的一些经典问题 （1）二分搜索 （2）大整数乘法 （3）Strassen矩阵乘法 （4）棋盘覆盖 （5）合并排序 （6）快速排序 （7）线性时间选择 （8）最接近点对问题 （9）循环赛日程表 （10）汉诺塔 七、依据分治法设计程序时的思维过程​ 实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。 1、一定是先找到最小问题规模时的求解方法 2、然后考虑随着问题规模增大时的求解方法 3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。 来源：五大常用算法之一：分治算法]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十五）：线程死锁]]></title>
    <url>%2F11129fd3.html</url>
    <content type="text"><![CDATA[摘要：如题。 什么是死锁？通俗的说，死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重影响。用来描述死锁的问题最有名的场景就是“哲学家就餐问题”。哲学家就餐问题可以这样表述：假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事之一：吃饭或者思考。吃东西的时候他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为只用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐。哲学家从来不交谈，这就跟危险，可能产生死锁，每个哲学家都拿着左手的餐叉永远等右边的餐叉（或者相反）…. 死锁产生的必要条件 互斥条件：进程对锁分配的资源进行排他性使用 请求和保持条件：线程已经保持了一个资源，但是又提出了其他请求，而该资源已被其他线程占用 不剥夺条件：在使用时不能被剥夺，只能自己用完释放 环路等待条件：资源调用是一个环形的链 死锁示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Slf4jpublic class DeadLock implements Runnable &#123; public int flag = 1; //静态对象是类的所有对象共享的 private static Object o1 = new Object(), o2 = new Object(); @Override public void run() &#123; log.info(&quot;flag:&#123;&#125;&quot;, flag); if (flag == 1) &#123; synchronized (o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; log.info(&quot;1&quot;); &#125; &#125; &#125; if (flag == 0) &#123; synchronized (o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; log.info(&quot;0&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DeadLock td1 = new DeadLock(); DeadLock td2 = new DeadLock(); td1.flag = 1; td2.flag = 0; //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。 //td2的run()可能在td1的run()之前运行 new Thread(td1).start(); new Thread(td2).start(); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 上述代码出现死锁原因： 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒 td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定； td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定； td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 确认死锁在真实的环境中，我们发现程序无法执行，并且CPU占用为0，这样就有理由怀疑产生了死锁，但是光怀疑是不行的，我们需要一个实际的验证方法。接下来我们使用jdk提供的工具来检测是否真正发生了死锁。运行上述的代码，并在windows系统中使用cmd进入控制台，输入以下命令： 1jps1 可见控制台输出：我们上边运行的类的类名以及对应的进程ID接下来使用命令获取进程对应线程的堆栈信息： 1jstack 9284 1 分析堆栈信息（提取有用的部分）两个线程都进行了加锁操作（如上图）系统发现了一个Java-level的线程死锁。ok，确认无疑是发生了死锁现象。 避免死锁 注意加锁顺序（这个很好理解，就像上边的例子） 加锁时限（超过时限放弃加锁）实现方式–使用重入锁。关于重入锁可以见我之前的博客：并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock 死锁检测（较难，就像分析上边的线程情况） 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80233899]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十四）：线程池 Executor]]></title>
    <url>%2Ff49ebf6e.html</url>
    <content type="text"><![CDATA[摘要：本文介绍线程池的好处、类图和核心类——ThreadPoolExecutor，以及使用Executor创建线程池。 new Thread的弊端 线程池的好处 线程池类图 线程池核心类-ThreadPoolExecutor 使用Executor创建线程池 new Thread的弊端 每次new Thread 新建对象，性能差 线程缺乏统一管理，可能无限制的新建线程，相互竞争，可能占用过多的系统资源导致死机或者OOM（out of memory 内存溢出），这种问题的原因不是因为单纯的new一个Thread，而是可能因为程序的bug或者设计上的缺陷导致不断new Thread造成的。 缺少更多功能，如更多执行、定期执行、线程中断。 线程池的好处 重用存在的线程，减少对象创建、消亡的开销，性能好 可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。 提供定时执行、定期执行、单线程、并发数控制等功能。 线程池类图 在线程池的类图中，我们最常使用的是最下边的Executors,用它来创建线程池使用线程。那么在上边的类图中，包含了一个Executor框架，它是一个根据一组执行策略的调用调度执行和控制异步任务的框架，目的是提供一种将任务提交与任务如何运行分离开的机制。它包含了三个executor接口： Executor:运行新任务的简单接口 ExecutorService：扩展了Executor，添加了用来管理执行器生命周期和任务生命周期的方法 ScheduleExcutorService：扩展了ExecutorService，支持Future和定期执行任务 线程池核心类-ThreadPoolExecutor参数说明：ThreadPoolExecutor一共有七个参数，这七个参数配合起来，构成了线程池强大的功能。 corePoolSize：核心线程数量 maximumPoolSize：线程最大线程数 workQueue：阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响 当我们提交一个新的任务到线程池，线程池会根据当前池中正在运行的线程数量来决定该任务的处理方式。处理方式有三种：1、直接切换（SynchronusQueue）2、无界队列（LinkedBlockingQueue）能够创建的最大线程数为corePoolSize,这时maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是运行状态的时候，新的任务提交就会放入等待队列中。3、有界队列（ArrayBlockingQueue）最大maximumPoolSize，能够降低资源消耗，但是这种方式使得线程池对线程调度变的更困难。因为线程池与队列容量都是有限的。所以想让线程池的吞吐率和处理任务达到一个合理的范围，又想使我们的线程调度相对简单，并且还尽可能降低资源的消耗，我们就需要合理的限制这两个数量分配技巧： [如果想降低资源的消耗包括降低cpu使用率、操作系统资源的消耗、上下文切换的开销等等，可以设置一个较大的队列容量和较小的线程池容量，这样会降低线程池的吞吐量。如果我们提交的任务经常发生阻塞，我们可以调整maximumPoolSize。如果我们的队列容量较小，我们需要把线程池大小设置的大一些，这样cpu的使用率相对来说会高一些。但是如果线程池的容量设置的过大，提高任务的数量过多的时候，并发量会增加，那么线程之间的调度就是一个需要考虑的问题。这样反而可能会降低处理任务的吞吐量。] keepAliveTime：线程没有任务执行时最多保持多久时间终止（当线程中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交核心线程外的线程不会立即销毁，而是等待，直到超过keepAliveTime） unit：keepAliveTime的时间单位 threadFactory：线程工厂，用来创建线程，有一个默认的工场来创建线程，这样新创建出来的线程有相同的优先级，是非守护线程、设置好了名称） rejectHandler：当拒绝处理任务时(阻塞队列满)的策略（AbortPolicy默认策略直接抛出异常、CallerRunsPolicy用调用者所在的线程执行任务、DiscardOldestPolicy丢弃队列中最靠前的任务并执行当前任务、DiscardPolicy直接丢弃当前任务） corePoolSize、maximumPoolSize、workQueue 三者关系：如果运行的线程数小于corePoolSize的时候，直接创建新线程来处理任务。即使线程池中的其他线程是空闲的。如果运行中的线程数大于corePoolSize且小于maximumPoolSize时，那么只有当workQueue满的时候才创建新的线程去处理任务。如果corePoolSize与maximumPoolSize是相同的，那么创建的线程池大小是固定的。这时有新任务提交，当workQueue未满时，就把请求放入workQueue中。等待空线程从workQueue取出任务。如果workQueue此时也满了，那么就使用另外的拒绝策略参数去执行拒绝策略。 初始化方法：由七个参数组合成四个初始化方法 其他方法： 序号 方法名 描述 1 execute() 提交任务，交给线程池执行 2 submit() 提交任务，能够返回执行结果 execute+Future 3 shutdown() 关闭线程池，等待任务都执行完 4 shutdownNow() 关闭线程池，不等待任务执行完 5 getTaskCount() 线程池已执行和未执行的任务总数 6 getCompleteTaskCount() 已完成的任务数量 7 getPoolSize() 线程池当前的线程数量 8 getActiveCount() 当前线程池中正在执行任务的线程数量 线程池生命周期： running：能接受新提交的任务，也能处理阻塞队列中的任务 shutdown：不能处理新的任务，但是能继续处理阻塞队列中任务 stop：不能接收新的任务，也不处理队列中的任务 tidying：如果所有的任务都已经终止了，这时有效线程数为0 terminated：最终状态 使用Executor创建线程池使用Executor可以创建四种线程池：分别对应上边提到的四种线程池初始化方法 1、Executors.newCachedThreadPool创建一个可缓存的线程池，如果线程池的长度超过了处理的需要，可以灵活回收空闲线程。如果没有可回收的就新建线程。 1234567891011121314151617181920//源码：public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;123456//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 值得注意的一点是，newCachedThreadPool的返回值是ExecutorService类型，该类型只包含基础的线程池方法，但却不包含线程监控相关方法，因此在使用返回值为ExecutorService的线程池类型创建新线程时要考虑到具体情况。 2、newFixedThreadPool定长线程池，可以线程现成的最大并发数，超出在队列等待 1234567891011121314151617181920//源码：public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;123456//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 3、newSingleThreadExecutor单线程化的线程池，用唯一的一个共用线程执行任务，保证所有任务按指定顺序执行（FIFO、优先级…） 123456789101112131415161718192021//源码public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;1234567//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 4、newScheduledThreadPool定长线程池，支持定时和周期任务执行 1234567891011121314151617181920//源码：public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,//此处super指的是ThreadPoolExecutor new DelayedWorkQueue());&#125;12345678//基础使用方法：public static void main(String[] args) &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1); executorService.schedule(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125; &#125;, 3, TimeUnit.SECONDS);//延迟3秒执行 executorService.shutdown();&#125;123456789101112 ScheduledExecutorService提供了三种方法可以使用：scheduleAtFixedRate：以指定的速率执行任务scheduleWithFixedDelay：以指定的延迟执行任务举例： 123456executorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125;&#125;, 1, 3, TimeUnit.SECONDS);//延迟一秒后每隔3秒执行123456 小扩展：延迟执行任务的操作，java中还有Timer类同样可以实现 1234567Timer timer = new Timer();timer.schedule(new TimerTask() &#123; @Override public void run() &#123; log.warn(&quot;timer run&quot;); &#125;&#125;, new Date(), 5 * 1000); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80202114]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十三）：并发容器J.U.C -- 组件FutureTask、ForkJoin、BlockingQueue]]></title>
    <url>%2Fef3705fd.html</url>
    <content type="text"><![CDATA[摘要：本文介绍组件FutureTask、ForkJoin、BlockingQueue阻塞队列。 FutureTask Runnable与Callable对比 Future接口 FutureTask ForkJoin 局限性： 框架核心： 使用方式：（模拟加和运算） BlockingQueue阻塞队列 阻塞情况： 四套方法： 实现类： FutureTaskFutureTask是J.U.C中的类，是一个可删除的异步计算类。这个类提供了Future接口的的基本实现，使用相关方法启动和取消计算，查询计算是否完成，并检索计算结果。只有在计算完成时才能使用get方法检索结果;如果计算尚未完成，get方法将会阻塞。一旦计算完成，计算就不能重新启动或取消(除非使用runAndReset方法调用计算)。 Runnable与Callable对比通常实现一个线程我们会使用继承Thread的方式或者实现Runnable接口，这两种方式有一个共同的缺陷就是在执行完任务之后无法获取执行结果。从Java1.5之后就提供了Callable与Future，这两个接口就可以实现获取任务执行结果。 Runnable接口：代码非常简单，只有一个方法run 123public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125;123 Callable泛型接口：有泛型参数，提供了一个call方法，执行后可返回传入的泛型参数类型的结果。 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125;123 Future接口Future接口提供了一系列方法用于控制线程执行计算，如下： 12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning);//取消任务 boolean isCancelled();//是否被取消 boolean isDone();//计算是否完成 V get() throws InterruptedException, ExecutionException;//获取计算结果，在执行过程中任务被阻塞 V get(long timeout, TimeUnit unit)//timeout等待时间、unit时间单位 throws InterruptedException, ExecutionException, TimeoutException;&#125;12345678 使用方法： 1234567891011121314151617181920public class FutureExample &#123; static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable());//线程池提交任务 log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = future.get();//获取不到一直阻塞 log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125;1234567891011121314151617181920 运行结果：阻塞效果 FutureTaskFuture实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。 1234567public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; ...&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125;1234567 FutureTask支持两种参数类型，Callable和Runnable，在使用Runnable 时，还可以多指定一个返回结果类型。 1234567891011public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;1234567891011 使用方法： 12345678910111213141516171819public class FutureTaskExample &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125;); new Thread(futureTask).start(); log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = futureTask.get(); log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125;12345678910111213141516171819 运行结果： ForkJoinForkJoin是Java7提供的一个并行执行任务的框架，是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架。主要采用的是工作窃取算法，工作窃取算法是指某个线程从其他队列里窃取任务来执行。在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用双端队列来实现工作窃取算法。被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。 局限性：1、任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了。2、我们所拆分的任务不应该去执行IO操作，如读和写数据文件。3、任务不能抛出检查异常。必须通过必要的代码来处理他们。 框架核心：核心有两个类：ForkJoinPool | ForkJoinTaskForkJoinPool：负责来做实现，包括工作窃取算法、管理工作线程和提供关于任务的状态以及他们的执行信息。ForkJoinTask:提供在任务中执行fork和join的机制。 使用方式：（模拟加和运算）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Slf4jpublic class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123; public static final int threshold = 2;//设定不大于两个数相加就直接for循环，不适用框架 private int start; private int end; public ForkJoinTaskExample(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; //如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= threshold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算（分裂算法，可依情况调优） int middle = (start + end) / 2; ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle); ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待任务执行结束合并其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkjoinPool = new ForkJoinPool(); //生成一个计算任务，计算1+2+3+4...100 ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100); //执行一个任务 Future&lt;Integer&gt; result = forkjoinPool.submit(task); try &#123; log.info(&quot;result:&#123;&#125;&quot;, result.get()); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 BlockingQueue阻塞队列主要应用场景：生产者消费者模型，是线程安全的 阻塞情况：1、当队列满了进行入队操作2、当队列空了的时候进行出队列操作 四套方法：BlockingQueue提供了四套方法，分别来进行插入、移除、检查。每套方法在不能立刻执行时都有不同的反应。 Throws Exceptions ：如果不能立即执行就抛出异常。 Special Value：如果不能立即执行就返回一个特殊的值。 Blocks：如果不能立即执行就阻塞 Times Out：如果不能立即执行就阻塞一段时间，如果过了设定时间还没有被执行，则返回一个值 实现类： ArrayBlockingQueue：它是一个有界的阻塞队列，内部实现是数组，初始化时指定容量大小，一旦指定大小就不能再变。采用FIFO方式存储元素。 DelayQueue：阻塞内部元素，内部元素必须实现Delayed接口，Delayed接口又继承了Comparable接口，原因在于DelayQueue内部元素需要排序，一般情况按过期时间优先级排序。 123public interface Delayed extends Comparable&lt;Delayed&gt; &#123; long getDelay(TimeUnit unit);&#125;123 DalayQueue内部采用PriorityQueue与ReentrantLock实现。 1234567public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; private final transient ReentrantLock lock = new ReentrantLock(); private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;(); ...&#125;1234567 LinkedBlockingQueue：大小配置可选，如果初始化时指定了大小，那么它就是有边界的。不指定就无边界（最大整型值）。内部实现是链表，采用FIFO形式保存数据。 123public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);//不指定大小，无边界采用默认值，最大整型值&#125;123 PriorityBlockingQueue:带优先级的阻塞队列。无边界队列，允许插入null。插入的对象必须实现Comparator接口，队列优先级的排序规则就是按照我们对Comparable接口的实现来指定的。我们可以从PriorityBlockingQueue中获取一个迭代器，但这个迭代器并不保证能按照优先级的顺序进行迭代。 12345678910111213141516171819202122232425public boolean add(E e) &#123;//添加方法 return offer(e);&#125;public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator;//必须实现Comparator接口 if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true;&#125;12345678910111213141516171819202122232425 SynchronusQueue：只能插入一个元素，同步队列，无界非缓存队列，不存储元素。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80168980]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十二）：并发容器J.U.C -- AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock]]></title>
    <url>%2F61c20be.html</url>
    <content type="text"><![CDATA[摘要：本文介绍重入锁(ReentrantLock)、读写锁（ReentrantReadWriteLock）、票据锁（StempedLock）以及如何选择锁。 ReentrantLock ReentrantLock与synchronized的区别 ReentrantLock独有的功能 要放弃synchronized？ 如何使用ReentrantLock？ 内置函数（部分） Condition的使用 读写锁：ReentrantReadWriteLock读写锁 票据锁：StempedLock 如何选择锁？ ReentrantLockjava中有两类锁，一类是Synchronized，而另一类就是J.U.C中提供的锁。ReentrantLock与Synchronized都是可重入锁，本质上都是lock与unlock的操作。接下来我们介绍三种J.U.C中的锁，其中 ReentrantLock使用synchronized与之比对介绍。 ReentrantLock与synchronized的区别 可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁 锁的实现：synchronized是基于JVM实现的（用户很难见到，无法了解其实现），ReentrantLock是JDK实现的。 性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自选锁）后，二者的性能差别不大，官方推荐synchronized（写法更容易、在优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞） 功能区别：（1）便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。（2）锁的细粒度和灵活度，ReentrantLock优于synchronized ReentrantLock独有的功能 可以指定是公平锁还是非公平锁，sync只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁） 提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。 提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现，这种机制 ReentrantLock是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。 要放弃synchronized？从上边的介绍，看上去ReentrantLock不仅拥有synchronized的所有功能，而且有一些功能synchronized无法实现的特性。性能方面，ReentrantLock也不比synchronized差，那么到底我们要不要放弃使用synchronized呢？答案是不要这样做。 J.U.C包中的锁定类是用于高级情况和高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需要，或这有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized。相比较这些高级的锁定类，synchronized还是有一些优势的，比如synchronized不可能忘记释放锁。还有当JVM使用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。 如何使用ReentrantLock？1234567891011//创建锁：使用Lock对象声明，使用ReentrantLock接口创建private final static Lock lock = new ReentrantLock();//使用锁：在需要被加锁的方法中使用private static void add() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125;&#125;1234567891011 分析一下源码： 123456789//初始化方面：//在new ReentrantLock的时候默认给了一个不公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125;//也可以加参数来初始化指定使用公平锁还是不公平锁public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125;123456789 内置函数（部分）基础特性： tryLock()：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。 tryLock(long timeout, TimeUnit unit)：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。 lockInterruptbily：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。 isLocked：查询此锁定是否由任意线程保持 isHeldByCurrentThread：查询当前线程是否保持锁定状态。 isFair：判断是不是公平锁… Condition相关特性： hasQueuedThread(Thread)：查询指定线程是否在等待获取此锁定 hasQueuedThreads()：查询是否有线程在等待获取此锁定 getHoldCount()：查询当前线程保持锁定的个数，也就是调用Lock方法的个数… Condition的使用Condition可以非常灵活的操作线程的唤醒，下面是一个线程等待与唤醒的例子，其中用1234序号标出了日志输出顺序 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition();//创建condition //线程1 new Thread(() -&gt; &#123; try &#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;); // 1 condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;); // 4 reentrantLock.unlock(); &#125;).start(); //线程2 new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get lock&quot;); // 2 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; condition.signalAll();//发送信号 log.info(&quot;send signal&quot;); // 3 reentrantLock.unlock(); &#125;).start();&#125;1234567891011121314151617181920212223242526272829 （这里对等待队列不熟悉的，请回顾我的上一篇文章中讲解的AQS等待队列：高并发探索（十一）：并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier）输出过程讲解： 1、线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出1号log2、接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中3、线程2因为线程1释放了锁，拿到了锁，输出2号log4、线程2执行condition.signalAll()发送信号，输出3号log5、condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列,这时线程1并没有被唤醒。6、线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程17、线程1继续执行，输出4号log，并进行unlock操作。 读写锁：ReentrantReadWriteLock读写锁在没有任何读写锁的时候才可以取得写入锁(悲观读取，容易写线程饥饿)，也就是说如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会造成等待获取写锁的线程饥饿。平时使用的场景并不多。 12345678910111213141516171819202122232425262728public class LockExample3 &#123; private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;(); private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock readLock = lock.readLock();//读锁 private final Lock writeLock = lock.writeLock();//写锁 //加读锁 public Data get(String key) &#123; readLock.lock(); try &#123; return map.get(key); &#125; finally &#123; readLock.unlock(); &#125; &#125; //加写锁 public Data put(String key, Data value) &#123; writeLock.lock(); try &#123; return map.put(key, value); &#125; finally &#123; writeLock.unlock(); &#125; &#125; class Data &#123;&#125;&#125;12345678910111213141516171819202122232425262728 票据锁：StempedLock它控制锁有三种模式（写、读、乐观读）。一个StempedLock的状态是由版本和模式两个部分组成。锁获取方法返回一个数字作为票据（stamp），他用相应的锁状态表示并控制相关的访问。数字0表示没有写锁被锁写访问，在读锁上分为悲观锁和乐观锁。 乐观读：如果读的操作很多写的很少，我们可以乐观的认为读的操作与写的操作同时发生的情况很少，因此不悲观的使用完全的读取锁定。程序可以查看读取资料之后是否遭到写入资料的变更，再采取之后的措施。 如何使用？ 1234567891011//定义private final static StampedLock lock = new StampedLock();//需要上锁的方法private static void add() &#123; long stamp = lock.writeLock(); try &#123; count++; &#125; finally &#123; lock.unlock(stamp); &#125;&#125;1234567891011 分析一下源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Point &#123; private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) &#123; long stamp = sl.writeLock(); try &#123; x += deltaX; y += deltaY; &#125; finally &#123; sl.unlockWrite(stamp); &#125; &#125; //下面看看乐观读锁案例 double distanceFromOrigin() &#123; // A read-only method long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁 double currentX = x, currentY = y; //将两个字段读入本地局部变量 if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？ stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁 try &#123; currentX = x; // 将两个字段读入本地局部变量 currentY = y; // 将两个字段读入本地局部变量 &#125; finally &#123; sl.unlockRead(stamp); &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; //下面是悲观读锁案例 void moveIfAtOrigin(double newX, double newY) &#123; // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合 long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁 if (ws != 0L) &#123; //这是确认转为写锁是否成功 stamp = ws; //如果成功 替换票据 x = newX; //进行状态改变 y = newY; //进行状态改变 break; &#125; else &#123; //如果不能成功转换为写锁 sl.unlockRead(stamp); //我们显式释放读锁 stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试 &#125; &#125; &#125; finally &#123; sl.unlock(stamp); //释放读锁或写锁 &#125; &#125; &#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 如何选择锁？1、当只有少量竞争者，使用synchronized2、竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock3、synchronized不会造成死锁，jvm会自动释放死锁。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80058631]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十一）：并发容器J.U.C -- AQS组件CountDownLatch、Semaphore、CyclicBarrier]]></title>
    <url>%2F68b85893.html</url>
    <content type="text"><![CDATA[摘要：本文介绍AQS。AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。 AQS简介 AQS设计思想 AQS的大致实现思路 AQS组件：CountDownLatch AQS组件：Semaphore AQS组件：CyclicBarrier AQS简介AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向列表。Sync queue：同步队列，是一个双向列表。包括head节点和tail节点。head节点主要用作后续的调度。Condition queue：非必须，单向列表。当程序中存在cindition的时候才会存在此列表。 AQS设计思想 使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。 利用int类型标识状态。在AQS类中有一个叫做state的成员变量 1234/** * The synchronization state. */private volatile int state;1234 基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。 继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。 可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。 AQS的大致实现思路AQS内部维护了一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。 AQS组件：CountDownLatch 通过一个计数来保证线程是否需要被阻塞。实现一个或多个线程等待其他线程执行的场景。 我们定义一个CountDownLatch，通过给定的计数器为其初始化，该计数器是原子性操作，保证同时只有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态。只有其他线程调用countDown方法（每次使计数器-1），使计数器归零才能继续执行。 123456789101112131415final CountDownLatch countDownLatch = new CountDownLatch(threadCount);for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; test(threadNum); //需要被等待的线程执行的方法 &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;);&#125;countDownLatch.await();123456789101112131415 CountDownLatch的await方法还有重载形式，可以设置等待的时间，如果超过此时间，计数器还未清零，则不继续等待： 1234countDownLatch.await(10, TimeUnit.MILLISECONDS);//参数1：等待的时间长度//参数2：等待的时间单位1234 AQS组件：Semaphore 用于保证同一时间并发访问线程的数目。 信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。Semaphore可以很容易控制系统中某个资源被同时访问的线程个数。 在数据结构中我们学过链表，链表正常是可以保存无限个节点的，而Semaphore可以实现有限大小的列表。 使用场景：仅能提供有限访问的资源。比如数据库连接。 Semaphore使用acquire方法和release方法来实现控制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 1、普通调用 */try &#123; semaphore.acquire(); // 获取一个许可 test();//需要并发控制的内容 semaphore.release(); // 释放一个许可&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/** * 2、同时获取多个许可，同时释放多个许可 */ try &#123; semaphore.acquire(2); test(); semaphore.release(2);&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/* * 3、尝试获取许可，获取不到不执行 */ try &#123; if (semaphore.tryAcquire()) &#123; test(threadNum); semaphore.release(); &#125; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/* * 4、尝试获取许可一段时间，获取不到不执行 * 参数1：等待时间长度 参数2：等待时间单位 */try &#123; if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) &#123; test(threadNum); semaphore.release(); &#125;&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 AQS组件：CyclicBarrier 也是一个同步辅助类，它允许一组线程相互等待，直到到达某个公共的屏障点（循环屏障） 通过它可以完成多个线程之间相互等待，只有每个线程都准备就绪后才能继续往下执行后面的操作。 每当有一个线程执行了await方法，计数器就会执行+1操作，待计数器达到预定的值，所有的线程再同时继续执行。由于计数器释放之后可以重用（reset方法），所以称之为循环屏障。 与CountDownLatch区别：1、计数器可重复用2、描述一个或多个线程等待其他线程的关系/多个线程相互等待 123456789101112131415161718192021222324252627282930313233343536373839404142//公共线程循环调用方法private static CyclicBarrier barrier = new CyclicBarrier(5);public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown();&#125;//使用方法1：每个线程都持续等待private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;&#123;&#125; is ready&quot;, threadNum); barrier.await(); log.info(&quot;&#123;&#125; continue&quot;, threadNum);&#125;//使用方法2：每个线程只等待一段时间private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); try &#123; barrier.await(2000, TimeUnit.MILLISECONDS); &#125; catch (InterruptedException | BrokenBarrierException | TimeoutException e) &#123; log.warn(&quot;BarrierException&quot;, e); &#125;&#125;//使用方法3：在初始化的时候设置runnable，当线程达到屏障时优先执行runnableprivate static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123; log.info(&quot;callback is running&quot;);&#125;); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80054133]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十）：HashMap与ConcurrentHashMap]]></title>
    <url>%2F1e12e841.html</url>
    <content type="text"><![CDATA[摘要：如题。 概述 HashMap （1）初始化方法 （2）寻址方式 （3）HashMap的线程不安全原因一：死循环 （4）HashMap的线程不安全原因二：fail-fast ConcurrentHashMap [（1）结构 Java7与Java8不同] 对比 概述在上一节我们简略提到了ConcurrentHashMap是HashMap的线程安全类，那么这两个类的具体实现是怎样的呢？我们来了解一下。 HashMap（1）初始化方法HashMap的实现方式是：数组+链表 的形式。在HashMap中有两个参数会影响HashMap的性能：初始容量/加载因子 初始容量：Hash表中桶的数量加载因子：是Hash表在自动增加之前可以达到多满的一个尺度。 HashMap在类中定义了这两个参数: 1234//初始容量，默认16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //加载因子，默认0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;1234 这两个参数的作用是：当Hash表中的条目数量超过了加载因子与当前容量的乘积，将会调用resize()进行扩容，将容量翻倍。这两个参数在初始化HashMap的时候可以进行设置：可以单独指定初始容量，也可以同时设置 （2）寻址方式对于一个新插入的数据或者要读取的数据，HashMap将key按一定规则计算出hash值，并对数组长度进行取模结果作为在数组中查找的index。由于在计算机中取模的代价远远高于位操作的代价，因此HashMap要求数组的长度必须为2的N次方。此时它将key的hash值对2的n-1次方进行与运算，等同于取模运算。HashMap并不要求用户一定要设置一个2的N次方的初始化大小，它本身内部会通过运算（tableSizeFor方法）确定一个合理的符合2的N次方的大小去设置。 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;123456789 （3）HashMap的线程不安全原因一：死循环原因在于HashMap在多线程情况下，执行resize()进行扩容时容易造成死循环。扩容思路为它要创建一个大小为原来两倍的数组，保证新的容量仍为2的N次方，从而保证上述寻址方式仍然适用。扩容后将原来的数组从新插入到新的数组中。这个过程称为reHash。 【单线程下的reHash】 扩容前：我们的HashMap初始容量为2，加载因子为1，需要向其中存入3个key，分别为5、9、11，放入第三个元素11的时候就涉及到了扩容。 第一步：先创建一个二倍大小的数组，接下来把原来数组中的元素reHash到新的数组中，5插入新的数组，没有问题。 第二步：将9插入到新的数组中，经过Hash计算，插入到5的后面。 第三步：将11经过Hash插入到index为3的数组节点中。 单线程reHash完全没有问题。 【多线程下的reHash】 我们假设有两个线程同时执行了put操作，并同时触发了reHash的操作，图示的上层的线程1，下层是线程2。 线程1某一时刻执行完扩容，准备将key为5的元素的next指针指向9，由于线程调度分配的时间片被用完而停在了这一步操作 线程2在这一刻执行reHash操作并执行完数据迁移的整个操作。 接下来线程1被唤醒继续操作。 执行上一轮的剩余部分，在处理key为5的元素时，将此key放在我们线程1申请的数组的索引1位置的链表的首部。理想状态是（线程1数组索引1）—&gt; (Key=5) —&gt; null 接着处理Key为9的元素，将key为9的元素插入在（索引1）与（key=5）之间，理想状态：（线程1数组索引1）—&gt; （Key=9）—&gt; （Key=5）—&gt;null 但是在处理完key为9的元素之后按理说应该结束了，但是由于线程2已经处理过了key=9与key=5的元素，即真实情况为（线程2数组索引1 —&gt;（key=9）—&gt; （key=5）—&gt; null）|（线程1数组索引1 —&gt; (key=9)—&gt; （key=5）—&gt; null），这时让线程1误以为key=9后面的key=5是从原数组还没有进行数组迁移的，接着又处理key=5。尝试将key=5放在k=9的前边，所以key=9与key=5之间就出现了一个循环。不断的被处理，交换顺序。 key = 11的元素是无法插入到新数组中的。一旦我们去从新的数组中获取值得时候，就会出现死循环。 （4）HashMap的线程不安全原因二：fail-fast如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast。在每一次对HashMap进行修改的时候，都会变动类中的modCount域，即modCount变量的值。源码中是这样实现的： 12345678910111213141516abstract class HashIterator &#123; ... int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; ...&#125;12345678910111213141516 在每次迭代的过程中，都会判断modCount跟expectedModCount是否相等，如果不相等代表有人修改HashMap。源码： 123456789101112final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e;&#125;123456789101112 解决办法：可以使用Collections的synchronizedMap方法构造一个同步的map，或者直接使用线程安全的ConcurrentHashMap来保证不会出现fail-fast策略。 ConcurrentHashMap（1）结构 [Java7与Java8不同] Java7里面的ConcurrentHashMap的底层结构仍然是数组和链表，与HashMap不同的是ConcurrentHashMap的最外层不是一个大的数组，而是一个Segment数组。每个Segment包含一个与HashMap结构差不多的链表数组。 当我们读取某个Key的时候它先取出key的Hash值，并将Hash值得高sshift位与Segment的个数取模，决定key属于哪个Segment。接着像HashMap一样操作Segment。 为了保证不同的Hash值保存到不同的Segment中，ConcurrentHashMap对Hash值也做了专门的优化。 Segment继承自J.U.C里的ReetrantLock，所以可以很方便的对Segment进行上锁。即分段锁。 Java8废弃了Java7中ConcurrentHashMap中分段锁的方案，并且不使用Segment，转为使用大的数组。同时为了提高Hash碰撞下的寻址做了性能优化。 Java8在列表的长度超过了一定的值（默认8）时，将链表转为红黑树实现。寻址的复杂度从O(n)转换为Olog(n)。 对比 HashMap非线程安全、ConcurrentHashMap线程安全 HashMap允许Key与Value为空，ConcurrentHashMap不允许 HashMap不允许通过迭代器遍历的同时修改，ConcurrentHashMap允许。并且更新可见 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79978855]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（九）：并发容器 J.U.C - 线程安全的集合与Map]]></title>
    <url>%2F87d3d6a5.html</url>
    <content type="text"><![CDATA[摘要：本文介绍并发容器JUC(Java.util.concurrency)：集合和Map中线程安全的替代类。 概述 ArrayList –&gt; CopyOnWriteArrayList HashSet –&gt; CopyOnWriteArraySet TreeSet –&gt; ConcurrentSkipListSet HashMap –&gt; ConcurrentHashMap TreeMap –&gt; ConcurrentSkipListMap 安全共享对象策略 概述Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即Java.util.concurrency。上一节我们介绍了ArrayList、HashMap、HashSet对应的同步容器保证其线程安全，这节我们介绍一下其对应的并发容器。 ArrayList –&gt; CopyOnWriteArrayListCopyOnWriteArrayList 写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁 缺点：1.写操作时复制消耗内存，如果元素比较多时候，容易导致young gc 和full gc。2.不能用于实时读的场景.由于复制和add操作等需要时间，故读取时可能读到旧值。能做到最终一致性，但无法满足实时性的要求，更适合读多写少的场景。如果无法知道数组有多大，或者add,set操作有多少，慎用此类,在大量的复制副本的过程中很容易出错。 设计思想：1.读写分离2.最终一致性3.使用时另外开辟空间，防止并发冲突 源码分析 12345678910111213141516171819202122232425262728293031323334//构造方法public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements;//使用对象数组来承载数据 if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements);&#125;//添加数据方法public boolean add(E e) &#123; final ReentrantLock lock = this.lock;//使用重入锁，保证线程安全 lock.lock(); try &#123; Object[] elements = getArray();//获取当前数组数据 int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//复制当前数组并且扩容+1 newElements[len] = e;//将要添加的数据放入新数组 setArray(newElements);//将原来的数组指向新的数组 return true; &#125; finally &#123; lock.unlock(); &#125;&#125;//获取数据方法，与普通的get没什么差别private E get(Object[] a, int index) &#123; return (E) a[index];&#125;12345678910111213141516171819202122232425262728293031323334 HashSet –&gt; CopyOnWriteArraySet 它是线程安全的，底层实现使用的是CopyOnWriteArrayList，因此它也适用于大小很小的set集合，只读操作远大于可变操作。因为他需要copy整个数组，所以包括add、remove、set它的开销相对于大一些。 迭代器不支持可变的remove操作。使用迭代器遍历的时候速度很快，而且不会与其他线程发生冲突。 源码分析： 1234567891011121314151617181920212223242526272829//构造方法public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();//底层使用CopyOnWriteArrayList&#125;//添加元素方法，基本实现原理与CopyOnWriteArrayList相同private boolean addIfAbsent(E e, Object[] snapshot) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) &#123;//添加了元素去重操作 // Optimize for lost race to another addXXX operation int common = Math.min(snapshot.length, len); for (int i = 0; i &lt; common; i++) if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) return false; if (indexOf(e, current, common, len) &gt;= 0) return false; &#125; Object[] newElements = Arrays.copyOf(current, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;1234567891011121314151617181920212223242526272829 TreeSet –&gt; ConcurrentSkipListSet它是JDK6新增的类，同TreeSet一样支持自然排序，并且可以在构造的时候自己定义比较器。 同其他set集合，是基于map集合的（基于ConcurrentSkipListMap），在多线程环境下，里面的contains、add、remove操作都是线程安全的。 多个线程可以安全的并发的执行插入、移除、和访问操作。但是对于批量操作addAll、removeAll、retainAll和containsAll并不能保证以原子方式执行，原因是addAll、removeAll、retainAll底层调用的还是contains、add、remove方法，只能保证每一次的执行是原子性的，代表在单一执行操纵时不会被打断，但是不能保证每一次批量操作都不会被打断。在使用批量操作时，还是需要手动加上同步操作的。 不允许使用null元素的，它无法可靠的将参数及返回值与不存在的元素区分开来。 源码分析： 1234//构造方法public ConcurrentSkipListSet() &#123; m = new ConcurrentSkipListMap&lt;E,Object&gt;();//使用ConcurrentSkipListMap实现&#125;1234 HashMap –&gt; ConcurrentHashMap 不允许空值，在实际的应用中除了少数的插入操作和删除操作外，绝大多数我们使用map都是读取操作。而且读操作大多数都是成功的。基于这个前提，它针对读操作做了大量的优化。因此这个类在高并发环境下有特别好的表现。 ConcurrentHashMap作为Concurrent一族，其有着高效地并发操作，相比Hashtable的笨重，ConcurrentHashMap则更胜一筹了。 在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。 源码分析：推荐参考chenssy的博文：J.U.C之Java并发容器：ConcurrentHashMap TreeMap –&gt; ConcurrentSkipListMap 底层实现采用SkipList跳表 曾经有人用ConcurrentHashMap与ConcurrentSkipListMap做性能测试，在4个线程1.6W的数据条件下，前者的数据存取速度是后者的4倍左右。但是后者有几个前者不能比拟的优点：1、Key是有序的2、支持更高的并发，存储时间与线程数无关 安全共享对象策略 线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改 共享只读：一个共享只读的U帝乡，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它 线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保障线程安全，多以其他线程无需额外的同步就可以通过公共接口随意访问他 被守护对象：被守护对象只能通过获取特定的锁来访问。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79947616]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（八）：线程不安全类、同步容器]]></title>
    <url>%2F92dea4ff.html</url>
    <content type="text"><![CDATA[摘要：本文介绍线程不安全的类和同步容器 1、线程不安全的类 （1）StringBuilder 与 StringBuffer （2）SimpleDateFormat 与 jodatime插件 （3）ArrayList,HashSet,HashMap 等Collection类 2、同步容器 （1）ArrayList的线程安全类：Vector,Stack （2）HashMap的线程安全类：HashTable （3）Collections类中的相关同步方法 1、线程不安全的类如果一个类的对象同时可以被多个线程访问，并且你不做特殊的同步或并发处理，那么它就很容易表现出线程不安全的现象。比如抛出异常、逻辑处理错误…下面列举一下常见的线程不安全的类及对应的线程安全类： （1）StringBuilder 与 StringBufferStringBuilder是线程不安全的，而StringBuffer是线程安全的。分析源码：StringBuffer的方法使用了synchronized关键字修饰。 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125;123456 （2）SimpleDateFormat 与 jodatime插件SimpleDateFormat 类在处理时间的时候，如下写法是线程不安全的： 12345678910private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);//线程调用方法private static void update() &#123; try &#123; simpleDateFormat.parse(&quot;20180208&quot;); &#125; catch (Exception e) &#123; log.error(&quot;parse exception&quot;, e); &#125;&#125;12345678910 但是我们可以变换其为线程安全的写法：在每次转换的时候使用线程封闭，新建变量 12345678private static void update() &#123; try &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;); simpleDateFormat.parse(&quot;20180208&quot;); &#125; catch (Exception e) &#123; log.error(&quot;parse exception&quot;, e); &#125;&#125;12345678 另外我们也可以使用jodatime插件来转换时间：其可以保证线程安全性Joda 类具有不可变性，因此它们的实例无法被修改。（不可变类的一个优点就是它们是线程安全的） 12345private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyyMMdd&quot;);private static void update(int i) &#123; log.info(&quot;&#123;&#125;, &#123;&#125;&quot;, i, DateTime.parse(&quot;20180208&quot;, dateTimeFormatter).toDate());&#125;12345 分析源码：（不可变性） 123456789101112131415161718192021222324252627public class DateTimeFormatter &#123; //均使用final声明 private final InternalPrinter iPrinter; private final InternalParser iParser; private final Locale iLocale; private final boolean iOffsetParsed; private final Chronology iChrono; private final DateTimeZone iZone; private final Integer iPivotYear; private final int iDefaultYear; ... private InternalParser requireParser() &#123; InternalParser var1 = this.iParser; if (var1 == null) &#123; throw new UnsupportedOperationException(&quot;Parsing not supported&quot;); &#125; else &#123; return var1; &#125; &#125; public DateTime parseDateTime(String var1) &#123; InternalParser var2 = this.requireParser(); Chronology var3 = this.selectChronology((Chronology)null); DateTimeParserBucket var4 = new DateTimeParserBucket(0L, var3, this.iLocale, this.iPivotYear, this.iDefaultYear); ... &#125;123456789101112131415161718192021222324252627 （3）ArrayList,HashSet,HashMap 等Collection类像ArrayList,HashSet,HashMap 等Collection类均是线程不安全的，我们以ArrayList举例分析一下源码：1、ArrayList的基本属性：在声明时使用了transient 关键字，此关键字意为在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。而ArrayList实现了序列化接口，自己定义了序列化方法（在此不描述）。 123456//对象数组：ArrayList的底层数据结构private transient Object[] elementData;//elementData中已存放的元素的个数private int size;//默认数组容量private static final int DEFAULT_CAPACITY = 10;123456 2、初始化 12345678910111213141516/** * 创建一个容量为initialCapacity的空的（size==0）对象数组 */ public ArrayList(int initialCapacity) &#123; super();//即父类protected AbstractList() &#123;&#125; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity:&quot; + initialCapacity); this.elementData = new Object[initialCapacity];&#125;/** * 默认初始化一个容量为10的对象数组 */ public ArrayList() &#123; this(10); &#125;12345678910111213141516 3、添加方法（重点） 123456789101112131415161718//每次添加时将数组扩容1，然后再赋值public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;123456789101112131415161718 4、总结：ArrayList每次对内容进行插入操作的时候，都会做扩容处理，这是ArrayList的优点（无容量的限制），同时也是缺点，线程不安全。（以下例子取材于鱼笑笑博客）一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成： 在 Items[Size] 的位置存放此元素； 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 那么如何将其处理为线程安全的？或者说对应的线程安全类有哪些呢？接下来就涉及到我们同步容器。 2、同步容器同步容器分两类，一种是Java提供好的类，另一类是Collections类中的相关同步方法。 （1）ArrayList的线程安全类：Vector,StackVector实现了List接口，Vector实际上就是一个数组，和ArrayList非常的类似，但是内部的方法都是使用synchronized修饰过的方法。Stack它的方法也是使用synchronized修饰了，继承了Vector，实际上就是栈使用举例（Vector）： 123456//定义private static List&lt;Integer&gt; list = new Vector&lt;&gt;();//多线程调用方法private static void update(int i) &#123; list.add(i);&#125;123456 源码分析：使用了synchronized修饰 123456public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;123456 但是Vector也不是完全的线程安全的，比如：错误[1]：删除与获取并发操作 1234567891011121314151617181920212223242526272829public class VectorExample &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread thread1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829 运行结果：报错java.lang.ArrayIndexOutOfBoundsException: Array index out of range原因分析：同时发生获取与删除的操作。当两个线程在同一时间都判断了vector的size，假设都判断为9，而下一刻线程1执行了remove操作，随后线程2才去get，所以就出现了错误。synchronized关键字可以保证同一时间只有一个线程执行该方法，但是多个线程同时分别执行remove、add、get操作的时候就无法控制了。 错误[2]：使用foreach\iterator遍历Vector的时候进行增删操作 123456789101112131415161718192021222324252627282930313233343536373839public class VectorExample3 &#123; // 报错java.util.ConcurrentModificationException private static void test1(Vector&lt;Integer&gt; v1) &#123; // foreach for(Integer i : v1) &#123; if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // 报错java.util.ConcurrentModificationException private static void test2(Vector&lt;Integer&gt; v1) &#123; // iterator Iterator&lt;Integer&gt; iterator = v1.iterator(); while (iterator.hasNext()) &#123; Integer i = iterator.next(); if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // success private static void test3(Vector&lt;Integer&gt; v1) &#123; // for for (int i = 0; i &lt; v1.size(); i++) &#123; if (v1.get(i).equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; public static void main(String[] args) &#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); vector.add(1); vector.add(2); vector.add(3); test1(vector); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839 解决办法：在使用iteratir进行增删操作的时候，加上Lock或者synchronized同步措施或者并发容器 （2）HashMap的线程安全类：HashTable使用举例: 123456//定义private static Map&lt;Integer, Integer&gt; map = new Hashtable&lt;&gt;();//多线程调用方法private static void update(int i) &#123; map.put(i, i);&#125;123456 源码分析： 保证安全性：使用了synchronized修饰 不允许空值（在代码中特殊做了判断） HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。 Entry对象唯一表示一个键值对，有四个属性：-K key 键对象-V value 值对象-int hash 键对象的hash值-Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部 1234567891011121314151617181920212223public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125;1234567891011121314151617181920212223 （3）Collections类中的相关同步方法Collections类中提供了一系列的线程安全方法用于处理ArrayList等线程不安全的Collection类 使用方法： 123456//定义private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());//多线程调用方法private static void update(int i) &#123; list.add(i);&#125;123456 源码分析：内部操作的方法使用了synchronized修饰符 123456789101112131415161718static class SynchronizedList&lt;E&gt; extends SynchronizedCollection&lt;E&gt; implements List&lt;E&gt; &#123; ... public E get(int index) &#123; synchronized (mutex) &#123;return list.get(index);&#125; &#125; public E set(int index, E element) &#123; synchronized (mutex) &#123;return list.set(index, element);&#125; &#125; public void add(int index, E element) &#123; synchronized (mutex) &#123;list.add(index, element);&#125; &#125; public E remove(int index) &#123; synchronized (mutex) &#123;return list.remove(index);&#125; &#125; ...&#125; 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79923837]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（七）：线程封闭 - ThreadLocal]]></title>
    <url>%2F36e8f52e.html</url>
    <content type="text"><![CDATA[摘要：本文介绍什么是线程封闭，线程封闭的种类，Springboot框架中使用ThreadLocal。 1、什么是线程封闭？它其实就是把对象封装到一个线程里，只有一个线程能看到这个对象，那么这个对象就算不是线程安全的，也不会出现任何线程安全方面的问题。 线程封闭技术有一个常见的应用： 数据库连接对应jdbc的Connection对象，Connection对象在实现的时候并没有对线程安全做太多的处理，jdbc的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。 2、线程封闭的种类：（1）Ad-hoc 线程封闭： Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象（例如，GUI应用程序中的可视化组件或数据模型等）的引用通常保存在公有变量中。 （2）堆栈封闭：堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，方法中的局部变量都会被拷贝一份到线程的栈中（Java内存模型），所以局部变量是不会被多个线程所共享的。 （3）ThreadLocal线程封闭：它是一个特别好的封闭方法，其实ThreadLocal内部维护了一个map,map的key是每个线程的名称，而map的value就是我们要封闭的对象。ThreadLocal提供了get、set、remove方法，每个操作都是基于当前线程的，所以它是线程安全的。 1234567891011121314//ThreadLocal的get方法源码public T get() &#123; Thread t = Thread.currentThread();//当前线程对象 ThreadLocalMap map = getMap(t);//get操作基于当前线程 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;1234567891011121314 3、Springboot框架中使用ThreadLocal说明：1、这里不描述springboot框架的搭建过程，假定你已经有了一个可以正常运行的springboot简单项目。2、我们这里的例子使用的是springboot框架中的filter与Interceptor来使用threadLocal，对于Springboot的filter与Interceptor不做过多的讲解。 coding：（1）创建一个包含ThreadLocal对象的类，并提供基础的添加、删除、获取操作。 12345678910111213141516public class RequestHolder &#123; private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;&gt;(); public static void add(Long id) &#123; requestHolder.set(id); &#125; public static Long getId() &#123; return requestHolder.get(); &#125; public static void remove() &#123; requestHolder.remove(); &#125;&#125;12345678910111213141516 （2）创建Filter，在Filter中对ThreadLocal做添加操作。 123456789101112131415161718192021222324public class HttpFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; //打印当前线程的ID与请求路径 log.info(&quot;do filter, &#123;&#125;, &#123;&#125;&quot;, Thread.currentThread().getId(), request.getServletPath()); //将当前线程ID添加到ThreadLocal中 RequestHolder.add(Thread.currentThread().getId()); filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125;123456789101112131415161718192021222324 （3)创建controller，在controller中获取到filter中存入的值 1234567891011@Controller@RequestMapping(&quot;/threadLocal&quot;)public class ThreadLocalController &#123; @RequestMapping(&quot;/test&quot;) @ResponseBody public Long test() &#123; return RequestHolder.getId(); &#125;&#125;1234567891011 （4）创建拦截器Interceptor，在拦截器中删除刚才添加的值 123456789101112131415161718public class HttpInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(&quot;preHandle&quot;); return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; RequestHolder.remove(); log.info(&quot;afterCompletion&quot;); return; &#125;&#125;123456789101112131415161718 （5）在springboot的启动类Application中注册filter与Interceptor。要继承WebMvcConfigurerAdapter 类。（我这里的启动类名为：ConcurrencyApplication） 1234567891011121314151617181920212223@SpringBootApplicationpublic class ConcurrencyApplication extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; SpringApplication.run(ConcurrencyApplication.class, args); &#125; //注册过滤器 @Bean public FilterRegistrationBean httpFilter() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new HttpFilter()); //设置要过滤的url registrationBean.addUrlPatterns(&quot;/threadLocal/*&quot;); return registrationBean; &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new HttpInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125;1234567891011121314151617181920212223 （6）运行程序，访问 http://localhost:8080/threadLocal/test 结果如下： 页面中打印出我们当前的线程ID： 查看控制台：从控制台的打印日志我们可以看出，首先filter过滤器先获取到我们当前的线程ID为40、我们当前的请求路径为/threadLocal/test ，紧接着进入了我们的Interceptor的preHandle方法中，打印了preHandle字样。最后进入了我们的Interceptor的afterCompletion方法，删除了我们之前存入的值，并打印了afterCompletion字样。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79902773]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（六）：不可变对象 -final -ImmutableX -unmodifiableX]]></title>
    <url>%2Fe471f102.html</url>
    <content type="text"><![CDATA[摘要：不可变对象一定是线程安全的，但是线程安全的对象不一定是不可变对象。本文介绍不可变对象的概率，如何创建一个不可变对象，final关键字，Java:unmodifiable相关方法和Google的Guava。 1、不可变对象有一种对象只要它发布了就是安全的，它就是不可变对象。一个不可变对象需要满足的条件： 对象创建一个其状态不能修改 对象所有域都是final类型 对象是正确创建的(在对象创建期间，this引用没有逸出) 2、创建一个不可变对象的方法（1）自己定义这里可以采用的方式包括：1、将类声明为final，这样它就不能被继承。2、将所有的成员声明为私有的，这样就不允许直接访问这些成员。3、对变量不提供set方法，将所有可变的成员声明为final，这样就只能赋值一次。通过构造器初始化所有成员进行深度拷贝。4、在get方法中不直接返回对象的本身，而是克隆对象，返回对象的拷贝。 （2）使用Java中提供的Collection类中的各种unmodifiable开头的方法（3）使用Guava中的Immutable开头的类 3、final关键字final关键字可以修饰类、修饰方法、修饰变量 修饰类：类不能被集成。基础类型的包装类都是final类型的类。final类中的成员变量可以根据需要设置为final，但是要注意的是，final类中的所有成员方法都会被隐式的指定为final方法 修饰方法：(1)把方法锁定，以防任何继承类修改它的含义(2)效率：在早期的java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不见效果。一个private方法会被隐式的指定为final方法 修饰变量：基本数据类型变量，在初始化之后，它的值就不能被修改了。如果是引用类型变量，在它初始化之后便不能再指向另外的对象。 从上图我们可见，（1）对一个被final修饰的变量（Integer a、String b）被赋值时在编译过程中就出现了错误。（2）（map）在重新被指向一个新的map对象的时候也出现了错误。那么对被定义为final的map进行赋值呢？我们单独运行map.put(1,3)语句，结果是可以的。被final修饰的引用类型变量，虽然不能重新指向，但是可以修改,这一点尤为要注意。（3）当final修饰方法的参数时：同样也是不允许在方法内部对其修改的。 4、Java:unmodifiable相关方法使用Java的Collection类的unmodifiable相关方法，可以创建不可变对象。unmodifiable相关方法包含：Collection、List、Map、Set….举个栗子： 1234567891011121314151617public class ImmutableExample &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125;1234567891011121314151617 上面程序的执行结果为：在map.put（1，3）操作的位置抛出了异常。由此可见map对象已经成为不可变对象。 那么unmodifiable相关类的实现原理是什么呢？我们查看一下Collections.unmodifiableMap的源码：（以下源码只筛选出表达观点的部分，非全部） 12345678910public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) &#123; return new UnmodifiableMap&lt;&gt;(m);&#125;private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; ... public V put(K key, V value) &#123; throw new UnsupportedOperationException(); &#125; ...&#125;12345678910 Collections.unmodifiableMap在执行时，将参数中的map对象进行了转换，转换为Collection类中的内部类 UnmodifiableMap对象。而 UnmodifiableMap对map的更新方法（比如put、remove等）进行了重写，均返回UnsupportedOperationException异常，这样就做到了map对象的不可变。 5、Guava:Immutable相关类使用Guava的Immutable相关类也可以创建不可变对象。同样包含很多类型：Collection、List、Map、Set….举栗子：（1）ImmutableList 123private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);list.add(4);//这一句在书写完就会被IDE提示该add方法为过时方法，实际为不可用方法123 对于ImmutableList.of方法，如果传多个参数，需要这样一直写下去，以逗号分隔每个参数。其源码中是这样实现的： 1234567891011121314151617181920212223242526272829303132333435363738//单个或少于12个参数时public static &lt;E&gt; ImmutableList&lt;E&gt; of() &#123; return RegularImmutableList.EMPTY;&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E element) &#123; return new SingletonImmutableList(element);&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2) &#123; return construct(e1, e2);&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3) &#123; return construct(e1, e2, e3);&#125;....//多于12个参数时，参数列表中最后的E...other会以数组形式接收参数@SafeVarargspublic static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) &#123; Object[] array = new Object[12 + others.length]; array[0] = e1; array[1] = e2; array[2] = e3; array[3] = e4; array[4] = e5; array[5] = e6; array[6] = e7; array[7] = e8; array[8] = e9; array[9] = e10; array[10] = e11; array[11] = e12; System.arraycopy(others, 0, array, 12, others.length); return construct(array);&#125;1234567891011121314151617181920212223242526272829303132333435363738 运行结果仍然为抛出UnsupportedOperationException异常。分析源码：Immutable相关类使用了跟Java的unmodifiable相关类相似的实现方法。 123456/** @deprecated */ @Deprecated @CanIgnoreReturnValue public final boolean add(E e) &#123; throw new UnsupportedOperationException(); &#125;123456 （2）ImmutableSetImmutableSet除了使用of的方法进行初始化，还可以使用copyof方法，将Collection类型、Iterator类型作为参数。 123private final static ImmutableSet set = ImmutableSet.copyOf(list);private final static ImmutableSet set = ImmutableSet.copyOf(list.iterator());123 （3）ImmutableMapImmutableMap有特殊的builder写法： 1234private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79897550]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（五）：安全发布对象与多种单例模式]]></title>
    <url>%2Fdcfa5a09.html</url>
    <content type="text"><![CDATA[摘要：本文介绍安全发布对象的概念，代码演示，对象逃逸与多种单例模式 概念 发布对象 对象逸出 代码演示 不安全发布对象 对象逸出 安全发布对象示例（多种单例模式演示） 1、懒汉式（最简式） 2、懒汉式（synchronized） 3、双重同步锁模式【先入坑再出坑】 4、饿汉式（最简式） 5、饿汉式（静态块初始化） 6、枚举式 概念发布对象使一个对象能够被当前范围之外的代码所使用。在我们的日常开发中，我们经常要发布一些对象，比如通过类的非私有方法返回对象的引用，或者通过公有静态变量发布对象。 对象逸出一种错误的发布。当一个对象还没有构造完成时，就使它被其他线程所见。 代码演示不安全发布对象1234567891011121314151617public class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; //类的非私有方法，返回私有对象的引用 public String[] getStates() &#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125;1234567891011121314151617 分析： 这个代码通过public访问级别发布了类的域，在类的任何外部的线程都可以访问这些域 我们无法保证其他线程会不会修改这个域，从而使私有域内的值错误（上述代码中就对私有域进行了修改） 对象逸出123456789101112131415161718192021public class Escape &#123; private Integer thisCanBeEscape = 0; public Escape () &#123; new InnerClass(); thisCanBeEscape = null; &#125; //内部类构造方法调用外部类的私有域 private class InnerClass &#123; public InnerClass() &#123; log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125;123456789101112131415161718192021 分析： 这个内部类的实例里面包含了对封装实例的私有域对象的引用，在对象没有被正确构造完成之前就会被发布，有可能有不安全的因素在里面，会导致this引用在构造期间溢出的错误。 上述代码在函数构造过程中启动了一个线程。无论是隐式的启动还是显式的启动，都会造成这个this引用的溢出。新线程总会在所属对象构造完毕之前就已经看到它了。 因此要在构造函数中创建线程，那么不要启动它，而是应该采用一个专有的start或者初始化的方法统一启动线程 这里其实我们可以采用工厂方法和私有构造函数来完成对象创建和监听器的注册等等，这样才可以避免错误 ——————————————————————————————————————————————————- 如果不正确的发布对象会导致两种错误：（1）发布线程意外的任何线程都可以看到被发布对象的过期的值（2）线程看到的被发布线程的引用是最新的，然而被发布对象的状态却是过期的 安全发布对象示例（多种单例模式演示）如何安全发布对象？共有四种方法 1、在静态初始化函数中初始化一个对象引用 2、将对象的引用保存到volatile类型域或者AtomicReference对象中 3、将对象的引用保存到某个正确构造对象的final类型域中 4、将对象的引用保存到一个由锁保护的域中 下面我们用各种单例模式来演示其中的几种方法 1、懒汉式（最简式）12345678910111213141516public class SingletonExample &#123; //私有构造函数 private SingletonExample()&#123; &#125; //单例对象 private static SingletonExample instance = null; //静态工厂方法 public static SingletonExample getInstance()&#123; if(instance==null)&#123; return new SingletonExample(); &#125; return instance; &#125;&#125;12345678910111213141516 分析：1、在多线程环境下，当两个线程同时访问这个方法，同时制定到instance==null的判断。都判断为null，接下来同时执行new操作。这样类的构造函数被执行了两次。一旦构造函数中涉及到某些资源的处理，那么就会发生错误。所以说最简式是线程不安全的 2、懒汉式（synchronized）12在类的静态方法上使用synchronized修饰 public static synchronized SingletonExample getInstance()12 分析：1、使用synchronized修饰静态方法后，保证了方法的线程安全性，同一时间只有一个线程访问该方法2、有缺陷：会造成性能损耗 3、双重同步锁模式【先入坑再出坑】12345678910111213141516171819public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = null; // 静态的工厂方法 public static SingletonExample getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (SingletonExample.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonExample(); &#125; &#125; &#125; return instance; &#125;&#125;12345678910111213141516171819 （入坑）分析：1、我们将上面的第二个例子(懒汉式（synchronized))进行了改进，由synchronized修饰方法改为先判断后，再锁定整个类，再加上双重的检测机制，保证了最大程度上的避免耗损性能。2、这个方法是线程不安全的，可能大家会想在多线程情况下，只要有一个线程对类进行了上锁，那么无论如何其他线程也不会执行到new的操作上。接下来我们分析一下线程不安全的原因： 这里有一个知识点：CPU指令相关在上述代码中，执行new操作的时候，CPU一共进行了三次指令（1）memory = allocate() 分配对象的内存空间（2）ctorInstance() 初始化对象（3）instance = memory 设置instance指向刚分配的内存 在程序运行过程中，CPU为提高运算速度会做出违背代码原有顺序的优化。我们称之为乱序执行优化或者说是指令重排。那么上面知识点中的三步指令极有可能被优化为（1）（3）（2）的顺序。当我们有两个线程A与B，A线程遵从132的顺序，经过了两此instance的空值判断后，执行了new操作，并且cpu在某一瞬间刚结束指令（3），并且还没有执行指令（2）。而在此时线程B恰巧在进行第一次的instance空值判断，由于线程A执行完（3）指令，为instance分配了内存，线程B判断instance不为空，直接执行return，返回了instance，这样就出现了错误。 （出坑）解决办法： 12在对象声明时使用volatile关键字修饰，阻止CPU的指令重排。private volatile static SingletonExample instance = null;12 关于volatile如何阻止CPU指令重排，详情请见另一篇文章：高并发探索（四)：线程安全性-可见性-有序性 4、饿汉式（最简式）1234567891011121314public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = new SingletonExample(); // 静态的工厂方法 public static SingletonExample getInstance() &#123; return instance; &#125;&#125;1234567891011121314 分析：1、饿汉模式由于单例实例是在类装载的时候进行创建，因此只会被执行一次，所以它是线程安全的。2、该方法存在缺陷：如果构造函数中有着大量的事情操作要做，那么类的装载时间会很长，影响性能。如果只是做的类的构造，却没有引用，那么会造成资源浪费3、饿汉模式适用场景为：（1）私有构造函数在实现的时候没有太多的处理（2）这个类在实例化后肯定会被使用 5、饿汉式（静态块初始化）123456789101112131415161718public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = null; static &#123; instance = new SingletonExample(); &#125; // 静态的工厂方法 public static SingletonExample getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; System.out.println(getInstance().hashCode()); System.out.println(getInstance().hashCode()); &#125;&#125;123456789101112131415161718 分析：1、除了使用静态域直接初始化单例对象，还可以用静态块初始化单例对象。2、值得注意的一点是，静态域与静态块的顺序一定不要反，在写静态域和静态方法的时候，一定要注意顺序，不同的静态代码块是按照顺序执行的，它跟我们正常定义的静态方法和普通方法是不一样的。 6、枚举式1234567891011121314151617181920212223public class SingletonExample &#123; private SingletonExample() &#123; &#125; public static SingletonExample getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private SingletonExample singleton; Singleton() &#123; singleton = new SingletonExample(); &#125; public SingletonExample getInstance() &#123; return singleton; &#125; &#125;&#125;1234567891011121314151617181920212223 由于枚举类的特殊性，枚举类的构造函数Singleton方法只会被实例化一次，且是这个类被调用之前。这个是JVM保证的。 对比懒汉与饿汉模式，它的优势很明显。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79866152]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（四）：线程安全性-可见性-有序性]]></title>
    <url>%2F4d4cd374.html</url>
    <content type="text"><![CDATA[摘要：本文介绍可见性及保证可见性的synchronized和volatile，有序性及如何保证有序性。 可见性什么是可见性？ 一个线程对主内存的修改可以及时的被其他线程观察到 导致共享变量在线程间不可见的原因 线程交叉执行 重排序结合线程交叉执行 共享变量更新后的值没有在工作内存与主存间及时更新 JVM处理可见性JVM对于可见性，提供了synchronized和volatile JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁） Volatile:通过加入内存屏障和禁止重排序优化来实现 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存。 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。 volatile的屏障操作都是cpu级别的。 适合状态验证，不适合累加值，volatile关键字不具有原子性举个例子：我们仍用高并发学习（二）中的例子来说明，对一个int型数值的多线程读写操作。我们将count变量用volatile来修饰： 12345678910111213141516171819202122232425262728293031323334public class CountExample &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //计数 * public static volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count); &#125; private static void add()&#123; count++; &#125;&#125;12345678910111213141516171819202122232425262728293031323334 多次运行代码我们发现：count的最终结果并不是预期的5000，而是有时为5000，但是大多数时间比5000小，这是为什么呢？原因在于对count++的操作中，jvm对count做了三步操作： 1、从主存中取出count的值放入工作变量 count2、对工作变量中的count进行+13、将工作变量中的count刷新回主存中 在单线程执行此操作绝对没有问题，但是在多线程环境中，假设有两个线程A、B同时执行count++操作，某一刻A与B同时读取主存中count的值，然后在自己线程对应的工作空间中对count+1，最后又同时将count+1的值写回主存。到此，count+1的值被写回主存两遍，所以导致最终的count值小了1。在整体程序执行过程中，该事件发生一次或多次，自然结果就不正确。那么volatile适合做什么呢？其实它比较适合做状态标记量（不会涉及到多线程同时读写的操作），而且要保证两点：（1）对变量的写操作不依赖于当前值（2）该变量没有包含在具有其他变量的不变的式子中例如： 12345678910volatile boolean inited = false;//线程一：context = loadContext();inited = true;//线程二：while（!inited）&#123; sleep();&#125;doSomethingWithConfig(context);12345678910 有序性什么是有序性？Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。关于重排序，详情见：高并发学习（二）– 4、乱序执行优化 java中保证有序性java提供了 volatile、synchronized、Lock可以用来保证有序性另外，java内存模型具备一些先天的有序性，即不需要任何手段就能得到保证的有序性。通常被我们成为happens-before原则（先行发生原则）。如果两个线程的执行顺序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机就可以对它们进行重排序。 【以下规则来自于《深入理解java虚拟机》】 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作（重要） 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C —————————————————————————————————————————————— 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79848032]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（三）：线程安全性-原子性-CAS（CAS的ABA问题）]]></title>
    <url>%2F922ce624.html</url>
    <content type="text"><![CDATA[摘要：本文介绍线程的安全性，原子性，java.lang.Number包下的类与CAS操作，synchronized锁，和原子性操作各方法间的对比。 线程安全性 线程安全？ 线程安全性？ 原子性 Atomic包中的类与CAS： AtomicInteger AtomicLong 与 LongAdder AtomicBoolean AtomicIntegerFieldUpdater AtomicStampReference与CAS的ABA问题 AtomicLongArray synchronized synchronized 修饰一个代码块 synchronized 修饰一个方法 synchronized 修饰一个静态方法 synchronized 修饰一个类 原子性操作各方法间的对比 线程安全？当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 线程安全性？线程安全性主要体现在三个方面：原子性、可见性、有序性 原子性:提供了互斥访问，同一时刻只能有一个线程来对它进行操作 可见性:一个线程对主内存的修改可以及时的被其他线程观察到 有序性:一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。 基础代码：以下代码用于描述下方的知识点，所有代码均在此代码基础上进行修改。 12345678910111213141516171819202122232425262728293031323334public class CountExample &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //变量声明：计数 public static AtomicInteger count = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count.get());//变量取值 &#125; private static void add()&#123; count.incrementAndGet();//变量操作 &#125;&#125;12345678910111213141516171819202122232425262728293031323334 原子性说到原子性，一共有两个方面需要学习一下，一个是JDK中已经提供好的Atomic包，他们均使用了CAS完成线程的原子性操作，另一个是使用锁的机制来处理线程之间的原子性。锁包括：synchronized、Lock Atomic包中的类与CAS：我们从最简单的AtomicInteger类来了解什么是CAS AtomicInteger上边的示例代码就是通过AtomicInteger类保证了线程的原子性。那么它是如何保证原子性的呢？我们接下来分析一下它的源码。示例中，对count变量的+1操作，采用的是incrementAndGet方法，此方法的源码中调用了一个名为unsafe.getAndAddInt的方法 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;123 而getAndAddInt方法的具体实现为： 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;1234567 在此方法中，方法参数为要操作的对象Object var1、期望底层当前的数值为var2、要修改的数值var4。定义的var5为真正从底层取出来的值。采用do..while循环的方式去获取底层数值并与期望值进行比较，比较成功才将值进行修改。而这个比较再进行修改的方法就是compareAndSwapInt就是我们所说的CAS，它是一系列的接口，比如下面罗列的几个接口。使用native修饰，是底层的方法。CAS取的是compareAndSwap三个单词的首字母. 另外，示例代码中的count可以理解为JMM中的工作内存，而这里的底层数值即为主内存，如果看过我上一篇文章的盆友就能把这一块的知识点串联起来了。 123public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);123 AtomicLong 与 LongAdderLongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。首先看一下代码实现： 1234567891011121314AtomicLong：//变量声明public static AtomicLong count = new AtomicLong(0);//变量操作count.incrementAndGet();//变量取值count.get();1234567LongAdder：//变量声明public static LongAdder count = new LongAdder();//变量操作count.increment();//变量取值count1234567 那么问题来了，为什么有了AtomicLong还要新增一个LongAdder呢？原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。 知识点： 对于普通类型的long、double变量，JVM允许将64位的读操作或写操作拆成两个32位的操作。 LongAdder类的实现核心是将热点数据分离，比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。 1234567891011121314源码：public void increment() &#123; add(1L);&#125;public void add(long x) &#123; Cell[] as; long b, v; int m; Cell a; if ((as = cells) != null || !casBase(b = base, b + x)) &#123; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) longAccumulate(x, null, uncontended); &#125;&#125;1234567891011121314 缺点：如果在统计的时候，如果有并发更新，可能会有统计数据有误差。实际使用中在处理高并发计数的时候优先使用LongAdder，而不是AtomicLong在线程竞争很低的时候，使用AtomicLong会简单效率更高一些。比如序列号生成（准确性） AtomicBoolean这个类中值得一提的是它包含了一个名为compareAndSet的方法，这个方法可以做到的是控制一个boolean变量在一件事情执行之前为false，事情执行之后变为true。或者也可以理解为可以控制某一件事只让一个线程执行，并仅能执行一次。他的源码如下： 12345public final boolean compareAndSet(boolean expect, boolean update) &#123; int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u);&#125;12345 举例说明： 12345678910111213141516171819202122232425262728293031323334353637 //是否发生过 private static AtomicBoolean isHappened = new AtomicBoolean(false); // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); test(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;isHappened:&#123;&#125;&quot;, isHappened.get()); &#125; private static void test() &#123; if (isHappened.compareAndSet(false, true)) &#123;//控制某有一段代码只执行一次 log.info(&quot;execute&quot;); &#125; &#125;结果：(log只打印一次)[pool-1-thread-2] INFO com.superboys.concurrency.example.Atomic.AtomicExample6 - execute[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample6 - isHappened:true12345678910111213141516171819202122232425262728293031323334353637 AtomicIntegerFieldUpdater这个类的核心作用是要更新一个指定的类的某一个字段的值。并且这个字段一定要用volatile修饰同时还不能是static的。举例说明： 123456789101112131415161718192021222324252627282930@Slf4jpublic class AtomicExample5 &#123; //原子性更新某一个类的一个实例 private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class,&quot;count&quot;); @Getter public volatile int count = 100;//必须要volatile标记，且不能是static public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if(updater.compareAndSet(example5,100,120))&#123; log.info(&quot;update success 1,&#123;&#125;&quot;,example5.getCount()); &#125; if(updater.compareAndSet(example5,100,120))&#123; log.info(&quot;update success 2,&#123;&#125;&quot;,example5.getCount()); &#125;else&#123; log.info(&quot;update failed,&#123;&#125;&quot;,example5.getCount()); &#125; &#125;&#125;此方法输出的结果为：[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample5 - update success 1,120[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample5 - update failed,120由此可见，count的值只修改了一次。123456789101112131415161718192021222324252627282930 AtomicStampReference与CAS的ABA问题什么是ABA问题？CAS操作的时候，其他线程将变量的值A改成了B，但是随后又改成了A，本线程在CAS方法中使用期望值A与当前变量进行比较的时候，发现变量的值未发生改变，于是CAS就将变量的值进行了交换操作。但是实际上变量的值已经被其他的变量改变过，这与设计思想是不符合的。所以就有了AtomicStampReference。 12345678910111213141516171819202122232425262728293031源码：private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125;private volatile Pair&lt;V&gt; pair;private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); &#125;public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; //排除新的引用和新的版本号与底层的值相同的情况 newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125;12345678910111213141516171819202122232425262728293031 AtomicStampReference的处理思想是，每次变量更新的时候，将变量的版本号+1，之前的ABA问题中，变量经过两次操作以后，变量的版本号就会由1变成3，也就是说只要线程对变量进行过操作，变量的版本号就会发生更改。从而解决了ABA问题。 解释一下上边的源码：类中维护了一个volatile修饰的Pair类型变量current，Pair是一个私有的静态类，current可以理解为底层数值。compareAndSet方法的参数部分分别为期望的引用、新的引用、期望的版本号、新的版本号。return的逻辑为判断了期望的引用和版本号是否与底层的引用和版本号相符，并且排除了新的引用和新的版本号与底层的值相同的情况（即不需要修改）的情况（return代码部分3、4行）。条件成立，执行casPair方法，调用CAS操作。 AtomicLongArray这个类实际上维护了一个Array数组，我们在对数值进行更新的时候，会多一个索引值让我们更新。 原子性，提供了互斥访问，同一时刻只能有一个线程来对它进行操作。那么在java里，保证同一时刻只有一个线程对它进行操作的，除了Atomic包之外，还有锁的机制。JDK提供锁主要分为两种：synchronized和Lock。接下来我们了解一下synchronized。 synchronized依赖于JVM去实现锁，因此在这个关键字作用对象的作用范围内，都是同一时刻只能有一个线程对其进行操作的。synchronized是java中的一个关键字，是一种同步锁。它可以修饰的对象主要有四种： 修饰代码块:大括号括起来的代码，作用于调用的对象 修饰方法：整个方法，作用于调用的对象 ———————————————————————– 修饰静态方法：整个静态方法，作用于所有对象 修饰类：括号括起来的部分，作用于所有对象 synchronized 修饰一个代码块被修饰的代码称为同步语句块，作用的范围是大括号括起来的部分。作用的对象是调用这段代码的对象。验证： 1234567891011121314151617public class SynchronizedExample &#123; public void test(int j)&#123; synchronized (this)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; &#125; //使用线程池方法进行测试： public static void main(String[] args) &#123; SynchronizedExample example1 = new SynchronizedExample(); SynchronizedExample example2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt; example1.test(1)); executorService.execute(()-&gt; example2.test(2)); &#125;&#125;1234567891011121314151617 结果：不同对象之间的操作互不影响 synchronized 修饰一个方法被修饰的方法称为同步方法，作用的范围是大括号括起来的部分，作用的对象是调用这段代码的对象。验证： 123456789public class SynchronizedExample public synchronized void test(int j)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; //验证方法与上面相同 ...&#125;123456789 结果：不同对象之间的操作互不影响 TIPS：如果当前类是一个父类，子类调用父类的被synchronized修饰的方法，不会携带synchronized属性，因为synchronized不属于方法声明的一部分 synchronized 修饰一个静态方法作用的范围是synchronized 大括号括起来的部分，作用的对象是这个类的所有对象。验证： 123456789public class SynchronizedExample&#123; public static synchronized void test(int j)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; //验证方法与上面相同 ...&#125;123456789 结果：同一时间只有一个线程可以执行 synchronized 修饰一个类验证： 1234567891011public class SynchronizedExample&#123; public static void test(int j)&#123; synchronized (SynchronizedExample.class)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125;-&#123;&#125;&quot;,j,i); &#125; &#125; &#125; //验证方法与上面相同 ...&#125;1234567891011 结果：同一时间只有一个线程可以执行 原子性操作各方法间的对比 synchronized:不可中断锁，适合竞争不激烈，可读性好 Lock：可中断锁，多样化同步，竞争激烈时能维持常态 Atomic:竞争激烈时能维持常态，比Lock性能好，每次只能同步一个值 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79837508]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（二）：高并发相关基础知识 - MESI - JMM]]></title>
    <url>%2F4e44ac3.html</url>
    <content type="text"><![CDATA[摘要：本文介绍高并发的工具、基础概念、CPU多级缓存、缓存一致性原则、CPU的乱序执行优化、JMM、JMM的同步操作、同步规则以及并发的优势与风险。 高并发相关基础知识0、工具1、基础概念2、CPU多级缓存3、缓存一致性(MESI Modify|Exclusive|Share|Invalid)4、乱序执行优化5、JAVA 内存模型(JMM)6、Java内存模型-同步八种操作7、Java内存模型-同步规则8、并发的优势与风险 0、工具 Apache Bench(AB) :Apache附带的工具，测试网站性能 — ApacheBench安装及使用方法 Jmeter ： Apache组织开发的压力测试工具（比AB更强大） 代码测试方法 ：Semaphore、CountDownLatch类 Semaphore类：信号量信号量，在我们测试的过程中充当监控并发数的角色。能够维持在同一时间的请求的并发量，达到并发量上线，会阻塞进程。 CountDownLatch类：计数器向下减的闭锁 说明：假设计数器的值为3，线程A执行了await()方法之后，进入了awaiting等待状态。在其他线程的方法中执行了countDown()方法之后，计数器的值都会减一，直到计数器的值减为0，线程A的方法才继续执行。所以说，countDownLatch类可以阻塞线程执行，并且当满足指定条件后让线程继续执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @author JeffOsmond * @version V1.0 * @package com.superboys.concurrency * @description 【线程不安全】模拟示例 * @email yinjiaxing_web@163.com * @time 2018/4/3 */@NotThreadSafe@Slf4jpublic class CountExample1 &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //计数 public static int count = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count); &#125; private static void add()&#123; count++; &#125;&#125; 1、基础概念 并发:同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地还如或者换出内存，这些线程是同时”存在”的，每隔线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。 高并发:High Concurrency 是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 2、CPU多级缓存CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题。CPU多级缓存配置（演变）：局部性原理：(1) 时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。(2) 空间局部性：如果某个数据被访问，那么与他相邻的数据很快也可能被访问。 3、缓存一致性(MESI Modify|Exclusive|Share|Invalid) Modify:被修改，该缓存行只被缓存在该CPU的缓存中。并且是被修改过的，因此它与主存中的数据是不一致的，该缓存行中的内存需要在未来的某个时间点写回主存，这个时间点是允许其他CPU读取主存中相应的内存之前。当这里的值被写回主存之后，该缓存行的状态将变为Excluisive. Exclusive:独享，该缓存行只被缓存在该CPU的缓存中，他是未被修改过的，是与主存中的数据一致的。他可以在任何时刻，被其他CPU读取该内存时，变成Share。当该CPU修改他的内容时，变成Modify Share：共享，意味着该缓存行可能被多个CPU进行缓存，并且各缓存中的数据与主存数据是一致的。当有一个CPU修改该缓存行的时候，其他CPU中该缓存行变成Invalid Invalid：无效 四种操作 本地读取 local read :读本地缓存 本地写入 local write : 写本地缓存 远端读取 remote rade : 将Memory中的数据读取过来 远端写入 remote write : 将数据写回Memory中缓存被修改时的情况：某一时刻缓存被CPU A 与CPU B共享，这时CPU A 要修改本地缓存的时候，会将主存的数据与CPU B在共享的数据置为无效状态。缓存由S -&gt; I 4、乱序执行优化处理器为提高运算速度而做出违背代码原有顺序的优化。举例：初始计算需求如下 预期计算流程： 实际计算流程（乱序执行优化后）： 5、JAVA 内存模型(JMM)一种规范，规范了java虚拟机与计算机内存如何协同工作的。它规定了一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步地访问共享变量。 堆Heap:运行时数据区，有垃圾回收，堆的优势可以动态分配内存大小，生存期也不必事先告诉编译器，因为他是在运行时动态分配内存。缺点是由于运行时动态分配内存，所以存取速度慢一些。 栈Stack:优势存取速度快，速度仅次于计算机的寄存器。栈的数据是可以共享的，但是缺点是存在栈中数据的大小与生存期必须是确定的。主要存放基本类型变量，对象据点。要求调用栈和本地变量存放在线程栈上。 静态类型变量跟随类的定义存放在堆上。存放在堆上的对象可以被所持有对这个对象引用的线程访问。 如果两个线程同时调用了同一个对象的同一个方法，他们都会访问这个对象的成员变量。但是这两个线程都拥有的是该对象的成员变量（局部变量）的私有拷贝。—[线程封闭中的堆栈封闭] CPU Registers(寄存器):是CPU内存的基础，CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器速度远大于主存。 CPU Cache Memory(高速缓存):由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存，来作为内存与处理器之间的缓冲。将运算时所使用到的数据复制到缓存中,让运算能快速的进行。当运算结束后，再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。 RAM-Main Memory(主存/内存): 当一个CPU需要读取主存的时候，他会将主存中的部分读取到CPU缓存中，甚至他可能将缓存中的部分内容读到他的内部寄存器里面，然后在寄存器中执行操作。当CPU需要将结果回写到主存的时候，他会将内部寄存器中的值刷新到缓存中，然后在某个时间点从缓存中刷回主存。 Java内存模型抽象结构：每个线程都有一个私有的本地内存，本地内存他是java内存模型的一个抽象的概念。它并不是真实存在的，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器的优化。本地内存中它存储了该线程以读或写共享变量拷贝的一个副本。 从更低的层次来说，主内存就是硬件的内存，是为了获取更高的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中，java内存模型中的线程的工作内存是CPU的寄存器和高速缓存的一个抽象的描述。而JVM的静态内存存储模型它只是对内存的一种物理划分而已。它只局限在内存，而且只局限在JVM的内存。 6、Java内存模型-同步八种操作 lock(锁定) ：作用于主内存变量，把一个变量标识为一条线程独占状态 unlock(解锁) ： 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read(读取) ： 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load(载入) ：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use(使用) ：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign(赋值) ： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量 store(存储) ： 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作 write(写入) ：作用于主内存的变量中，它把store操作从工作内存中一个变量的值传送到主内存的变量中 7、Java内存模型-同步规则 如果要把一个变量从主内存中复制到工作内存，就需要按顺序的执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序的执行store和write操作。但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量早同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须是成对出现。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock锁定，则不允许对它执行unlock操作，也不允许unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） 8、并发的优势与风险 风险： 安全性：多个线程共享数据时可能会产生于期望不相符的结果 活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁、饥饿问题 性能：线程过多时会使得CPU频繁切换，调度时间增多；同步机制；消耗过多内存。 优势： 速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程同时进行。 设计：程序设计在某些情况下更简单，也可以有更多选择 资源利用：CPU能够在等待IO的时候做一些其他的事情 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79811336]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（一）：详细讲解 - 网站性能测试工具Apache Bench]]></title>
    <url>%2F31ea1ae0.html</url>
    <content type="text"><![CDATA[摘要：本文介绍网站服务器效能测试工具：Apache Bench 的简介、下载、简单的使用方法和测试 1、Apache Bench 简介Apache Bench是Apache 服务器附带的工具，专门用来执行网站服务器的运行效能，特别是针对Apache 网站服务器。原本用来检测Apache网站能够提供的效能，特别是能看出Apache能提供每秒能送出多少网页。 2、Apache Bench下载我们到网站的官网去下载Apache服务器下载地址：Apache服务器下载地址下载成功后直接进行解压，无需安装即可使用（仅针对于ApacheBench而言）。 3、简单的Apache Bench使用方法 我们打开命令行界面，从命令行界面进入Apache Bench的解压路径下，进入后访问bin文件夹。 进入后我们输入基础的测试命令对接口进行测试（例如http://localhost:8080/test） ab -n 1000 -c 50 http://localhost:8080/test 这段命令的含义是对于上述接口进行1000次测试，在同一时间内允许50个并发请求，执行结果如下： 4、测试结果讲解（1）测试指令参数说明：Usage: ab [options][]hostname[:port]/path&gt;我们上述的测试指令中，options为测试指令参数，其全部指参数说明如下： Options are:（英文水平太烂，凑活看吧） 参数编码（-？） 参数名 参数说明 含义 -n requests Number of requests to perform 总请求数 -c concurrency Number of multiple requests to make at a time 并发数量 -t timelimit Seconds to max. to spend on benchmarkin ,This implies -n 50000 测试时长最大秒数 -s timeout Seconds to max. wait for each response, Default is 30 seconds 每次请求等待响应的最长时间，默认30秒 -b windowsize Size of TCP send/receive buffer, in bytes TCP发送\接收缓存大小（单位bytes） -B address Address to bind to when making outgoing connections 发送连接时绑定的地址 -p postfile File containing data to POST. Remember also to set -T 以POST方法发送文件，必须同时使用-T参数 -u putfile File containing data to PUT. Remember also to set -T 以PUT方法发送文件，必须同时使用-T参数 -T content-type Content-type header to use for POST/PUT data, eg., ‘application/x-www-form-urlencoded’, Default is ‘text/plain’ 使用POST\PUT方式时的Content-Type头，例如：’application/x-www-form-urlencoded’，默认：’text/plain’ -v verbosity How much troubleshooting info to print 设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出 -w Print out results in HTML tables 以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表 -i Use HEAD instead of GET 使用HEAD请求 -x attributes String to insert as table attributes 插入字符串作为表格属性 -y attributes String to insert as tr attributes 插入字符串作为tr属性 -z attributes String to insert as td or th attributes 插入字符串作为th属性 -C attribute Add cookie, eg. ‘Apache=1234’. (repeatable) 添加cookie，可重复 -H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’, Inserted after all normal header lines. (repeatable) 添加任意的头信息，可重复 -A attribute Add Basic WWW Authentication, the attributes ,are a colon separated username and password. 添加基础的www认证、属性，是一个以冒号分割的账号与密码 -P attribute Add Basic Proxy Authentication, the attributes ,are a colon separated username and password. 添加基本的代理身份验证、属性，是一个以冒号分隔的用户名和密码。 -X proxy:port Proxyserver and port number to use 使用的代理服务和对应端口号 -V Print version number and exit 直接输出版本号退出 -k Use HTTP KeepAlive feature 使用Http KeepAlice特性 -d Do not show percentiles served table. -S Do not show confidence estimators and warnings. 不显示confidence estimators和警告 -q Do not show progress when doing more than 150 requests 当超过150个请求的时候不显示进程 -l Accept variable document length (use this for dynamic pages) 接受可变文档长度(用于动态页面) -g filename Output collected data to gnuplot format file. 以gnuplot格式文件输出收集的数据。 -e filename Output CSV file with percentages served 以CSV文件的方式输出命中的服务 -r Don’t exit on socket receive errors. 返回error时不要终端socket -m method Method name 方法名 -h Display usage information (this message) 显示使用信息 （2）返回结果的说明： 字段名 解释 Document Path 测试页面 Document Length 页面大小 Concurrency Level 并发量 Time taken for tests 整个测试持续的时间 Complete requests 完成的请求数量 Failed requests 失败的请求数量 Total transferred 所有请求的响应数据的长度总和，包括每个http响应数据的头信息和正文数据的长度，这里不包括http请求数据的长度。仅仅为WEB服务器流向用户PC的应用层数据总长度 HTML transferred 所有请求的响应数据中正文数据的总和，数量上 = Total transferred - 响应数据头信息的长度 Requests per second 吞吐率,相当于LR中的每秒事务数，后面括号中的mean表示这是一个平均值 Time per request 用户平均请求等待时间,相当于LR中的平均事务响应时间，后面括号中的mean表示这是一个平均值 Time per request 服务器平均请求等待时间,每个连接请求实际运行时间的平均值 Transfer rate （单位时间内从服务器获取的数据长度）平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题。计算公式：（Total transferred : Time taken for tests） 特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79806358]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
</search>
