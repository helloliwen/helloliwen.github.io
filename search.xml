<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【链表】打卡3：删除单链表中顺数、倒数第K个节点]]></title>
    <url>%2F705cc6ed.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题。每道题会提供简单的解答。 【题目描述】 在单链表中删除顺数、倒数第 K 个节点。 【要求】 如果链表的长度为 N, 时间复杂度达到 O(N), 额外空间复杂度达到 O(1) 【难度】 士：★☆☆☆ ###【解答】 删除倒数第K个节点的时候会出现三种情况： 1、不存在倒数第 K 个节点，此时不用删除。 2、倒数第 K 个节点就是第一个节点。 3、倒数第 K 个节点在第一个节点之后。 所以我们可以用一个变量 length记录链表一共有多少个节点。 如果 length&lt; K，则属于第一种情况。 如果 length== K，则属于第二种情况。 如果 length&gt; K, 则属于第三种情况，此时删除倒数第 K 个节点等价于删除第 (length- k + 1) 个节点。 删除顺数第K个代码如下： 123456789101112131415161718192021222324252627282930313233343536//删除单链表中的第K个节点public static Node deleteKthNode(Node head,int K)&#123; if(head == null || K &lt; 1)&#123; return null; &#125; int length = 0;//链表的长度 Node node = head; while(node!=null)&#123; length++; node = node.next; &#125; if(length &lt; K)&#123; return head; &#125; node = head; //删除第一个 if(K == 1)&#123; node = node.next; return node; &#125; int i = 0; while(++i != K - 1)&#123; node = node.next; &#125; //删除最后一个 if(length == K)&#123; node.next = null; //node和head引用的是一个对象，所以返回head return head; &#125; if(length &gt; K)&#123; node.next = node.next.next; return head; &#125; return null;&#125; 删除倒数第K个代码如下： 1234567891011121314151617181920212223242526//删除倒数第K个节点public static Node deleteLastKthNode(Node head, int K) &#123; if(head == null || K &lt; 1) return head; Node node = head; int length = 0; while (node != null) &#123; length++; node = node.next; &#125; if (length == K) &#123; return head.next; &#125; if (length &gt; K) &#123; node = head; //删除第(num+1-k)个节点 //定位到这个点的前继 //只能循环length-K次，原解这里有误，多循环了一次。原解为length-K while (length - K -1 != 0) &#123; node = node.next; length--; &#125; node.next = node.next.next; &#125; return head;&#125; 测试代码 123456789101112131415public static void main(String[] args) &#123; int i = 1; Node head = new Node(i); Node node = head; while(++i&lt;6)&#123; node.next = new Node(i); node = node.next; &#125; //node = deleteKthNode(head,3); node = deleteLastKthNode(head, 2); while(node!=null)&#123; System.out.println(node.value); node = node.next; &#125;&#125; 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡2：如何优雅着反转单链表]]></title>
    <url>%2F124f68d0.html</url>
    <content type="text"><![CDATA[前言以专题的形式更新刷题贴，欢迎跟我一起学习刷题，相信我，你的坚持，绝对会有意想不到的收获。每道题会提供简单的解答，如果你有更优雅的做法，欢迎提供指点，谢谢 【题目描述】 反转单链表。例如链表为： 1-&gt;2-&gt;3-&gt;4 反转后为 4-&gt;3-&gt;2-&gt;1 【要求】 如果链表的长度为 N, 时间复杂度达到 O(n), 额外空间复杂度达到 O(1) 【难度】 士：★☆☆☆ 解答方法1 这道题还是挺简单的，当我们在反转一个节点的时候，把一个节点的后继改为指向它前驱就可以了。这里需要注意的点就是，当你把当前节点的后继指向前驱的时候，这个时候链表会被截断，也就是说后面的节点和当前节点分开了，所以我们需要一个变量来保存当前节点的后继，以防丢失。 具体代码如下： 代码如下 1234567class Node&#123; public int value; public Node next; public Node(int data)&#123; this.value = data; &#125;&#125; 主要代码 123456789101112131415//反转单链表public static Node reverseList(Node head)&#123; Node next = null;//指向当前节点的后继 Node pre = null;//指向当前节点的前驱 while(head!=null)&#123; next = head.next; //当前节点的后继指向前驱 head.next = pre; pre = head; //处理下一个节点 head = next; &#125; return pre;&#125; 方法二 这道题也可以用递归来做，假设 方法 reverse() 的功能是将单链表进行逆转。采用递归的方法时，我们可以不断着对子链表进行递归。例如对于如下的链表： 我们对子链表 2-&gt;3-&gt;4 进行递归，即Node newList = reverse(head.next)。递归之后的结果如下： 逆转之后子链表 2-&gt;3-&gt;变为了 4-&gt;3-&gt;2。注意，我刚才假设 reverse() 的功能就是对链表进行逆转。不过此时节点 1 仍然是指向节点 2 的。这个时候，我们再把节点1 和 2逆转一下，然后 1 的下一个节点指向 null 就可以了。如图： 递归的结束条件就是：当子链表只有一个节点，或者为 null 时，递归结束。代码如下： 12345678910111213141516//用递归的方法反转链表public static Node reverseList2(Node head)&#123; if(head == null || head.next == null)&#123; return head; &#125; //递归反转子链表 //第四次递归返回结果为 1 -&gt; 2 -&gt; 3 &lt;- 4 //head:3,next=nodeList,nodeList:4 null //第三次递归返回结果为 1 -&gt; 2 &lt;- 3 &lt;- 4 //... Node nodeList = reverseList2(head.next); head.next.next = head; //head:3 nodeList,nodeList:4 head, head.next = null; //head:3 null, nodeList:4 head,head:3 null return nodeList;&#125; 测试代码 1234567891011121314public static void main(String[] args) &#123; int i = 1; Node head = new Node(i); Node node = head; while(++i&lt;5)&#123; node.next = new Node(i); node = node.next; &#125; node = reverseList2(head); while(node!=null)&#123; System.out.println(node.value); node = node.next; &#125;&#125; 运行截图 第四次递归返回： 第四次递归处理返回： 第三次递归返回： 问题拓展题目：反转部分链表节点 【题目描述】 题目：给定一个单向链表的头结点head,以及两个整数from和to ,在单项链表上把第from个节点和第to个节点这一部分进行反转 例如： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null,from=2,to=4 结果：1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null 例如： 1-&gt;2-&gt;3-&gt;null from=1,to=3 结果为3-&gt;2-&gt;1-&gt;null 【要求】 1、如果链表长度为N，时间复杂度要求为O（N),额外空间复杂度要求为O（1） 2、如果不满足1&lt;=from&lt;=to&lt;=N,则不调整 【难度】 士：★☆☆☆ 【解答】 12345678910111213141516171819202122232425262728293031323334353637383940//反转部分链表节点public static Node reversePartList(Node head,int from,int to)&#123; if(head == null)&#123; return head; &#125; int length = 0;//记录链表的长度 Node node = head; Node pre = null;//记录from前一个节点 Node aft = null;//记录to后一个节点 while(node != null)&#123; length++; if(length == from-1)&#123; pre = node; &#125; if(length == to+1)&#123; aft = node; &#125; node = node.next; &#125; //判断给定的值是否合理 if(from &lt; 1 || from &gt;= to || to &gt; length)&#123; return head; &#125; //把from到to这部分链表进行反转 node = pre == null ? head : pre.next;//node指向部分链表的第一个节点 Node cur = node.next;//cur指向当前要处理的节点 node.next = aft;//先处理第一个节点 Node next = null; while(cur != aft)&#123; next = cur.next;//保存当前节点的下一个节点 cur.next = node; node = cur; cur = next; &#125; if(pre != null)&#123;//说明反转的中间 pre.next = node; return head; &#125; return node;&#125; 【运行图片】 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【链表】打卡1：生成窗口最大值数组]]></title>
    <url>%2F2ebd4c17.html</url>
    <content type="text"><![CDATA[做算法题了，题的难度我们分为“士，尉，校，将”四个等级。这个算法题的模块是篇幅比较小的那种模块。首先是给出一道题的描述，之后我会用我的想法来做这道题，今天算是算法题的第一道题，先来试试水。 问题描述（等级：尉）有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。 例如，数组为[4,3,1,5,4,3,7,5]，窗口大小为5时: [4 3 1 5 4] 3 7 5 max = 5 4 [3 1 5 4 3] 7 5 max = 5 4 3 [1 5 4 3 7] 5 max = 7 4 3 1 [5 4 3 7 5] max = 7 即窗口最大值数组为 result = {5, 5,7,7} 解答对于一道题，我一般会第一时间想到用暴力的方法来做，之后再来慢慢优化。 显然，对于这道题用暴力法来做还是挺简单了，窗口每次向右移动一位时，我们每次遍历窗口内的w个元素，然后求出此时窗口的最大值就可以了，用这种方法的时间复杂度是 O(w*n)。代码如下： 12345678910111213141516171819202122//暴力法求解，时间复杂度：O(n*w)//w:窗口内的w个元素public static int[] getMaxWindow(int[] arr,int w)&#123; int length = arr.length; if(w&lt;1 || arr == null || length&lt;w)&#123; return null; &#125; int[] result = new int[length-w+1]; int index = 0; //总共需要遍历result.length，也就是length-w+1次 for (int i = w-1; i &lt; length; i++) &#123; int max = arr[i]; //暴力求解直接从第 w-1个元素开始遍历 for (int j = i; j &gt; i-w; j--) &#123; if(arr[j]&gt;max)&#123; max = arr[j]; &#125; &#125; result[index++] = max; &#125; return result;&#125; 大家想一个问题，例如对于刚才例题中的数组： 第一次遍历的时候，max = 5 第二次遍历的时候，max = 5 我们刚才用暴力法的时候，无论是第一次还是第二次，我们都是把窗口内的所有元素都给遍历了一次，以此来寻找最大值，可是，真的需要这样吗？ 第一次遍历的时候，我们找出了max = 5, 那么在第二次遍历的时候，在窗口范围内，max = 5 左边的两个数1， 3 还有可能是最大值吗？也就是说，max=5 左边的窗口元素还要必要遍历吗？ 显然，max=5左边的窗口实际上是不必再遍历的了，也就是它不可能会是窗口的最大值。 而 max = 5 右边的 4 有可能会是窗口的最大值吗？由于窗口还会一直向右移动，所以 max = 5 右边的窗口元素还是有可能是某一个窗口的最大值的。 因此，我们可以用一个双向的队列，来记录有可能成为窗口最大值的下标，注意，这里指的是有可能。 像刚才的 max = 5 前面的 1,3 就不可能成为窗口的最大值了，而右边的4还是有可能成为窗口的最大值的。并且这个队列是有序的，队首存放的总是队列中的最大值， 我以这道题来演示一下，我们用result[] 数组来存放窗口最大值。 1、result[0] = 5 2、result[1] = 5; 3、result[2] = 7 其他的全部都要出队，因为7前面的5，4，3是不可能成为窗口最大值的了。 4、result[3] = 7 遍历完毕。这种方法的话时间复杂度是 O(n)。 我这里只是提供了思路与大致的做法，具体的代码实现还是有很多细节需要注意的。下面给出实现代码，代码会有详细的解释。 123456789101112131415161718192021222324252627282930313233//优化，时间复杂度：O(n)public static int[] getMaxWindow2(int[] arr,int w)&#123; int length = arr.length; if(w&lt;1 || arr == null || length&lt;w)&#123; return null; &#125; //用来保存成为最大窗口的元素 int[] result = new int[length-w+1]; int index = 0; //用链表充当双向队列 LinkedList&lt;Integer&gt; tempList = new LinkedList&lt;Integer&gt;(); //暴力法直接从i=w-1开始的 for (int i = 0; i &lt; length; i++) &#123; /*如果队列不为空，并且存放在队尾的元素小于等于当前元素，那么 队尾的这个元素就可以弹出了，因为他不可能会是窗口最大值。 当前元素指的是i增大时新加入的元素。*/ //经过检测，比较队首的元素也是可以的 while(!tempList.isEmpty() &amp;&amp; arr[tempList.peekFirst()]&lt;arr[i])&#123; tempList.pollFirst(); &#125; //把当前元素的下标加入队尾 tempList.addLast(i); //如果队首的元素的下标不在窗口范围内，则弹出 if(tempList.peekFirst() == i-w)&#123; tempList.pollFirst(); &#125; //由于队首存放的是最大值，所以队首总是对应窗口的最大值元素 if(i&gt;=w-1)&#123; result[index++] = arr[tempList.peekFirst()]; &#125; &#125; return result;&#125; 说实话，微信看代码确实有点难受，如果是在电脑浏览的话还好点，我在考虑要不要用截图的方式，不过如果是截图的话，有些人想要复制代码的话会复制不了，那我之后考虑把代码打包，你们后台回复获取。 来源：苦逼的码农（ID:di201805） （完）]]></content>
      <categories>
        <category>算法与数据结构</category>
        <category>链表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大三、研二的秋招备战路线（Java、大数据）]]></title>
    <url>%2F6e869c7c.html</url>
    <content type="text"><![CDATA[一、写作背景1.分享经验。从去年五月份到今年五月份，我面试了n家公司，也收了(n/2+10)家的offer，经历了两个春招一个秋招，其中有腾讯、今日头条、京东等offer。通过这篇文章分享一些经验，让后面的同学少走弯路。 2.解决问题。我有自己的学习群和知识星球，秋招快到了，避免不了被问关于秋招备战的问题。通过这篇文章把我自己能想到的路线和方法系统化先输出出来，以便于精细化提问，也为我自己节省时间。 二、秋招的意义1.秋招对于大企业是一场人才储备的战役，只有相对较大的企业才有秋招这个概念，它们有资本和资源花费大量精力进行宣传面试，可以提前发offer，坐等你毕业来上班。 2.对于学生来说，秋招是一场大型的招聘会，可能是这辈子离大厂最近的，机会最多的，也是唯一一次有精力面对这么多大厂的面试。 3.秋招offer在手，毕业时间我有。秋招拿了offer之后，对于你后面的面试也好，玩也好，都是起到非常关键的作用。至少心理负担不会那么大，面试起来也会更上手一次，不急不躁，玩起来也嗨，没有就业压力，毕业之前的时间随意安排。 三、不同的同学备战秋招的策略想要在秋招拿到offer，记住以下三点，接下去的案例都围绕这三点： 1.拿到足够多的面试机会， 别让自己的才华无处施展。 2.根据自己的简历形成系统性的知识，在面试中占据主动地位。 3.成不骄，败不馁。不断地从面试中总结经验，补自己的知识盲区。 案例1 有小公司Java实习经验，参与过两个项目的开发，算法不太行，基础一般，有大数据基础，自己做了个大数据项目。 目标：秋招想收到大数据offer，最好大厂。 分析：项目是长板，算法是短板，其他正常。所以要用最短时间把项目补扎实，成为优势，算法逐渐拉上来，其他时间扑理论基础上。 学习路线： 1.先把自己手头上的Java分布式项目弄明白，对其中的技术栈以及业务进行深入了解，并自己整理项目中的难点和亮点，最终能漂漂亮亮的写在简历上。先熟悉手头项目，一方面项目是面试的敲门砖，没有项目的简历会显得空洞，有项目可以避免项目经验不足被刷。另一方面，项目在面试中也占着很大比重，面试官比较喜欢从项目场景切入到理论知识。 2.每天安排时间刷算法，剑指offer、牛客leetcode148题，容易的先刷，刷一题整理一题到博客，先懂思路后懂代码，一天至少1题，争取重复刷几遍到会手写。大厂必问算法，而且大都剑指offer或者leetcode原题或变形题，有些只问思路。所以算法必刷，先刷思路，要整理起来，避免刷过即忘。 3.补Java集合源码、JVM、多线程。不看书，直接去网上搜面试题，最后把高频的整理了下来，直接刚面试题，借助博客辅助理解。同样，懂一题整理一题到博客。(整理的面经我学习群公告有)大数据岗位也要求Java知识，就算到时大数据面不上，面大厂Java还是妥妥的，会大数据知识可以加分。 4.熟悉大数据项目里的技术栈和流程，理解并整理常见大数据面试题。 5.对数据库、操作系统、计算机网络常见面试题进行熟悉。因为这些在面试中不会占很大比例，而且问来问去也是那几题，所以放到最后。 6.有时间再看相关书籍，系统梳理。因为准备时间有限，而我的目的又是通过秋招面试，所以都是从面试题开始刷起，零散整理，最后有时间再通过看书系统梳理。 7.投递小厂练手。当准备差不多的时候我就开始投递简历面试小公司，通过这样去补缺补漏。 案例2 目前正在公司实习，但已经确定不留在这家公司，打算秋招前夕辞职全身心备战。 目标：大厂的Java或者大数据offer 路线： 1.针对目前还在公司实习或者即将去公司实习的同学，如果已经确定不留在该公司，那么可以「面向简历实习」。面向简历实习，顾名思义，简历上需要什么就学什么。公司可以提供的资源就是项目，有文档给你看，不懂的还有老员工可以帮你讲解。你需要快速地了解项目所用的技术栈，以及应用的业务场景，尽可能多地去搜集相关资料和看源码。多听听老员工在探讨什么技术难点，以及解决方案是怎么实施的，不懂的就多问。 2.在实习期间估计也只有精力学习项目了，在职期间去刷算法或者补理论基础不太现实。当把你实习的项目有目的性地吃透之后，就可以全身而退，开始刷算法和补基础。 3.如果要找大数据相关，可以通过基础视频入门，自己做一两个项目，把简历写好。其余的可以参考案例1的学习路线。 案例3 懂点Java基础，有学校课设的管理系统项目，懂基本的数据结构。 目标：秋招能进一个知名的大厂做Java。 规划路线： 1.先用一些时间补1到2个项目，技术栈要相对好一些，这样能保证有面试大公司的机会和进小公司的机会。 2.当你能把相对较好的项目写在简历上，并且懂一部分技术栈的原理，那么先暂停对项目的学习，转战Java。先从Javase开始，到JVM，最后并发编程。se和JVM理论较多，先记住能理解的，再就是理解性的背，面试前才机械性记忆。并发编程可以从常见的多线程实现开始熟悉，自己敲敲常见的多线程实现demo，以及常用的几个线程池，再去比较每个实现方法的优缺点，参数。再由此切入到线程安全，并发锁等等。记得整理！ 3.由于数据结构算法基础不是很扎实，可以先从常见的7大选择，8大排序开始熟悉，尽量能手写代码。再就是刷剑指offer，统一先刷实现思路，遇到能理解的代码实现也可以记住，不然只记思路也可以。每天刷，记得整理！ 4.回过头深入理解项目的技术栈，常见的技术栈面试题，项目的业务场景怎么样，技术栈怎么和业务关联，可以找出哪些实现难点，有哪些可以当亮点。 5.投递小公司，收到面试通知之后刷数据库、操作系统等面试题。 案例4 非科班零基础。 目标：秋招尽量找份开发工作。 先看看Java基础视频入门，然后补项目、适当地补点Java基础，懂一些基本的JVM和多线程，数据结构和算法只看基本的排序和选择。当达到案例二的水平之后可以走它的学习路线进行进阶。 案例5 大三或研究生，机器学习或者其他方向，技术栈主要是Python，算法基础还行，有个Python小项目。由于机器学习竞争激烈，但自己又没核心竞争力，走Python后台或者爬虫岗位需求少。 目标：秋招找份大厂大数据开发或者后台开发 学习路线： 1.由于已经会Python语言了，所以学Java会比较快。可以快速地过一遍Java基础。 2.根据想走的方向针对性去准备1至2个项目，然后熟悉。可以参考案例1的学习路线去准备算法和基础。 3.把你的Python项目也写上，做大数据或者Java会Python也是加分的。 总结 秋招 = 项目 + 语言基础 + 计算机基础 + 算法 + 软实力 争取在项目中有： 微服务：SpringCloud、SpringBoot、Dubbo等 分布式服务框架：Zookeeper等 消息队列：Kafka、RabbitMQ、RocketMQ等 内存数据库：Memcached、Redis等 分布式搜索引擎：Solr、Lucene、ES等 大数据框架：Hadoop、Hive、Spark等 语言基础： Javase、集合源码、JVM、多线程、IO等 计算机基础： 数据库、计算机网络、操作系统 算法: 基本的排序和选择算法、剑指offer、牛客148题Leetcode等 四、部分面试题整理JavaJava散列表，树对应的容器类，hashmap如何解决冲突 Java实现生产者和消费者的三种方法 init方法与clinit方法的区别 Java中的引用 Java对象的创建过程 Java中创建子类实例时会创建父类实例？ Java的类加载机制 为什么会出现锁机制？ 抽象类和接口的区别 双亲委派模型：启动加载器、扩展加载器、应用程序加载器 重载与重写 Java的类型擦除 简述Java Object类中的方法有哪些 char可以存储汉字嘛？ 抽象类和接口的区别 静态分派与动态分派 HashMap与HashTable的区别 什么时候使用HashMap？它有什么特点？ HashMap的基本原理及内部数据结构 HashMap的put和get操作 简述Java中的深拷贝与浅拷贝，C++中的浅拷贝和深拷贝 解释一下static块和static变量的执行顺序 equals()的重写规则 Java中如何创建线程？ JDK1.8新特性 JVMJVM内存布局 JVM垃圾回收机制 JVM垃圾回收算法 哪些对象在老年代？ 从年轻代到老年代执行的时间以及发生转移的场景 为什么存在GC？ 简单可达性分析 Minor GC安全检查 垃圾回收器 引用记数法和可达性算法 类加载机制过程 双亲委派模型 双亲委派机制 Java集合排序算法比较 Hashmap是线程安全的吗?为什么？ ArrayList与LinkedList区别 HashMap、LinkedHashMap和TreeMap 冒泡排序的优化以及快排过程及优化 红黑树 JDK7与JDK8中hashmap的区别 hashmap的初始容量为什么设置为16？ 平衡二叉树的插入删除操作 并发编程锁分段技术、ConcurrentHashMap、扩容 Java同步线程有哪些方式？ volatile 和 synchronized的区别 讲一下同步异步（进程和IO） synchronized和volatile的区别？ 线程安全 对象的内存布局 哪些是线程安全的容器？ ConcurrentHashMap介绍 线程启动start和run HashMap为什么线程不安全？ 简述Java内存模型的happen before原则 volatile的原理和实现机制 || volatile到底如何保证可见性和禁止指令重排序的？ volatile关键字的两层语义 || 可见性 volatile保证原子性吗？ volatile能保证有序性吗？ ZookeeperDubbo简介及以Zookeeper为注册中心 Zookeeper的leader选举过程 2PC and 3PC 简述Zookeeper。。。watcher 简介ZAB 简述paxos算法 Zookeeper如何保证数据的一致性？ 叙述ZAB集群数据同步的过程 Zookeeper中的ACL Zookeeper底层实现数据一致性 Zookeeper在yarn框架中如何实现避免脑裂的? 大数据Kylin： 简介Kylin Kylin的工作原理 Kylin的技术框架 Cube、Cuboid 和 Cube Segment Kylin 对维度表的的要求 Cube的构建过程 全量构建和增量构建的区别 流式构建原理 HiveHive内部表与外部表的区别 Hive与传统数据库的区别 Hiverc文件 Hive分区 Hive分区过多有何坏处以及分区时的注意事项 Hive中复杂数据类型的使用好处与坏处 hive分桶？ Hive元数据库是用来做什么的，存储哪些信息？ 为何不使用Derby作为元数据库？ Hive什么情况下可以避免进行mapreduce？ Hive连接？ Hive MapJoin? Hive的sort by, order by, distribute by, cluster by区别？ Hadoop计算框架特性 Hive优化常用手段 数据倾斜整理(转) 使用Hive如何进行抽样查询？ StormStorm的可靠性如何实现？包括spout和bolt两部分 怎么提高Storm的并发度？ Storm如何处理反压机制？ Storm中的Stream grouping有哪几种方式？ Storm的组件介绍 Storm怎么完成对单词的计数？ 简述Strom的计算结构 SparkSpark的运行模式 RDD是如何容错的？ Spark和MapReduce的区别 说一下Spark的RDD 自己实现一个RDD，需要实现哪些函数或者部分？ MapReduce和Spark的区别 Spark的Stage是怎么划分的？如何优化？ 宽依赖与窄依赖区别 Spark性能调优 Flink、Storm与Spark Stream的区别（未） 说下spark中的transform和action RDD、DataFrame和DataSet的区别 Spark执行任务流程（standalone、yarn） Spark的数据容错机制 Spark技术栈有哪些组件，每个组件都有什么功能，适合什么应用场景？ Spark master使用zookeeper进行HA的，有哪些元数据保存在Zookeeper？以及要注意的地方 driver的功能是什么？ spark端口 RDD有哪几种创建方式 map和flatmap的区别 Spark的基本工作流程 HadoopMR的Shuffle过程 Yarn的工作机制，以及MR Job提交运行过程 MapReduce1的工作机制和过程 HDFS写入过程 Fsimage 与 EditLog定义及合并过程 HDFS读过程 HDFS简介 在向HDFS中写数据的时候，当写某一副本时出错怎么处理？ namenode的HA实现 简述联邦HDFS HDFS源码解读–create() NameNode高可用中editlog同步的过程 HDFS写入过程客户端奔溃怎么处理？（租约恢复） Kafkakafka介绍 Kafka与传统消息队列的区别？ kafka的零拷贝 kafka消息持久化和顺序读写？ 网络简述TCP和UDP的区别 七层协议每一层的任务及作用 简述http状态码 简述http协议与https协议 简述SSL协议 解析DNS过程 三次握手，四次挥手的过程？？为什么三握？？ 剑指offer常问字符串转换成整数 链表中倒数第K个结点 二维数组中的查找 替换空格 从尾到头打印链表 重建二叉树 用两个栈实现队列 斐波那契数列及变形题 二进制中1的个数 在O(1)时间删除链表结点 调整数组顺序使奇数位于偶数前面 反转链表 合并两个排序的链表 树的子结构 二叉树的镜像 顺时针打印矩阵 栈的压入、弹出序列 二叉搜索树的后序遍历序列 二叉树中和为某一值的路径 数组中出现次数超过一半的数字 最小的k个数 连续子数组的最大和 第一个只出现一次的字符 两个链表的第一个公共结点 链表中环的入口结点 二叉树的镜像 跳台阶 变态跳台阶 矩形覆盖 从上往下打印二叉树 二叉搜索树的第K个结点 五、准备过程中的注意事项1.心理压力大。怕面试，面试怕被怼，一直逃避。面试是一个会上瘾的东西，刚开始几场会比较难受，但不用怕，一个优秀的面试官会让你有一个舒适的面试体验，而且面试是一个检验自己水平的过程。刚开始可以选择小公司，即使面的不好也没事，面上了也不一定去，放轻松。 2.沉迷学习，无法自拔。秋招已经开始了，自己总想着还没准备好，想把所有的东西都学完之后再去投。参考过秋招的人都知道，知识是永远学不完的，永远没有准备好的那一刻，当你能把简历写出来的时候就开始投吧。面试不是你很厉害就一定能过的，也有运气成分在里面，而且边面试边总结会成长很快的。 3.无论学习理论，项目，还是算法，一定要边学边总结。光输入看似都会了，输出才是王道，不然脑子依然一盘散沙，东拼西凑。面试之前这些平时总结的内容就是你的杀手锏。 4.怕理论懂太多，实操太少。通过以上内容，你会发现我一直强调理论性的东西，无论是项目的学习或者是语言。在校生本来就是以理论分高低，大家都知道面试问这些，但为什么总有人回答不上来。实操的话自己在学校敲的跟公司比起来都是小儿科，都得重新学，重要的是先拿到offer。学会把面试和日常学习区分开。 5.一定要注重简历上的项目。前面提到，简历没有相关项目去支撑你求职的岗位，即使简历写自己的理论多么强，基础多么扎实都是很苍白无力的。这点我在面阿里的时候吃过亏，前几天学习群的一个小兄弟也吃了这个亏。企业说注重理论基础是建立在有项目的基础上，而不是只有理论基础。 6.在简历的排版和内容上要好好做文章。正常的面试都是从自我介绍开始，然后面试从上到下浏览简历，所以你要把你的优点尽量往前面放，而不是把兴趣爱好，个人技能这种比较虚的东西放第一第二模块，而实习经历，项目经验放最后。 7.实习经历是否影响秋招？理论上是的，有实习经历尤其是大厂实习都会在秋招中有优势的，但这种优势不是绝对性优势。实习的目的也是锻炼你的动手能力，提高你的工程能力，所以只要能把项目搞定，问题不是很大。但是建议你还是多面试，项目经历可以补，面试经验补不了，终归要出去试试水的，所以要多面试。 8.为什么零基础的人学完基础就马上学习项目？我在校园招聘的时候，打印了10个简历，投了10家，全都拿了offer，当然都是小公司。面试问什么呢？面向对象的概念，Java的特点等等这些极其基础的，剩下的都是围绕着项目问。有些公司面试都没有直接说有项目那就好办了，接着问什么时候能上班，要现场给offer。案例1的人就是我，简历有两个分布式项目和一个大数据项目。所以我经常跟那些担心找不到工作的同学说，只要你把项目鼓捣明白，总有公司会要你的，就是大和小的问题。 六、针对简历复习一直强调把简历写好，那么怎么针对简历去复习？ 1.面试前夕，打开简历，拿一张白纸，把自己当成面试官，手撸思维导图。从自我介绍开始，然后就是项目介绍，其次就是自己负责的部分以及项目难点。 2.技术面试正常两个部分，一个基础，另一个项目技术栈。基础就是网络，数据结构，算法这些，这些是无论你简历上写不写都问的。其次就是你简历描述的技术栈。 3.正常面试官会问你在项目中做了什么，然后以这个为点切入进去。 举个例子：我在项目中用了多线程，提高了读取效率。那么项目官肯定接着，你如何创建多线程的？我回答：线程池。那你知道创建线程有哪些方法吗？有哪些线程池吗？怎么保证线程安全呢？等等。 如果你项目中的问题会把自己问死，也就是挖坑，那我建议你换个。这部分写的好就是给自己开路，弄不好就自己填坑了。 4.项目技术栈来不及复习怎么办？打开谷歌搜索一下对应技术栈常问面试题，或者平时多刷牛客网，你就知道哪些题目是高频的。 5.扬长避短。对于不熟的框架，尽量不写简历上，如果写了并且被面试官问到就直接跟他说这个正在学，用的比较少。正常面试官也有数，你负责的部分用到的技术栈他会问的深一些，这块自己掂量一下。 7.针对基础，平时多积累。多整理博客也是为了临时突击，像网络，数据库，操作系统，问来问去也是那几题。多看面经几十遍，不懂原理也能吟。 8.针对技术框架，除了基本原理之外，也要准备应用场景。这块对应届生来说要求不会很高，社招的话要整理每个原理的应用场景，相对来说会细一点，源码加分。 9.针对算法。算法是贯彻在日常学习的，我刷算法的策略就是理论先上，其次代码，最后优化。是把所有的算法先刷一遍理论，第二遍再回头代码哦，也都有整理思路的。当然，也要准备常用算法，快排，冒泡的手撸代码。 大部分还是吹吹思路就可以了，所以我先前面提到了先刷实现思路。 10.公司面试题优先。去牛客、看准或拉钩查对应公司的面试题，这个命中概率比较大。 11.公司产品业务准备，最好也看看竞品，让面试官刮目相看。之前面了一家腾讯系的，从它的融资开始讲。 12.面试官正常从上到下看简历，记得布好局。自己面试自己的时候多想想怎么把上面的知识点不经意的串到你熟悉的知识点。 为什么说不经意呢？要是你直接跟面试官说，我这个框架不熟，对***比较熟，有点尴尬的。所以要不经意的。 当面试官问你hashmap原理的时候，比如说你多线程比较熟，你最后一句提一下它是线程不安全的。又或者你数据结构比较厉害，那就说它是红黑树。又或者你对Lambda，JDK1.8一些特性比较熟，那就可以说它是在JDK1.8优化的。 平时还是得多整理，面试之前复习一手博客，一手面经，一手面试的思维导图。 最后说一句：抓住学生红利期，无论机会还是精力都有可能在巅峰时期。 来源：大数据肌肉猿（ID：BigData-BigMuscle） （完）]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用GitHub+Hexo搭建这个博客平台]]></title>
    <url>%2F62ffb8b5.html</url>
    <content type="text"><![CDATA[一、为什么要写博客​ 当自己主动学习，主动思考其效率和对个人的提升无疑是高于被动接受的。然而使你提高最大的是主动说出自己认知，把自己的知识和理解传达给他人，这种方式是对你提升无疑是最显著的。 引用《码农翻身》里的一段话： 对自己狠一点，开始写作吧。 ​ 自己心里觉得对一个技术点已经掌握了，但是当我试图给别人讲述的时候，发现并不能轻松自如、深入浅出地讲出来，这就说明了一个问题：自以为掌握了，其实并没有真正掌握。 ​ 为什么要有这门技术、这门技术解决了什么问题，然后才是这门技术是怎么使用的。 ​ 整理资料和思考的过程是很珍贵的，只有这样才能把信息变成自身的知识。不写出来，很容易放弃深度思考。 ​ 我们已经进入了一个碎片化的时代，我们的大脑已经养成了碎片化的习惯，一天不看碎片化的信息就觉得不舒服，这样下去会慢慢的丧失深度思考的能力。写作会逼着你去思考，梳理知识体系，防止自己被碎片化所填满。 ​ 最后，能够坚持的人才更有可能成功！ ​ 为什么你要写博客？——陈素封 二、为什么使用GitHub+Hexo​ 我很喜欢掘金的风格，里面也有很多大牛，但是因为没有文章分类，只好作罢。CSDN是很多人的入门博客，但是不屏蔽广告完全没法看。简书也不错，但是个人感觉总少点技术氛围。其他博客平台没有使用过，不作评论。至于为什么选择GitHub+Hexo，可能出于成就感吧，而且给我的感觉完全像一张白纸可以在上面任意发挥，而且文章有分类、没有广告、风格很简约，喜欢，所以选择这个平台。 ​ 至于其他平台的评论，参看这篇文章：程序员可以选择哪些平台写技术博客？，如果提示无法访问，使用搜狗微信平台搜索文章。 三、准备环境1.关于Hexo、Node.jsHexo的工作机制 ​ 由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 ​ Hexo基于Node.js，将/source文件夹下的资源(文章、图片、模板)，按照预定的配置文件，转换成静态页面放置到/public目录下。如果需要预览或者部署，hexo会把public作为web目录处理。具体的细节可以通过实践接下来的步骤，来逐渐明晓。 Hexo 特点 支持Markdown: 支持Markdown意味着你可以把经历从排版中解放出来 轻量: 无需拥有后台及数据库，专心写好你的文章 一键部署: 可以通过Git或者ftp来将生成的静态页面部署到服务器或者主机空间中 插件丰富: 丰富的插件可以满足你的各种需求 Node.js Node.js是一个基于Chrome V8引擎的JavaScript运行环境，为我们的Hexo提供js脚本的运行环境。而npm则 是一个JavaScript的包管理工具。主流的很多语言都会有自己的包管理器，Hexo官网教程中使用的是npm。 优势： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等。 博客搭建过程 一个博客的搭建过程分为三步： 编写：包含内容的书写与格式的配置 构建：从编写的原始内容生成可发布的最终内容 发布：让待发布的内容对读者可见 依托于博客平台（如博客园、新浪博客等）发布内容的用户只需要关注编写部分，但要搭建一个独立的个人博客则以上三方面都需要关心。幸运的是，现在有大量的工具帮助我们简化这个过程：丰富的 Markup 语言简化了编写；强大的静态站点生成器简化了构建；友好的托管平台简化了发布。 这个博客的诞生也得益于这些工具： 编写：使用 Markdown，内置大量层级、列表、超链接、代码等的简便语法支持 构建：使用 Hexo，几条命令完成生成、预览、发布步骤 发布：使用 GitHub Pages 进行托管，方便又免费 2.准备工作（1）有一个Github账户 （2）安装Node.js Node.js官网下载LTS版本，并安装，配置环境变量，在命令行中通过查看版本。 （3）安装Git Git官网下载，安装，配置环境变量，使用git –version查看是否安装成功。 （4）注意事项 ​ 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； ​ hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； ​ hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的。 3.设置使用ssh提交到Github Pages设置用户名和邮箱 初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are. 你需要运行命令来配置你的用户名和邮箱： 12$ git config --global user.name "yourName"$ git config --global user.email "your_email@example.com" 注意：引号内请输入你自己设置的名字，和你自己的邮箱。此用户名和邮箱是git提交代码时用来显示你身份和联 系方式的，并不是github用户名和邮箱。 git使用ssh密钥 git支持https和git两种传输协议。相应的，github分享链接时会有两种协议可选：git格式和https格式。 使用https协议，每次pull, push都会提示要输入密码。 使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦。 （1）生成密钥对 ​ 大多数 Git 服务器都会选择使用 SSH 公钥来进行授权，SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。 首先需要检查你电脑是否已经有 SSH key ​ 运行 git Bash 客户端，输入如下命令，看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建。 12$ cd ~/.ssh$ ls （2）创建一个 SSH key，直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)： 1$ ssh-keygen -t rsa -C "your_email@example.com" 添加公钥到你的远程仓库（github） （1）查看你生成的公钥： 1$ cat ~/.ssh/id_rsa.pub （2）登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key （3）然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 （4）验证 1$ ssh -T git@github.com 如果看到 1Hi helloliwen! You've successfully authenticated, but GitHub does not provide shell access. 恭喜你，你的设置已经成功了。 修改git的remote url 在hexo目录下，使用命令 git remote -v 查看你当前的 remote url 123$ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push) 如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议），你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url。 复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。 1git remote set-url origin git@github.com:someaccount/someproject.git 然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。 然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了。 4.创建仓库新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ 由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； 创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 四、Hexo博客安装使用1.安装hexo（1）首先需要知道两个配置文件，需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 Hexo配置文件：hexo/_config.yml NeXT主题配置：hexo/themes/next/_config.yml （2）安装hexo 1npm install hexo-cli -g （3）选择一个目录作为hexo站点目录，然后进入目录，执行以下命令初始化： 1hexo init hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： （4）生成并启动服务 12hexo g #生成 或 hexo generate hexo s #启动本地服务器 或者 hexo server，这一步之后就可以通过http://localhost:4000查看了 （5）更新hexo 1npm update -g hexo （6）Windows下npm安装Hexo失败的解放方案 因为国外源网速不好的原因，安装hexo失败，可以采用如下方案： 12345678# 添加淘宝源npm install -g cnpm --registry=https://registry.npm.taobao.org# nrm类似包管理器cnpm install nrm -gnrm ls# 使用淘宝nrm use taobaonpm install -g hexo-cli 参考：(node.js)使用淘宝镜像安装hexo失败 2.安装主题（1）安装主题NexT（当然还有很多其他主题，可以去选择自己喜欢的主题：官方主题，本人选择NexT） 1git clone https://github.com/iissnan/hexo-theme-next themes/next （2）启用主题 打开Hexo配置文件：hexo/_config.yml，修改 1theme: next （3）设置语言 hexo/_config.yml 1language: zh-Hans （4）更新主题 cd 到主题文件夹，执行命令（需要隐藏的.git文件夹没有被删除） 1git pull 3.创建博客及常用命令12hexo new "文章名" #新建文章hexo new page "页面名" #新建页面 那么hexo new &#39;postName&#39;命令和hexo new page &#39;postName&#39;有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; 生成如下： 最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 常用命令及缩写 123456789hexo cl = hexo clean # 清除缓存hexo n = hexo new # 新建文章hexo g = hexo generate # 生成静态页面至public目录hexo s = hexo server # 启动服务hexo d = hexo deploy # 部署到GitHubhexo h = hexo help # 查看帮助hexo v = hexo version #查看Hexo的版本#会根据gulpfile.js中的配置，对public目录中的静态资源文件进行压缩。hexo g &amp;&amp; gulp 组合命令： 123hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo dhexo s -g #生成并本地预览hexo d -g #生成并上传 4.部署上传之前：在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 首先安装扩展文件 1npm install hexo-deployer-git --save 其次需要配置Hexo配置文件：hexo/_config.yml 1234567891011#正确写法deploy: type: git repo: git@github.com:cczeng/cczeng.github.io.git #这里的网址填你自己的，中间有空格要注意 branch: master #错误写法deploy: type: github repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master 接下来就是使用Hexo部署到我们的Github仓库上 1hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 接下来等待几分钟就可以打开浏览器，输入：https://username.github.io就可以看到博客了。 5.常见问题（1）如何让博文列表不显示全部内容：在合适的位置加上&lt;!--more--&gt;即可 （2）电脑重装了系统/多台电脑写博客？那就赶紧戳这里：使用hexo，如果换了电脑怎么更新博客？ （3）想要给网站添加图片？方式一：使用图床。国内的有：微博图床、阿里云OSS、腾讯云COS、七牛云。具体可以查看这里：嗯，图片就交给它了。方式二：在根目录 source 下建立一个文件夹，加入取名叫upload-images，把图片放在这个文件夹下，然后在博客中连接就是：/upload-images/图片名，执行hexo g的时候此文件夹自动生成到public中。 五、Hexo配置1.基本信息配置基本信息包括：博客标题、作者、描述、语言等等。打开_config.yml，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 其他配置可参考站点配置 2.设置头像及网站的icon首先把图片放在source/images目录下，并修改配置文件themes/next/_config.yml 12avatar: /images/avatar.jpgfavicon: /images/favicon32.ico 3.Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 themes/next/_config.yml 找到Scheme Settings 123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 4种风格大同小异，本人用的是Pisces风格，你们可以选择自己喜欢的风格。 4.菜单设置刚开始默认的菜单只有首页和归档两个，修改菜单设置文件： themes/next/_config.yml 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 #about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 需要哪个菜单取消注释就好了。关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题文字可以去themes/next/languages/zh-Hans.yml中参考或修改。||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 5.侧栏设置侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等。打开 themes/next/_config.yml 找到sidebar字段 1234567891011121314sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 6.添加标签页面新建页面： 1hexo new page tags 设置页面（编辑 source/tags/index.md）： 123456---title: tagsdate: 2018-09-12 10:30:31type: &quot;tags&quot;comments: false--- 修改菜单（编辑 themes/next/_config.yml）： 12menu: tags: /tags 7.添加分类页面新建页面： 1hexo new page categories 设置页面（编辑 source/categories/index.md）： 12345---title: categoriesdate: 2018-09-12 10:32:08type: &quot;categories&quot;--- 修改菜单（编辑 themes/next/_config.yml）： 12menu: categories: /categories/ 使用： 1234567---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端 #一级分类 - jQuery #二级分类--- scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你 自己的需求添加一些默认值。打开scaffolds/post.md文件，在tages:上面加入categories:，保存后，之后执行 hexo new 文章名命令生成的文件，页面里就有categories:项了。 123456title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: tags: keywords: description: 8.修改二级分类符号二级分类使用 1234categories: - 笔记- 题解- t themes\next\layout_macro\post.swig 123&#123;% if cat_length &gt; 1 and loop.index !== cat_length %&#125; &#123;&#123; __(&apos;symbol.comma&apos;) &#125;&#125;&#123;% endif %&#125; __(‘symbol.comma’)就是二级分类所使用的符号，具体定义在themes\next\languages\zh-Hans.yml 1234symbol: comma: &apos;， &apos; period: &apos;。 &apos; colon: &apos;：&apos; 9.站内搜索功能 hexo-generator-searchdb 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 hexo-generator-search 安装 hexo-generator-search 插件 1$ npm install hexo-generator-search –save 配置站点文件_config.yml: 1234# 站内搜索search: path: search.xml field: post 配置主题文件_config.yml: 12local_search: enable: true 10.修改字体大小和字体 字体大小 修改文件：\themes\next\source\css\ _variables\base.styl 1$font-size-base 字体 全局字体：\themes\next_config.yml 1family: Lato 字体文件：\themes\next\source\css_variables\base.styl 123$font-family-chinese = "PingFang SC", "Microsoft YaHei"$font-family-base = $font-family-chinese, sans-serif$font-family-base = get_font_family('global'), $font-family-chinese, sans-serif if get_font_family('global') 参考：Hexo博客之改字体 11.设置文章字体的颜色、大小如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color="#FF0000"&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color="#FF0000"&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 12.文字居中显示1&lt;center&gt;这一行需要居中&lt;/center&gt; 13.显示文章更新时间在文章列表中我们一般都能看的文章的发布时间。对于一些文章来说，比如涉及到文章中的内容过期，或者软件的升级等等，我们都会进行一些修改。这种情况下，我们就像把文章的更新日期也显示处理，也能让读者看的我们写的之前的文章也是有更新的，不会过时的。 显示更新日期 在 Next 主题下添加显示更新时间非常简单，找到themes/next/_config.yml的 post_meta部分： 123456# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true 将 updated_at: false 修改为 updated_at: true 即可。通过 hexo s -g 预览，可以看到已经自动添加上了更新日期。 自定义显示更新日期 对于某些特殊的文章，我们也想能够自定义这个更新的日期。当然，更改起来也非常的简单，Hexo默认就支持更新日期的配置。在每一篇文章的 Front-matter 部分，只要添加 updated 参数即可。 1234---date: 2017-05-24 22:07:58updated: 2017-12-01 10:35:18--- 14.去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开themes/next/_config.yml，找到 123456789# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: false # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false 15.使用gulp压缩资源在站点执行以下命令 12$ npm install gulp -g$ npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save 然后查看gulp的安装版本 123$ gulp -vCLI version: 2.2.0Local version: 4.0.2 如果gulp是3.X的版本，由于函数的写法不同，所以以前的部分博客使用了以下写法，导致报错： 1234// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html', 'minify-css', 'minify-js']); 错误：AssertionError: Task function must be specified。 gulp4.x本部请在在博客根目录新建gulpfile.js文件来编写gulp task对应的函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss(&#123; compatibility: 'ie8' &#125;)) .pipe(gulp.dest('./public'));&#125;);// 压缩jsgulp.task('minify-js', function() &#123; return gulp.src('./public/js/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩图片gulp.task('minify-images', function() &#123; return gulp.src('./public/images/**/*.*') .pipe(imagemin( [imagemin.gifsicle(&#123;'optimizationLevel': 3&#125;), imagemin.jpegtran(&#123;'progressive': true&#125;), imagemin.optipng(&#123;'optimizationLevel': 7&#125;), imagemin.svgo()], &#123;'verbose': true&#125;)) .pipe(gulp.dest('./public/images'))&#125;);// 默认任务gulp.task('default', gulp.parallel( 'minify-html','minify-css','minify-js','minify-images')); 其中：gulp.parallel()是gulp4中的新写法。 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 参考： 运行gulp项目报错：AssertionError: Task function must be specified。 利用gulp对Hexo博客压缩并一键之部署 hexo 优化之——使用 gulp 压缩资源 16.设置一键部署在package.json中加入如下script 12345"scripts": &#123; "push": "hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d"&#125; 然后在部署的时候只需要运行 1$ npm run push 17.文章置顶Hexo博客中，默认的情况是按照时间倒序来排列的，即新发布的文章排在前面。虽然有一种很简单的方法，就是更改文章的发布时间到一个“未来”的时间点，这样虽然能让文章一直置顶，但是给人的体验和感觉是非常不好的。今天介绍一种非常简单而且体验上也非常好的方法。 安装node插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 添加标记 在需要置顶的文章的 Front-matter 中加上 top: true（top 的值可以是 true，也可以是 n，n 越大代表级别越高） 即可。比如： 123---top: true--- 设置置顶标志 打开：/themes/next/layout/_macro/post.swig目录下的文件，定位到 &lt;div class=&quot;post-meta&quot;&gt; 标签下，插入如下代码： 12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 18.鼠标点击小红心的设置将 love.js 文件添加到\themes\next\source\js\src文件目录下。修改\themes\next\layout\_layout.swing文件， 在文件的后面、标签之前添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 19.背景的设置将 particle.js文件添加到\themes\next\source\js\src文件目录下。修改\themes\next\layout\_layout.swing文件， 在文件的后面、标签之前添加以下代码： 12&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; 20.开启阅读进度记录themes/next/_config.yml 12345678910111213141516171819# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 自动将页面滚动到&lt;!-- more --&gt;标记下的地方。scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.# 自动保存每篇文章或页面上一次滚动的地方。save_scroll: true# Automatically excerpt description in homepage as preamble text.# 自动在首页对文章进行摘要描述作为前言文本。excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 不推荐使用自动摘要。# 请在文章中使用&lt;!-- more --&gt;标志来精确控制摘要长度。auto_excerpt: enable: true length: 200 21.添加文章字数统计一般为了让读者大概估计阅读文章的时间，有的文章在头部会显示总的字数统计。 启用字数统计 首先安装一个依赖插件： 1npm i --save hexo-wordcount 然后修改themes/next/_config.yml中的 post_wordcount 部分： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true //底部是否显示“总字数”字样 wordcount: false //文章字数统计 min2read: false //文章预计阅读时长（分钟） totalcount: false //网站总字数，位于底部 separated_meta: true //是否将文章的字数统计信息换行显示 22.使用LeanCloud添加文章阅读次数统计参考：为NexT主题添加文章阅读量统计功能 23.添加站点访问次数统计站点访问计数有名的就是不蒜子 - 极简网页计数器，使用起来非常方便。 1、安装脚本。打开 themes/next/layout/_partial/footer.swig，添加脚本： 12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2、显示站点总访问量 themes/next/layout/_partial/footer.swig 要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 3、显示单页面访问量 要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 123&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 备注：代码中文字是可以修改的，只要保留id正确即可。 24.绑定域名使用hexo+github搭建免费个人博客详细教程 25.SEO优化SEO优化对于网站是否能被搜索引擎快速收录有很大帮助，因此适当做一些SEO还是有必要的。但是请注意，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名。谷歌对此没有限制。 首先修改站点URL _config.yml 1url: https://helloliwen.github.io 添加 sitemap 插件 安装 hexo-generator-sitemap 插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 配置（编辑 _config.yml）： 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 注意：这个地方的空格要符合语法规范！ 提交sitemap。参考next主题官方解答：添加 Google Webmaster tools 验证 配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml。其中sitemap.xml适 合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。 其次，在robots.txt中添加下面的一段代码： 12Sitemap: &lt;your-domain-name&gt;/sitemap.xmlSitemap: &lt;your-domain-name&gt;/baidusitemap.xml 参考这篇文章：hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌） 提交sitemap.xml 添加蜘蛛协议 robots.txt 新建 source/robots.txt： 12345678910111213141516User-agent: *Disallow: /CNAMEDisallow: /READMEAllow: /Allow: /about/Allow: /archives/Allow: /categories/Allow: /tags/Allow: /css/Allow: /images/Allow: /js/Allow: /lib/Sitemap: &lt;your-domain-name&gt;/sitemap.xml Hexo NexT主题首页title的优化 更改文件：\themes\next\layout\index.swig，将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改成 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页标题会更符合网站名称 - 网站描述这习惯。 进阶，做了seo优化，把关键词也显示在Title标题里，可改成 1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过chinaz的seo综合查询检查。 其他SEO优化 SEO优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，SEO优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上keyword和描述在代码中，我们应该写出能让浏览器识别的语义化HTML，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置nofollow标签，避免spider爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为spider会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样spider是很有可能爬到我们中的站点的，so…. 网站外链的推广度、数量和质量 网站的内链足够强大 网站的原创质量 网站的年龄时间 网站的更新频率（更新次数越多越好） 网站的服务器 网站的流量：流量越高网站的权重越高 网站的关键词排名：关键词排名越靠前，网站的权重越高 网站的收录数量：网站百度收录数量越多，网站百度权重越高 网站的浏览量及深度：用户体验越好，网站的百度权重越高 参考： HEXO SEO 高级优化 hexo高阶教程：SEO优化、代码同时托管github和coding、多终端编辑hexo博客、使用gulp压缩你的代码、增加七牛图床 26.添加链接持久化​ SEO搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于SEO，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文。 ​ hexo 默认的链接是http://xxx.yy.com/2013/07/14/hello-world这种类型的，这源于站点配置文件config.yml里的配置: permalink: :year/:month/:day/:title/。这种默认配置的缺点就是当我们创建的博文名包含中文的名的时候，url 链接地址经常会变成一串很长的难以理解的字符串，不利于博文的链接分享，以及搜索引擎搜索，另外就是年月日都会有分隔符。我们可以让 url 链接持久化来解决这个问。 （1）安装hexo-abbrlink插件 1$ npm install hexo-abbrlink –save （2）修改站点配置文件_config.yml：permalink: post/:abbrlink.html 添加 abbrlink: 123456permalink: post/:abbrlink.html # :year/:month/:day/:title/ # 文章的永久链接格式permalink_defaults: # 永久链接中个部分的默认值# abbrlink config 需安装插件hexo-abbrlinkabbrlink: alg: crc32 # 算法： crc16(default) and crc32 rep: hex # 进制： dec(default) and hex 27.添加评论系统Hexo博客(14)添加来必力评论系统 28.开启打赏功能编辑 themes/next/_config.yml： 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 六、其他1.自己安装插件一览1234567891011121314151617181920212223$ npm list --depth 0hexo-site@0.0.0 D:\java\hexo+-- gulp@4.0.2+-- gulp-htmlclean@2.7.22+-- gulp-htmlmin@5.0.1+-- gulp-imagemin@5.0.3+-- gulp-minify-css@1.2.4+-- gulp-uglify@3.0.2+-- hexo@3.7.1+-- hexo-abbrlink@2.0.5+-- hexo-deployer-git@0.3.1+-- hexo-generator-archive@0.1.5+-- hexo-generator-baidu-sitemap@0.1.5+-- hexo-generator-category@0.1.3+-- hexo-generator-index@0.2.1+-- hexo-generator-index-pin-top@0.2.2+-- hexo-generator-searchdb@1.0.8+-- hexo-generator-sitemap@1.2.0+-- hexo-generator-tag@0.2.0+-- hexo-renderer-ejs@0.3.1+-- hexo-renderer-marked@0.3.2+-- hexo-renderer-stylus@0.3.3`-- hexo-server@0.3.3 更新插件 1npm update 2.关于npmnpm小知识 npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）。使用npm安装插件：npm install &lt;name&gt; [g] [--save -dev] &lt;name&gt;:node 插件名称 -g:全局安装，会在node安装的根目录下载对应的包，在计算机的任何文件都可以使用该插件，默认的node安装目录是：C:\Users\Administrator\AppData\Roaming\npm;如果不带该属性，将会安装在当前目录，下载安装包的位置是当前目录的node_modules文件夹 --save：将配置信息保存在node项目配置文件package.json中 -dev：保存至package.json的devDependencies节点，如果没有该属性，该插件将会被保存至dependencies节点，devDependencies和dependencies有什么区别呢？其实从名字就应该可以看出来两者的区别，devDependencies中dev是development（开发）的缩写，dependencies是依赖的意思。所以 dependencies 是程序正常运行所需要安装的依赖，而devDependencies是开发所需要的依赖，比如一些单元测试的包~ 为什么要保存至package.json？因为我们使用node的时候需要很多的包，所以我们将我们的配置信息，也就是我们需要包的名称等其他信息保存至一个文件中，如果说其他开发者就可以直接使用一个命令就可以安装和我们相同的配置，这个命令就是npm install，就可以下载package.json 下所有需要的包。npm install --production则只下载dependencies下的包 使用npm卸载插件：npm unstall &lt;name&gt; [-g] [--save-dev] 在npm中要卸载插件不是将文件夹删除就可以了，因为你的配置信息还在package中，所以要使用npm unstall &lt;name&gt; [-g] [--save-dev] 命令 删除全部插件:rimraf node_modules（首先你需要先安装rimraf 插件） 更新npm插件：npm update &lt;name&gt; [g] [--save-dev] 使用cnpm 什么是cnpm呢，大家都知道，由于不可描述原因，我们访问国外的资源有时候的速度，大家懂的，所以淘宝除了一个npm镜像，服务器就在中国。c可以理解为China（应该可以这样理解吧）,cnpm使用方法和npm完全相同，只需将npm全部换成cnpm就可以。本文都是使用的npm，如果想要尝试cnpmde的麻烦自行替换~ 这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 cnpm 官网地址：npm.taobao.org；安装命令为npm install cnpm -g --registry=https://registry.npm.taobao.org 注意：安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误； 3.参考 官网 Hexo NexT 博客搭建 git使用ssh密钥 github设置添加SSH 使用hexo+github搭建免费个人博客详细教程 我是如何利用Github Pages搭建起我的博客，细数一路的坑 Hexo搭建博客教程 主题配置 Hexo 使用入门 Hexo的Next主题详细配置 动动手指，NexT主题与Hexo更搭哦（基础篇） hexo之next主题优化整理 SEO优化 让Google搜索到搭建在Github Pages上的博客 动动手指，不限于NexT主题的Hexo优化（SEO篇） Markdow语法 Markdown——入门指南 Markdown语法汇总 （完）]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用hexo，如果换了电脑怎么保留配置和更新博客]]></title>
    <url>%2F870ed150.html</url>
    <content type="text"><![CDATA[思路还是使用git的分支来管理，@直上云霄的回答清晰明了，但是需要使用两个文件夹，而且两个文件夹会出现以后新建博客同步问题，除非使用新文件夹进行编辑、发布博客。而@CrazyMilk的回答步骤清楚，但是不够清晰。所以合并@直上云霄 和 @CrazyMilk 的回答，使用目前已有的hexo博客目录来管理。 一.备份1.在github上新建一个hexo分支 2.在仓库的设置里面，设置默认分支为hexo 3.在其他目录，打开git bash，克隆hexo仓库到本地，拿到隐藏的.git文件夹 1git clone -b hexo &lt;github的https或者ssh的URL&gt; 4.复制这个隐藏的.git文件夹到你使用hexo博客的目录下，同时删除博客主题，比如next下面的.git文件夹(因为git不能嵌套上传)，然后你之前克隆hexo仓库的文件夹就可以删除了。 5.上传 123git add .git commit –m &quot;你的备注&quot;git push origin hexo 二、编辑博客在新建博客之后 1.先备份到hexo分支 123git add .git commit –m &quot;你的备注&quot;git push origin hexo 2.再进行部署 1hexo cl &amp;&amp; hexo g &amp;&amp; hexo d 三、更换电脑1.安装git 2.设置git全局邮箱和用户名 3.配置SSH Key 4.克隆github分支hexo到本地文件夹 5.安装nodejs 6.安装hexo(不需要初始化) 参见@直上云霄的回答 来源：使用hexo，如果换了电脑怎么更新博客？ 异地同步博客内容 现在电脑已经很普及了，因为一般来说我们都是公司一台电脑，家里一台电脑，那么如何将两台电脑上博客的内容同步内，即两台电脑上都可以编辑更新博客？要解决这个问题，首先我们要清楚我们博客文件的组成： node_modules public scaffolds source themes _config_yml db.json package.json .deploy_git 以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？ 我们可以看下github上的tengzhangchao.github.io项目，发现里面只有Public目录下的内容。也就是说，我们博客上呈现的内容，其实就是public下的文件内容。那么这个Pulic目录是怎么生成的呢？ 一开始hexo init的时候是没有public目录的，而当我们运行hexo g命令时，public目录被生成了，换句话说hexo g命令就是用来生成博客文件的（会根据_config.yml，source目录文件以及themes目录下文件生成）。同样当我们运行hexo clean命令时，public目录被删除了。 好了，既然我们知道了决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成Public目录的文件即可。 以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git 同步的方式有很多种，可以每次更新后都备份到一个地址。我采用github去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。 同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？ 前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧： 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙） 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙) 我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。 git clone 我们备份的项目，生成一个文件夹，如：MyBlogData 将MyBlog里面的node_modules、scaffolds文件夹复制到MyBlogData里面。 做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo ghexo d试试，如果会报错，则往下看。 这是因为.deploy_git没有同步，在MyBlogData目录内运行:npm install hexo-deployer-git –save后再次推送即可 总结流程：当我们每次更新MyBlog内容后，先利用hexo将public推送到github，然后再将其余必须同步的文件利用git推送到github。 创建Hexo分支创建两个分支：master 与 Hexo,并将Hexo设置为默认分支（这个Hexo分支就是存放我们源文件的分支，我们只需要更新Hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的） 删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件因为有些主题是从git上clone过来的，所以我们要先删除.git缓存文件，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git文件夹被删除后整个文件对应的git仓库状态也会被清空).gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容： 123/.deploy_git/public /_config.yml复制代码 .deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去 初始化仓库然后我们再初始化仓库，重新对我们的代码进行版本控制 12git initgit remote add origin &lt;server&gt;复制代码 &lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端 将博客源文件上传至Hexo分支依次执行 123git add .git commit -m &quot;...&quot;git push origin hexo复制代码 提交网站相关的文件； 对B电脑进行的操作假设B电脑现在没有我们的源文件 1234git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。git fetch --allgit reset --hard origin/master复制代码 日常改动平时我们对源文件有修改的时候记得先pull一遍代码，再将代码push到Hexo分支，就和日常的使用git一样~ 依次执行git add .、git commit -m “…”、git push origin Hexo指令将改动推送到GitHub（此时当前分支应为Hexo）； 然后才执行hexo g -d发布网站到master分支上。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之五：分支限界法]]></title>
    <url>%2F1f3dcc68.html</url>
    <content type="text"><![CDATA[一、基本描述​ 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 （1）分支搜索算法​ 所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。 ​ 选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。 1）FIFO搜索 2）LIFO搜索 3）优先队列式搜索 （2）分支限界搜索算法二、分支限界法的一般过程​ 由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。 ​ 分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。 ​ 分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。 三、回溯法和分支限界法的一些区别​ 有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？ 回溯法和分支限界法的一些区别： 方法对解空间树的搜索方式 存储结点的常用数据结构 结点存储特性常用应用 回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解 分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解 来源：五大常用算法之五：分支限界法]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之四：回溯法]]></title>
    <url>%2Fb72db516.html</url>
    <content type="text"><![CDATA[1、概念​ 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 ​ 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 2、基本思想 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 ​ 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 ​ 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 3、用回溯法解题的一般步骤：​ （1）针对所给问题，确定问题的解空间： ​ 首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。 ​ （2）确定结点的扩展搜索规则 ​ （3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 4、算法框架​ （1）问题框架 ​ 设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。 ​ （2）非递归回溯框架 123456789101112131415161718192021222324252627 1: int a[n],i; 2: 初始化数组a[]; 3: i = 1; 4: while (i&gt;0(有路可走) and (未达到目标)) // 还未回溯到头 5: &#123; 6: if(i &gt; n) // 搜索到叶结点 7: &#123; 8: 搜索到一个解，输出； 9: &#125;10: else // 处理第i个元素11: &#123; 12: a[i]第一个可能的值；13: while(a[i]在不满足约束条件且在搜索空间内)14: &#123;15: a[i]下一个可能的值；16: &#125;17: if(a[i]在搜索空间内)18: &#123;19: 标识占用的资源；20: i = i+1; // 扩展下一个结点21: &#125;22: else 23: &#123;24: 清理所占的状态空间； // 回溯25: i = i –1; 26: &#125;27: &#125; ​ （3）递归的算法框架 ​ 回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下： 12345678910111213141516171819 1: int a[n]; 2: try(int i) 3: &#123; 4: if(i&gt;n) 5: 输出结果; 6: else 7: &#123; 8: for(j = 下界; j &lt;= 上界; j=j+1) // 枚举i所有可能的路径 9: &#123;10: if(fun(j)) // 满足限界函数和约束条件11: &#123;12: a[i] = j;13: ... // 其他操作14: try(i+1);15: 回溯前的清理工作（如a[i]置空值等）;16: &#125;17: &#125;18: &#125;19: &#125; 来源：五大常用算法之四：回溯法]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之三：贪心算法]]></title>
    <url>%2F400f83c6.html</url>
    <content type="text"><![CDATA[一、基本概念： ​ 所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。 ​ 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。 ​ 所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 二、贪心算法的基本思路： ​ 1.建立数学模型来描述问题。 ​ 2.把求解的问题分成若干个子问题。 ​ 3.对每一子问题求解，得到子问题的局部最优解。 ​ 4.把子问题的解局部最优解合成原来解问题的一个解。 三、贪心算法适用的问题 ​ 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 ​ 实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。 四、贪心算法的实现框架 ​ 从问题的某一初始解出发； ​ while （能朝给定总目标前进一步） ​ { ​ 利用可行的决策，求出可行解的一个解元素； ​ } ​ 由所有解元素组合成问题的一个可行解； 五、贪心策略的选择 ​ 因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。 六、例题分析 ​ 下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。 ​ [背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。 ​ 要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 ​ 物品 A B C D E F G ​ 重量 35 30 60 50 40 10 25 ​ 价值 10 40 30 50 35 40 30 ​ 分析： ​ 目标函数： ∑pi最大 ​ 约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) ​ （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ ​ （2）每次挑选所占重量最小的物品装入是否能得到最优解？ ​ （3）每次选取单位重量价值最大的物品，成为解本题的策略。 ​ 值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。 ​ 贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。 ​ 可惜的是，它需要证明后才能真正运用到题目的算法中。 ​ 一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。 ​ 对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下： ​ （1）贪心策略：选取价值最大者。反例： ​ W=30 ​ 物品：A B C ​ 重量：28 12 12 ​ 价值：30 20 20 ​ 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ​ （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 ​ （3）贪心策略：选取单位重量价值最大的物品。反例： ​ W=30 ​ 物品：A B C ​ 重量：28 20 10 ​ 价值：28 20 10 ​ 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 来源：五大常用算法之三：贪心算法 comments： 题目的要求是：有7个物品，物品可以分割成任意大小。那么最后一个根据单位价值最大进行选取的贪心策略应该是对了，为什么是错的呢？ 比如我选择了A，然后再从B切下重量为2的物品出来，不就得到了最大价值为30的最优选择了吗？ 是不是题目的要求“物品可以分割成任意大小”给错了。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之二：动态规划算法]]></title>
    <url>%2F5dc644dc.html</url>
    <content type="text"><![CDATA[一、基本概念 ​ 动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 二、基本思想与策略 ​ 基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 ​ 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 ​ 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 三、适用的情况 能采用动态规划求解的问题的一般要具有3个性质： ​ (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 ​ (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 四、求解的基本步骤 ​ 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。 ​ 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 ​ 图1 动态规划决策过程示意图 ​ (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 ​ (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 ​ (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 ​ (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 ​ 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 实际应用中可以按以下几个简化的步骤进行设计： ​ （1）分析最优解的性质，并刻画其结构特征。 ​ （2）递归的定义最优解。 ​ （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 ​ （4）根据计算最优值时得到的信息，构造问题的最优解 五、算法实现的说明 ​ 动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 ​ 使用动态规划求解问题，最重要的就是确定动态规划三要素： ​ （1）问题的阶段 ​ （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系 ​ 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 ​ 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 ​ f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} 六、动态规划算法基本框架 12345678910111213141516171819 1 for(j=1; j&lt;=m; j=j+1) // 第一个阶段 2 xn[j] = 初始值; 3 4 for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段 5 for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式 6 xi[j]=j=max（或min）&#123;g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])&#125;; 8 9 t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案10 11 print(x1[j1]);12 13 for(i=2; i&lt;=n-1; i=i+1）15 &#123; 17 t = t-xi-1[ji];18 19 for(j=1; j&gt;=f(i); j=j+1)21 if(t=xi[ji])23 break;25 &#125; 来源：五大常用算法之二：动态规划算法]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五大常用算法之一：分治算法]]></title>
    <url>%2F7474c898.html</url>
    <content type="text"><![CDATA[一、基本概念 在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… ​ 任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。 二、基本思想及策略 分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 三、分治法适用的情况​ 分治法所能解决的问题一般具有以下几个特征： ​ 1) 该问题的规模缩小到一定的程度就可以容易地解决； ​ 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质； ​ 3) 利用该问题分解出的子问题的解可以合并为该问题的解； ​ 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。 四、分治法的基本步骤分治法在每一层递归上都有三个步骤： ​ step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； ​ step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 ​ step3 合并：将各个子问题的解合并为原问题的解。 它的一般的算法设计模式如下： ​ Divide-and-Conquer(P) if |P|≤n0 then return(ADHOC(P)) 将P分解为较小的子问题 P1 ,P2 ,…,Pk for i←1 to k do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi T ← MERGE(y1,y2,…,yk) △ 合并子问题 return(T) ​ 其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。 五、分治法的复杂性分析​ 一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有： T（n）= k T(n/m)+f(n) ​ 通过迭代法求得方程的解： 递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当 mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 六、可使用分治法求解的一些经典问题 （1）二分搜索 （2）大整数乘法 （3）Strassen矩阵乘法 （4）棋盘覆盖 （5）合并排序 （6）快速排序 （7）线性时间选择 （8）最接近点对问题 （9）循环赛日程表 （10）汉诺塔 七、依据分治法设计程序时的思维过程​ 实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。 1、一定是先找到最小问题规模时的求解方法 2、然后考虑随着问题规模增大时的求解方法 3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。 来源：五大常用算法之一：分治算法]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十五）：线程死锁]]></title>
    <url>%2F11129fd3.html</url>
    <content type="text"><![CDATA[摘要：如题。 什么是死锁？通俗的说，死锁就是两个或者多个线程，相互占用对方需要的资源，而都不进行释放，导致彼此之间都相互等待对方释放资源，产生了无限制等待的现象。死锁一旦发生，如果没有外力介入，这种等待将永远存在，从而对程序产生严重影响。用来描述死锁的问题最有名的场景就是“哲学家就餐问题”。哲学家就餐问题可以这样表述：假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事之一：吃饭或者思考。吃东西的时候他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为只用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐。哲学家从来不交谈，这就跟危险，可能产生死锁，每个哲学家都拿着左手的餐叉永远等右边的餐叉（或者相反）…. 死锁产生的必要条件 互斥条件：进程对锁分配的资源进行排他性使用 请求和保持条件：线程已经保持了一个资源，但是又提出了其他请求，而该资源已被其他线程占用 不剥夺条件：在使用时不能被剥夺，只能自己用完释放 环路等待条件：资源调用是一个环形的链 死锁示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Slf4jpublic class DeadLock implements Runnable &#123; public int flag = 1; //静态对象是类的所有对象共享的 private static Object o1 = new Object(), o2 = new Object(); @Override public void run() &#123; log.info(&quot;flag:&#123;&#125;&quot;, flag); if (flag == 1) &#123; synchronized (o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; log.info(&quot;1&quot;); &#125; &#125; &#125; if (flag == 0) &#123; synchronized (o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; log.info(&quot;0&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DeadLock td1 = new DeadLock(); DeadLock td2 = new DeadLock(); td1.flag = 1; td2.flag = 0; //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。 //td2的run()可能在td1的run()之前运行 new Thread(td1).start(); new Thread(td2).start(); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 上述代码出现死锁原因： 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒 td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定； td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定； td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 确认死锁在真实的环境中，我们发现程序无法执行，并且CPU占用为0，这样就有理由怀疑产生了死锁，但是光怀疑是不行的，我们需要一个实际的验证方法。接下来我们使用jdk提供的工具来检测是否真正发生了死锁。运行上述的代码，并在windows系统中使用cmd进入控制台，输入以下命令： 1jps1 可见控制台输出：我们上边运行的类的类名以及对应的进程ID接下来使用命令获取进程对应线程的堆栈信息： 1jstack 9284 1 分析堆栈信息（提取有用的部分）两个线程都进行了加锁操作（如上图）系统发现了一个Java-level的线程死锁。ok，确认无疑是发生了死锁现象。 避免死锁 注意加锁顺序（这个很好理解，就像上边的例子） 加锁时限（超过时限放弃加锁）实现方式–使用重入锁。关于重入锁可以见我之前的博客：并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock 死锁检测（较难，就像分析上边的线程情况） 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80233899]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十四）：线程池 Executor]]></title>
    <url>%2Ff49ebf6e.html</url>
    <content type="text"><![CDATA[摘要：本文介绍线程池的好处、类图和核心类——ThreadPoolExecutor，以及使用Executor创建线程池。 new Thread的弊端 线程池的好处 线程池类图 线程池核心类-ThreadPoolExecutor 使用Executor创建线程池 new Thread的弊端 每次new Thread 新建对象，性能差 线程缺乏统一管理，可能无限制的新建线程，相互竞争，可能占用过多的系统资源导致死机或者OOM（out of memory 内存溢出），这种问题的原因不是因为单纯的new一个Thread，而是可能因为程序的bug或者设计上的缺陷导致不断new Thread造成的。 缺少更多功能，如更多执行、定期执行、线程中断。 线程池的好处 重用存在的线程，减少对象创建、消亡的开销，性能好 可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。 提供定时执行、定期执行、单线程、并发数控制等功能。 线程池类图 在线程池的类图中，我们最常使用的是最下边的Executors,用它来创建线程池使用线程。那么在上边的类图中，包含了一个Executor框架，它是一个根据一组执行策略的调用调度执行和控制异步任务的框架，目的是提供一种将任务提交与任务如何运行分离开的机制。它包含了三个executor接口： Executor:运行新任务的简单接口 ExecutorService：扩展了Executor，添加了用来管理执行器生命周期和任务生命周期的方法 ScheduleExcutorService：扩展了ExecutorService，支持Future和定期执行任务 线程池核心类-ThreadPoolExecutor参数说明：ThreadPoolExecutor一共有七个参数，这七个参数配合起来，构成了线程池强大的功能。 corePoolSize：核心线程数量 maximumPoolSize：线程最大线程数 workQueue：阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响 当我们提交一个新的任务到线程池，线程池会根据当前池中正在运行的线程数量来决定该任务的处理方式。处理方式有三种：1、直接切换（SynchronusQueue）2、无界队列（LinkedBlockingQueue）能够创建的最大线程数为corePoolSize,这时maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是运行状态的时候，新的任务提交就会放入等待队列中。3、有界队列（ArrayBlockingQueue）最大maximumPoolSize，能够降低资源消耗，但是这种方式使得线程池对线程调度变的更困难。因为线程池与队列容量都是有限的。所以想让线程池的吞吐率和处理任务达到一个合理的范围，又想使我们的线程调度相对简单，并且还尽可能降低资源的消耗，我们就需要合理的限制这两个数量分配技巧： [如果想降低资源的消耗包括降低cpu使用率、操作系统资源的消耗、上下文切换的开销等等，可以设置一个较大的队列容量和较小的线程池容量，这样会降低线程池的吞吐量。如果我们提交的任务经常发生阻塞，我们可以调整maximumPoolSize。如果我们的队列容量较小，我们需要把线程池大小设置的大一些，这样cpu的使用率相对来说会高一些。但是如果线程池的容量设置的过大，提高任务的数量过多的时候，并发量会增加，那么线程之间的调度就是一个需要考虑的问题。这样反而可能会降低处理任务的吞吐量。] keepAliveTime：线程没有任务执行时最多保持多久时间终止（当线程中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交核心线程外的线程不会立即销毁，而是等待，直到超过keepAliveTime） unit：keepAliveTime的时间单位 threadFactory：线程工厂，用来创建线程，有一个默认的工场来创建线程，这样新创建出来的线程有相同的优先级，是非守护线程、设置好了名称） rejectHandler：当拒绝处理任务时(阻塞队列满)的策略（AbortPolicy默认策略直接抛出异常、CallerRunsPolicy用调用者所在的线程执行任务、DiscardOldestPolicy丢弃队列中最靠前的任务并执行当前任务、DiscardPolicy直接丢弃当前任务） corePoolSize、maximumPoolSize、workQueue 三者关系：如果运行的线程数小于corePoolSize的时候，直接创建新线程来处理任务。即使线程池中的其他线程是空闲的。如果运行中的线程数大于corePoolSize且小于maximumPoolSize时，那么只有当workQueue满的时候才创建新的线程去处理任务。如果corePoolSize与maximumPoolSize是相同的，那么创建的线程池大小是固定的。这时有新任务提交，当workQueue未满时，就把请求放入workQueue中。等待空线程从workQueue取出任务。如果workQueue此时也满了，那么就使用另外的拒绝策略参数去执行拒绝策略。 初始化方法：由七个参数组合成四个初始化方法 其他方法： 序号 方法名 描述 1 execute() 提交任务，交给线程池执行 2 submit() 提交任务，能够返回执行结果 execute+Future 3 shutdown() 关闭线程池，等待任务都执行完 4 shutdownNow() 关闭线程池，不等待任务执行完 5 getTaskCount() 线程池已执行和未执行的任务总数 6 getCompleteTaskCount() 已完成的任务数量 7 getPoolSize() 线程池当前的线程数量 8 getActiveCount() 当前线程池中正在执行任务的线程数量 线程池生命周期： running：能接受新提交的任务，也能处理阻塞队列中的任务 shutdown：不能处理新的任务，但是能继续处理阻塞队列中任务 stop：不能接收新的任务，也不处理队列中的任务 tidying：如果所有的任务都已经终止了，这时有效线程数为0 terminated：最终状态 使用Executor创建线程池使用Executor可以创建四种线程池：分别对应上边提到的四种线程池初始化方法 1、Executors.newCachedThreadPool创建一个可缓存的线程池，如果线程池的长度超过了处理的需要，可以灵活回收空闲线程。如果没有可回收的就新建线程。 1234567891011121314151617181920//源码：public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;123456//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 值得注意的一点是，newCachedThreadPool的返回值是ExecutorService类型，该类型只包含基础的线程池方法，但却不包含线程监控相关方法，因此在使用返回值为ExecutorService的线程池类型创建新线程时要考虑到具体情况。 2、newFixedThreadPool定长线程池，可以线程现成的最大并发数，超出在队列等待 1234567891011121314151617181920//源码：public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;123456//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 3、newSingleThreadExecutor单线程化的线程池，用唯一的一个共用线程执行任务，保证所有任务按指定顺序执行（FIFO、优先级…） 123456789101112131415161718192021//源码public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;1234567//使用方法：public static void main(String[] args) &#123; ExecutorService executorService = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; executorService.execute(new Runnable() &#123; @Override public void run() &#123; log.info(&quot;task:&#123;&#125;&quot;, index); &#125; &#125;); &#125; executorService.shutdown();&#125;1234567891011121314 4、newScheduledThreadPool定长线程池，支持定时和周期任务执行 1234567891011121314151617181920//源码：public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,//此处super指的是ThreadPoolExecutor new DelayedWorkQueue());&#125;12345678//基础使用方法：public static void main(String[] args) &#123; ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1); executorService.schedule(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125; &#125;, 3, TimeUnit.SECONDS);//延迟3秒执行 executorService.shutdown();&#125;123456789101112 ScheduledExecutorService提供了三种方法可以使用：scheduleAtFixedRate：以指定的速率执行任务scheduleWithFixedDelay：以指定的延迟执行任务举例： 123456executorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; log.warn(&quot;schedule run&quot;); &#125;&#125;, 1, 3, TimeUnit.SECONDS);//延迟一秒后每隔3秒执行123456 小扩展：延迟执行任务的操作，java中还有Timer类同样可以实现 1234567Timer timer = new Timer();timer.schedule(new TimerTask() &#123; @Override public void run() &#123; log.warn(&quot;timer run&quot;); &#125;&#125;, new Date(), 5 * 1000); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80202114]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十三）：并发容器J.U.C -- 组件FutureTask、ForkJoin、BlockingQueue]]></title>
    <url>%2Fef3705fd.html</url>
    <content type="text"><![CDATA[摘要：本文介绍组件FutureTask、ForkJoin、BlockingQueue阻塞队列。 FutureTask Runnable与Callable对比 Future接口 FutureTask ForkJoin 局限性： 框架核心： 使用方式：（模拟加和运算） BlockingQueue阻塞队列 阻塞情况： 四套方法： 实现类： FutureTaskFutureTask是J.U.C中的类，是一个可删除的异步计算类。这个类提供了Future接口的的基本实现，使用相关方法启动和取消计算，查询计算是否完成，并检索计算结果。只有在计算完成时才能使用get方法检索结果;如果计算尚未完成，get方法将会阻塞。一旦计算完成，计算就不能重新启动或取消(除非使用runAndReset方法调用计算)。 Runnable与Callable对比通常实现一个线程我们会使用继承Thread的方式或者实现Runnable接口，这两种方式有一个共同的缺陷就是在执行完任务之后无法获取执行结果。从Java1.5之后就提供了Callable与Future，这两个接口就可以实现获取任务执行结果。 Runnable接口：代码非常简单，只有一个方法run 123public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125;123 Callable泛型接口：有泛型参数，提供了一个call方法，执行后可返回传入的泛型参数类型的结果。 123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125;123 Future接口Future接口提供了一系列方法用于控制线程执行计算，如下： 12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning);//取消任务 boolean isCancelled();//是否被取消 boolean isDone();//计算是否完成 V get() throws InterruptedException, ExecutionException;//获取计算结果，在执行过程中任务被阻塞 V get(long timeout, TimeUnit unit)//timeout等待时间、unit时间单位 throws InterruptedException, ExecutionException, TimeoutException;&#125;12345678 使用方法： 1234567891011121314151617181920public class FutureExample &#123; static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable());//线程池提交任务 log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = future.get();//获取不到一直阻塞 log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125;1234567891011121314151617181920 运行结果：阻塞效果 FutureTaskFuture实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。 1234567public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; ...&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125;1234567 FutureTask支持两种参数类型，Callable和Runnable，在使用Runnable 时，还可以多指定一个返回结果类型。 1234567891011public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;1234567891011 使用方法： 12345678910111213141516171819public class FutureTaskExample &#123; public static void main(String[] args) throws Exception &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info(&quot;do something in callable&quot;); Thread.sleep(5000); return &quot;Done&quot;; &#125; &#125;); new Thread(futureTask).start(); log.info(&quot;do something in main&quot;); Thread.sleep(1000); String result = futureTask.get(); log.info(&quot;result：&#123;&#125;&quot;, result); &#125;&#125;12345678910111213141516171819 运行结果： ForkJoinForkJoin是Java7提供的一个并行执行任务的框架，是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架。主要采用的是工作窃取算法，工作窃取算法是指某个线程从其他队列里窃取任务来执行。在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用双端队列来实现工作窃取算法。被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。 局限性：1、任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了。2、我们所拆分的任务不应该去执行IO操作，如读和写数据文件。3、任务不能抛出检查异常。必须通过必要的代码来处理他们。 框架核心：核心有两个类：ForkJoinPool | ForkJoinTaskForkJoinPool：负责来做实现，包括工作窃取算法、管理工作线程和提供关于任务的状态以及他们的执行信息。ForkJoinTask:提供在任务中执行fork和join的机制。 使用方式：（模拟加和运算）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Slf4jpublic class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123; public static final int threshold = 2;//设定不大于两个数相加就直接for循环，不适用框架 private int start; private int end; public ForkJoinTaskExample(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; //如果任务足够小就计算任务 boolean canCompute = (end - start) &lt;= threshold; if (canCompute) &#123; for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 如果任务大于阈值，就分裂成两个子任务计算（分裂算法，可依情况调优） int middle = (start + end) / 2; ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle); ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待任务执行结束合并其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkjoinPool = new ForkJoinPool(); //生成一个计算任务，计算1+2+3+4...100 ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100); //执行一个任务 Future&lt;Integer&gt; result = forkjoinPool.submit(task); try &#123; log.info(&quot;result:&#123;&#125;&quot;, result.get()); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 BlockingQueue阻塞队列主要应用场景：生产者消费者模型，是线程安全的 阻塞情况：1、当队列满了进行入队操作2、当队列空了的时候进行出队列操作 四套方法：BlockingQueue提供了四套方法，分别来进行插入、移除、检查。每套方法在不能立刻执行时都有不同的反应。 Throws Exceptions ：如果不能立即执行就抛出异常。 Special Value：如果不能立即执行就返回一个特殊的值。 Blocks：如果不能立即执行就阻塞 Times Out：如果不能立即执行就阻塞一段时间，如果过了设定时间还没有被执行，则返回一个值 实现类： ArrayBlockingQueue：它是一个有界的阻塞队列，内部实现是数组，初始化时指定容量大小，一旦指定大小就不能再变。采用FIFO方式存储元素。 DelayQueue：阻塞内部元素，内部元素必须实现Delayed接口，Delayed接口又继承了Comparable接口，原因在于DelayQueue内部元素需要排序，一般情况按过期时间优先级排序。 123public interface Delayed extends Comparable&lt;Delayed&gt; &#123; long getDelay(TimeUnit unit);&#125;123 DalayQueue内部采用PriorityQueue与ReentrantLock实现。 1234567public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; private final transient ReentrantLock lock = new ReentrantLock(); private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;(); ...&#125;1234567 LinkedBlockingQueue：大小配置可选，如果初始化时指定了大小，那么它就是有边界的。不指定就无边界（最大整型值）。内部实现是链表，采用FIFO形式保存数据。 123public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);//不指定大小，无边界采用默认值，最大整型值&#125;123 PriorityBlockingQueue:带优先级的阻塞队列。无边界队列，允许插入null。插入的对象必须实现Comparator接口，队列优先级的排序规则就是按照我们对Comparable接口的实现来指定的。我们可以从PriorityBlockingQueue中获取一个迭代器，但这个迭代器并不保证能按照优先级的顺序进行迭代。 12345678910111213141516171819202122232425public boolean add(E e) &#123;//添加方法 return offer(e);&#125;public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator;//必须实现Comparator接口 if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true;&#125;12345678910111213141516171819202122232425 SynchronusQueue：只能插入一个元素，同步队列，无界非缓存队列，不存储元素。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80168980]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十二）：并发容器J.U.C -- AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock]]></title>
    <url>%2F61c20be.html</url>
    <content type="text"><![CDATA[摘要：本文介绍重入锁(ReentrantLock)、读写锁（ReentrantReadWriteLock）、票据锁（StempedLock）以及如何选择锁。 ReentrantLock ReentrantLock与synchronized的区别 ReentrantLock独有的功能 要放弃synchronized？ 如何使用ReentrantLock？ 内置函数（部分） Condition的使用 读写锁：ReentrantReadWriteLock读写锁 票据锁：StempedLock 如何选择锁？ ReentrantLockjava中有两类锁，一类是Synchronized，而另一类就是J.U.C中提供的锁。ReentrantLock与Synchronized都是可重入锁，本质上都是lock与unlock的操作。接下来我们介绍三种J.U.C中的锁，其中 ReentrantLock使用synchronized与之比对介绍。 ReentrantLock与synchronized的区别 可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁 锁的实现：synchronized是基于JVM实现的（用户很难见到，无法了解其实现），ReentrantLock是JDK实现的。 性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自选锁）后，二者的性能差别不大，官方推荐synchronized（写法更容易、在优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞） 功能区别：（1）便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。（2）锁的细粒度和灵活度，ReentrantLock优于synchronized ReentrantLock独有的功能 可以指定是公平锁还是非公平锁，sync只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁） 提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。 提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现，这种机制 ReentrantLock是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。 要放弃synchronized？从上边的介绍，看上去ReentrantLock不仅拥有synchronized的所有功能，而且有一些功能synchronized无法实现的特性。性能方面，ReentrantLock也不比synchronized差，那么到底我们要不要放弃使用synchronized呢？答案是不要这样做。 J.U.C包中的锁定类是用于高级情况和高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需要，或这有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized。相比较这些高级的锁定类，synchronized还是有一些优势的，比如synchronized不可能忘记释放锁。还有当JVM使用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。 如何使用ReentrantLock？1234567891011//创建锁：使用Lock对象声明，使用ReentrantLock接口创建private final static Lock lock = new ReentrantLock();//使用锁：在需要被加锁的方法中使用private static void add() &#123; lock.lock(); try &#123; count++; &#125; finally &#123; lock.unlock(); &#125;&#125;1234567891011 分析一下源码： 123456789//初始化方面：//在new ReentrantLock的时候默认给了一个不公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125;//也可以加参数来初始化指定使用公平锁还是不公平锁public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125;123456789 内置函数（部分）基础特性： tryLock()：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。 tryLock(long timeout, TimeUnit unit)：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。 lockInterruptbily：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。 isLocked：查询此锁定是否由任意线程保持 isHeldByCurrentThread：查询当前线程是否保持锁定状态。 isFair：判断是不是公平锁… Condition相关特性： hasQueuedThread(Thread)：查询指定线程是否在等待获取此锁定 hasQueuedThreads()：查询是否有线程在等待获取此锁定 getHoldCount()：查询当前线程保持锁定的个数，也就是调用Lock方法的个数… Condition的使用Condition可以非常灵活的操作线程的唤醒，下面是一个线程等待与唤醒的例子，其中用1234序号标出了日志输出顺序 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; ReentrantLock reentrantLock = new ReentrantLock(); Condition condition = reentrantLock.newCondition();//创建condition //线程1 new Thread(() -&gt; &#123; try &#123; reentrantLock.lock(); log.info(&quot;wait signal&quot;); // 1 condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(&quot;get signal&quot;); // 4 reentrantLock.unlock(); &#125;).start(); //线程2 new Thread(() -&gt; &#123; reentrantLock.lock(); log.info(&quot;get lock&quot;); // 2 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; condition.signalAll();//发送信号 log.info(&quot;send signal&quot;); // 3 reentrantLock.unlock(); &#125;).start();&#125;1234567891011121314151617181920212223242526272829 （这里对等待队列不熟悉的，请回顾我的上一篇文章中讲解的AQS等待队列：高并发探索（十一）：并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier）输出过程讲解： 1、线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出1号log2、接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中3、线程2因为线程1释放了锁，拿到了锁，输出2号log4、线程2执行condition.signalAll()发送信号，输出3号log5、condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列,这时线程1并没有被唤醒。6、线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程17、线程1继续执行，输出4号log，并进行unlock操作。 读写锁：ReentrantReadWriteLock读写锁在没有任何读写锁的时候才可以取得写入锁(悲观读取，容易写线程饥饿)，也就是说如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会造成等待获取写锁的线程饥饿。平时使用的场景并不多。 12345678910111213141516171819202122232425262728public class LockExample3 &#123; private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;(); private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock readLock = lock.readLock();//读锁 private final Lock writeLock = lock.writeLock();//写锁 //加读锁 public Data get(String key) &#123; readLock.lock(); try &#123; return map.get(key); &#125; finally &#123; readLock.unlock(); &#125; &#125; //加写锁 public Data put(String key, Data value) &#123; writeLock.lock(); try &#123; return map.put(key, value); &#125; finally &#123; writeLock.unlock(); &#125; &#125; class Data &#123;&#125;&#125;12345678910111213141516171819202122232425262728 票据锁：StempedLock它控制锁有三种模式（写、读、乐观读）。一个StempedLock的状态是由版本和模式两个部分组成。锁获取方法返回一个数字作为票据（stamp），他用相应的锁状态表示并控制相关的访问。数字0表示没有写锁被锁写访问，在读锁上分为悲观锁和乐观锁。 乐观读：如果读的操作很多写的很少，我们可以乐观的认为读的操作与写的操作同时发生的情况很少，因此不悲观的使用完全的读取锁定。程序可以查看读取资料之后是否遭到写入资料的变更，再采取之后的措施。 如何使用？ 1234567891011//定义private final static StampedLock lock = new StampedLock();//需要上锁的方法private static void add() &#123; long stamp = lock.writeLock(); try &#123; count++; &#125; finally &#123; lock.unlock(stamp); &#125;&#125;1234567891011 分析一下源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Point &#123; private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) &#123; long stamp = sl.writeLock(); try &#123; x += deltaX; y += deltaY; &#125; finally &#123; sl.unlockWrite(stamp); &#125; &#125; //下面看看乐观读锁案例 double distanceFromOrigin() &#123; // A read-only method long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁 double currentX = x, currentY = y; //将两个字段读入本地局部变量 if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？ stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁 try &#123; currentX = x; // 将两个字段读入本地局部变量 currentY = y; // 将两个字段读入本地局部变量 &#125; finally &#123; sl.unlockRead(stamp); &#125; &#125; return Math.sqrt(currentX * currentX + currentY * currentY); &#125; //下面是悲观读锁案例 void moveIfAtOrigin(double newX, double newY) &#123; // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try &#123; while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合 long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁 if (ws != 0L) &#123; //这是确认转为写锁是否成功 stamp = ws; //如果成功 替换票据 x = newX; //进行状态改变 y = newY; //进行状态改变 break; &#125; else &#123; //如果不能成功转换为写锁 sl.unlockRead(stamp); //我们显式释放读锁 stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试 &#125; &#125; &#125; finally &#123; sl.unlock(stamp); //释放读锁或写锁 &#125; &#125; &#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 如何选择锁？1、当只有少量竞争者，使用synchronized2、竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock3、synchronized不会造成死锁，jvm会自动释放死锁。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80058631]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十一）：并发容器J.U.C -- AQS组件CountDownLatch、Semaphore、CyclicBarrier]]></title>
    <url>%2F68b85893.html</url>
    <content type="text"><![CDATA[摘要：本文介绍AQS。AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。 AQS简介 AQS设计思想 AQS的大致实现思路 AQS组件：CountDownLatch AQS组件：Semaphore AQS组件：CyclicBarrier AQS简介AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个FIFO(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个双向列表。Sync queue：同步队列，是一个双向列表。包括head节点和tail节点。head节点主要用作后续的调度。Condition queue：非必须，单向列表。当程序中存在cindition的时候才会存在此列表。 AQS设计思想 使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。 利用int类型标识状态。在AQS类中有一个叫做state的成员变量 1234/** * The synchronization state. */private volatile int state;1234 基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。 继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。 可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。 AQS的大致实现思路AQS内部维护了一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。 AQS组件：CountDownLatch 通过一个计数来保证线程是否需要被阻塞。实现一个或多个线程等待其他线程执行的场景。 我们定义一个CountDownLatch，通过给定的计数器为其初始化，该计数器是原子性操作，保证同时只有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态。只有其他线程调用countDown方法（每次使计数器-1），使计数器归零才能继续执行。 123456789101112131415final CountDownLatch countDownLatch = new CountDownLatch(threadCount);for (int i = 0; i &lt; threadCount; i++) &#123; final int threadNum = i; exec.execute(() -&gt; &#123; try &#123; test(threadNum); //需要被等待的线程执行的方法 &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125;);&#125;countDownLatch.await();123456789101112131415 CountDownLatch的await方法还有重载形式，可以设置等待的时间，如果超过此时间，计数器还未清零，则不继续等待： 1234countDownLatch.await(10, TimeUnit.MILLISECONDS);//参数1：等待的时间长度//参数2：等待的时间单位1234 AQS组件：Semaphore 用于保证同一时间并发访问线程的数目。 信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。Semaphore可以很容易控制系统中某个资源被同时访问的线程个数。 在数据结构中我们学过链表，链表正常是可以保存无限个节点的，而Semaphore可以实现有限大小的列表。 使用场景：仅能提供有限访问的资源。比如数据库连接。 Semaphore使用acquire方法和release方法来实现控制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 1、普通调用 */try &#123; semaphore.acquire(); // 获取一个许可 test();//需要并发控制的内容 semaphore.release(); // 释放一个许可&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/** * 2、同时获取多个许可，同时释放多个许可 */ try &#123; semaphore.acquire(2); test(); semaphore.release(2);&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/* * 3、尝试获取许可，获取不到不执行 */ try &#123; if (semaphore.tryAcquire()) &#123; test(threadNum); semaphore.release(); &#125; &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;/* * 4、尝试获取许可一段时间，获取不到不执行 * 参数1：等待时间长度 参数2：等待时间单位 */try &#123; if (semaphore.tryAcquire(5000, TimeUnit.MILLISECONDS)) &#123; test(threadNum); semaphore.release(); &#125;&#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e);&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546 AQS组件：CyclicBarrier 也是一个同步辅助类，它允许一组线程相互等待，直到到达某个公共的屏障点（循环屏障） 通过它可以完成多个线程之间相互等待，只有每个线程都准备就绪后才能继续往下执行后面的操作。 每当有一个线程执行了await方法，计数器就会执行+1操作，待计数器达到预定的值，所有的线程再同时继续执行。由于计数器释放之后可以重用（reset方法），所以称之为循环屏障。 与CountDownLatch区别：1、计数器可重复用2、描述一个或多个线程等待其他线程的关系/多个线程相互等待 123456789101112131415161718192021222324252627282930313233343536373839404142//公共线程循环调用方法private static CyclicBarrier barrier = new CyclicBarrier(5);public static void main(String[] args) throws Exception &#123; ExecutorService executor = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int threadNum = i; Thread.sleep(1000); executor.execute(() -&gt; &#123; try &#123; race(threadNum); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; &#125;); &#125; executor.shutdown();&#125;//使用方法1：每个线程都持续等待private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); log.info(&quot;&#123;&#125; is ready&quot;, threadNum); barrier.await(); log.info(&quot;&#123;&#125; continue&quot;, threadNum);&#125;//使用方法2：每个线程只等待一段时间private static void race(int threadNum) throws Exception &#123; Thread.sleep(1000); try &#123; barrier.await(2000, TimeUnit.MILLISECONDS); &#125; catch (InterruptedException | BrokenBarrierException | TimeoutException e) &#123; log.warn(&quot;BarrierException&quot;, e); &#125;&#125;//使用方法3：在初始化的时候设置runnable，当线程达到屏障时优先执行runnableprivate static CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; &#123; log.info(&quot;callback is running&quot;);&#125;); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/80054133]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（十）：HashMap与ConcurrentHashMap]]></title>
    <url>%2F1e12e841.html</url>
    <content type="text"><![CDATA[摘要：如题。 概述 HashMap （1）初始化方法 （2）寻址方式 （3）HashMap的线程不安全原因一：死循环 （4）HashMap的线程不安全原因二：fail-fast ConcurrentHashMap [（1）结构 Java7与Java8不同] 对比 概述在上一节我们简略提到了ConcurrentHashMap是HashMap的线程安全类，那么这两个类的具体实现是怎样的呢？我们来了解一下。 HashMap（1）初始化方法HashMap的实现方式是：数组+链表 的形式。在HashMap中有两个参数会影响HashMap的性能：初始容量/加载因子 初始容量：Hash表中桶的数量加载因子：是Hash表在自动增加之前可以达到多满的一个尺度。 HashMap在类中定义了这两个参数: 1234//初始容量，默认16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //加载因子，默认0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;1234 这两个参数的作用是：当Hash表中的条目数量超过了加载因子与当前容量的乘积，将会调用resize()进行扩容，将容量翻倍。这两个参数在初始化HashMap的时候可以进行设置：可以单独指定初始容量，也可以同时设置 （2）寻址方式对于一个新插入的数据或者要读取的数据，HashMap将key按一定规则计算出hash值，并对数组长度进行取模结果作为在数组中查找的index。由于在计算机中取模的代价远远高于位操作的代价，因此HashMap要求数组的长度必须为2的N次方。此时它将key的hash值对2的n-1次方进行与运算，等同于取模运算。HashMap并不要求用户一定要设置一个2的N次方的初始化大小，它本身内部会通过运算（tableSizeFor方法）确定一个合理的符合2的N次方的大小去设置。 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125;123456789 （3）HashMap的线程不安全原因一：死循环原因在于HashMap在多线程情况下，执行resize()进行扩容时容易造成死循环。扩容思路为它要创建一个大小为原来两倍的数组，保证新的容量仍为2的N次方，从而保证上述寻址方式仍然适用。扩容后将原来的数组从新插入到新的数组中。这个过程称为reHash。 【单线程下的reHash】 扩容前：我们的HashMap初始容量为2，加载因子为1，需要向其中存入3个key，分别为5、9、11，放入第三个元素11的时候就涉及到了扩容。 第一步：先创建一个二倍大小的数组，接下来把原来数组中的元素reHash到新的数组中，5插入新的数组，没有问题。 第二步：将9插入到新的数组中，经过Hash计算，插入到5的后面。 第三步：将11经过Hash插入到index为3的数组节点中。 单线程reHash完全没有问题。 【多线程下的reHash】 我们假设有两个线程同时执行了put操作，并同时触发了reHash的操作，图示的上层的线程1，下层是线程2。 线程1某一时刻执行完扩容，准备将key为5的元素的next指针指向9，由于线程调度分配的时间片被用完而停在了这一步操作 线程2在这一刻执行reHash操作并执行完数据迁移的整个操作。 接下来线程1被唤醒继续操作。 执行上一轮的剩余部分，在处理key为5的元素时，将此key放在我们线程1申请的数组的索引1位置的链表的首部。理想状态是（线程1数组索引1）—&gt; (Key=5) —&gt; null 接着处理Key为9的元素，将key为9的元素插入在（索引1）与（key=5）之间，理想状态：（线程1数组索引1）—&gt; （Key=9）—&gt; （Key=5）—&gt;null 但是在处理完key为9的元素之后按理说应该结束了，但是由于线程2已经处理过了key=9与key=5的元素，即真实情况为（线程2数组索引1 —&gt;（key=9）—&gt; （key=5）—&gt; null）|（线程1数组索引1 —&gt; (key=9)—&gt; （key=5）—&gt; null），这时让线程1误以为key=9后面的key=5是从原数组还没有进行数组迁移的，接着又处理key=5。尝试将key=5放在k=9的前边，所以key=9与key=5之间就出现了一个循环。不断的被处理，交换顺序。 key = 11的元素是无法插入到新数组中的。一旦我们去从新的数组中获取值得时候，就会出现死循环。 （4）HashMap的线程不安全原因二：fail-fast如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast。在每一次对HashMap进行修改的时候，都会变动类中的modCount域，即modCount变量的值。源码中是这样实现的： 12345678910111213141516abstract class HashIterator &#123; ... int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; ...&#125;12345678910111213141516 在每次迭代的过程中，都会判断modCount跟expectedModCount是否相等，如果不相等代表有人修改HashMap。源码： 123456789101112final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e;&#125;123456789101112 解决办法：可以使用Collections的synchronizedMap方法构造一个同步的map，或者直接使用线程安全的ConcurrentHashMap来保证不会出现fail-fast策略。 ConcurrentHashMap（1）结构 [Java7与Java8不同] Java7里面的ConcurrentHashMap的底层结构仍然是数组和链表，与HashMap不同的是ConcurrentHashMap的最外层不是一个大的数组，而是一个Segment数组。每个Segment包含一个与HashMap结构差不多的链表数组。 当我们读取某个Key的时候它先取出key的Hash值，并将Hash值得高sshift位与Segment的个数取模，决定key属于哪个Segment。接着像HashMap一样操作Segment。 为了保证不同的Hash值保存到不同的Segment中，ConcurrentHashMap对Hash值也做了专门的优化。 Segment继承自J.U.C里的ReetrantLock，所以可以很方便的对Segment进行上锁。即分段锁。 Java8废弃了Java7中ConcurrentHashMap中分段锁的方案，并且不使用Segment，转为使用大的数组。同时为了提高Hash碰撞下的寻址做了性能优化。 Java8在列表的长度超过了一定的值（默认8）时，将链表转为红黑树实现。寻址的复杂度从O(n)转换为Olog(n)。 对比 HashMap非线程安全、ConcurrentHashMap线程安全 HashMap允许Key与Value为空，ConcurrentHashMap不允许 HashMap不允许通过迭代器遍历的同时修改，ConcurrentHashMap允许。并且更新可见 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79978855]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（九）：并发容器 J.U.C - 线程安全的集合与Map]]></title>
    <url>%2F87d3d6a5.html</url>
    <content type="text"><![CDATA[摘要：本文介绍并发容器JUC(Java.util.concurrency)：集合和Map中线程安全的替代类。 概述 ArrayList –&gt; CopyOnWriteArrayList HashSet –&gt; CopyOnWriteArraySet TreeSet –&gt; ConcurrentSkipListSet HashMap –&gt; ConcurrentHashMap TreeMap –&gt; ConcurrentSkipListMap 安全共享对象策略 概述Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即Java.util.concurrency。上一节我们介绍了ArrayList、HashMap、HashSet对应的同步容器保证其线程安全，这节我们介绍一下其对应的并发容器。 ArrayList –&gt; CopyOnWriteArrayListCopyOnWriteArrayList 写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁 缺点：1.写操作时复制消耗内存，如果元素比较多时候，容易导致young gc 和full gc。2.不能用于实时读的场景.由于复制和add操作等需要时间，故读取时可能读到旧值。能做到最终一致性，但无法满足实时性的要求，更适合读多写少的场景。如果无法知道数组有多大，或者add,set操作有多少，慎用此类,在大量的复制副本的过程中很容易出错。 设计思想：1.读写分离2.最终一致性3.使用时另外开辟空间，防止并发冲突 源码分析 12345678910111213141516171819202122232425262728293031323334//构造方法public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements;//使用对象数组来承载数据 if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements);&#125;//添加数据方法public boolean add(E e) &#123; final ReentrantLock lock = this.lock;//使用重入锁，保证线程安全 lock.lock(); try &#123; Object[] elements = getArray();//获取当前数组数据 int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//复制当前数组并且扩容+1 newElements[len] = e;//将要添加的数据放入新数组 setArray(newElements);//将原来的数组指向新的数组 return true; &#125; finally &#123; lock.unlock(); &#125;&#125;//获取数据方法，与普通的get没什么差别private E get(Object[] a, int index) &#123; return (E) a[index];&#125;12345678910111213141516171819202122232425262728293031323334 HashSet –&gt; CopyOnWriteArraySet 它是线程安全的，底层实现使用的是CopyOnWriteArrayList，因此它也适用于大小很小的set集合，只读操作远大于可变操作。因为他需要copy整个数组，所以包括add、remove、set它的开销相对于大一些。 迭代器不支持可变的remove操作。使用迭代器遍历的时候速度很快，而且不会与其他线程发生冲突。 源码分析： 1234567891011121314151617181920212223242526272829//构造方法public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();//底层使用CopyOnWriteArrayList&#125;//添加元素方法，基本实现原理与CopyOnWriteArrayList相同private boolean addIfAbsent(E e, Object[] snapshot) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) &#123;//添加了元素去重操作 // Optimize for lost race to another addXXX operation int common = Math.min(snapshot.length, len); for (int i = 0; i &lt; common; i++) if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i])) return false; if (indexOf(e, current, common, len) &gt;= 0) return false; &#125; Object[] newElements = Arrays.copyOf(current, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;1234567891011121314151617181920212223242526272829 TreeSet –&gt; ConcurrentSkipListSet它是JDK6新增的类，同TreeSet一样支持自然排序，并且可以在构造的时候自己定义比较器。 同其他set集合，是基于map集合的（基于ConcurrentSkipListMap），在多线程环境下，里面的contains、add、remove操作都是线程安全的。 多个线程可以安全的并发的执行插入、移除、和访问操作。但是对于批量操作addAll、removeAll、retainAll和containsAll并不能保证以原子方式执行，原因是addAll、removeAll、retainAll底层调用的还是contains、add、remove方法，只能保证每一次的执行是原子性的，代表在单一执行操纵时不会被打断，但是不能保证每一次批量操作都不会被打断。在使用批量操作时，还是需要手动加上同步操作的。 不允许使用null元素的，它无法可靠的将参数及返回值与不存在的元素区分开来。 源码分析： 1234//构造方法public ConcurrentSkipListSet() &#123; m = new ConcurrentSkipListMap&lt;E,Object&gt;();//使用ConcurrentSkipListMap实现&#125;1234 HashMap –&gt; ConcurrentHashMap 不允许空值，在实际的应用中除了少数的插入操作和删除操作外，绝大多数我们使用map都是读取操作。而且读操作大多数都是成功的。基于这个前提，它针对读操作做了大量的优化。因此这个类在高并发环境下有特别好的表现。 ConcurrentHashMap作为Concurrent一族，其有着高效地并发操作，相比Hashtable的笨重，ConcurrentHashMap则更胜一筹了。 在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。 源码分析：推荐参考chenssy的博文：J.U.C之Java并发容器：ConcurrentHashMap TreeMap –&gt; ConcurrentSkipListMap 底层实现采用SkipList跳表 曾经有人用ConcurrentHashMap与ConcurrentSkipListMap做性能测试，在4个线程1.6W的数据条件下，前者的数据存取速度是后者的4倍左右。但是后者有几个前者不能比拟的优点：1、Key是有序的2、支持更高的并发，存储时间与线程数无关 安全共享对象策略 线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改 共享只读：一个共享只读的U帝乡，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它 线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保障线程安全，多以其他线程无需额外的同步就可以通过公共接口随意访问他 被守护对象：被守护对象只能通过获取特定的锁来访问。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79947616]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（八）：线程不安全类、同步容器]]></title>
    <url>%2F92dea4ff.html</url>
    <content type="text"><![CDATA[摘要：本文介绍线程不安全的类和同步容器 1、线程不安全的类 （1）StringBuilder 与 StringBuffer （2）SimpleDateFormat 与 jodatime插件 （3）ArrayList,HashSet,HashMap 等Collection类 2、同步容器 （1）ArrayList的线程安全类：Vector,Stack （2）HashMap的线程安全类：HashTable （3）Collections类中的相关同步方法 1、线程不安全的类如果一个类的对象同时可以被多个线程访问，并且你不做特殊的同步或并发处理，那么它就很容易表现出线程不安全的现象。比如抛出异常、逻辑处理错误…下面列举一下常见的线程不安全的类及对应的线程安全类： （1）StringBuilder 与 StringBufferStringBuilder是线程不安全的，而StringBuffer是线程安全的。分析源码：StringBuffer的方法使用了synchronized关键字修饰。 123456@Overridepublic synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this;&#125;123456 （2）SimpleDateFormat 与 jodatime插件SimpleDateFormat 类在处理时间的时候，如下写法是线程不安全的： 12345678910private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);//线程调用方法private static void update() &#123; try &#123; simpleDateFormat.parse(&quot;20180208&quot;); &#125; catch (Exception e) &#123; log.error(&quot;parse exception&quot;, e); &#125;&#125;12345678910 但是我们可以变换其为线程安全的写法：在每次转换的时候使用线程封闭，新建变量 12345678private static void update() &#123; try &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;); simpleDateFormat.parse(&quot;20180208&quot;); &#125; catch (Exception e) &#123; log.error(&quot;parse exception&quot;, e); &#125;&#125;12345678 另外我们也可以使用jodatime插件来转换时间：其可以保证线程安全性Joda 类具有不可变性，因此它们的实例无法被修改。（不可变类的一个优点就是它们是线程安全的） 12345private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyyMMdd&quot;);private static void update(int i) &#123; log.info(&quot;&#123;&#125;, &#123;&#125;&quot;, i, DateTime.parse(&quot;20180208&quot;, dateTimeFormatter).toDate());&#125;12345 分析源码：（不可变性） 123456789101112131415161718192021222324252627public class DateTimeFormatter &#123; //均使用final声明 private final InternalPrinter iPrinter; private final InternalParser iParser; private final Locale iLocale; private final boolean iOffsetParsed; private final Chronology iChrono; private final DateTimeZone iZone; private final Integer iPivotYear; private final int iDefaultYear; ... private InternalParser requireParser() &#123; InternalParser var1 = this.iParser; if (var1 == null) &#123; throw new UnsupportedOperationException(&quot;Parsing not supported&quot;); &#125; else &#123; return var1; &#125; &#125; public DateTime parseDateTime(String var1) &#123; InternalParser var2 = this.requireParser(); Chronology var3 = this.selectChronology((Chronology)null); DateTimeParserBucket var4 = new DateTimeParserBucket(0L, var3, this.iLocale, this.iPivotYear, this.iDefaultYear); ... &#125;123456789101112131415161718192021222324252627 （3）ArrayList,HashSet,HashMap 等Collection类像ArrayList,HashSet,HashMap 等Collection类均是线程不安全的，我们以ArrayList举例分析一下源码：1、ArrayList的基本属性：在声明时使用了transient 关键字，此关键字意为在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。而ArrayList实现了序列化接口，自己定义了序列化方法（在此不描述）。 123456//对象数组：ArrayList的底层数据结构private transient Object[] elementData;//elementData中已存放的元素的个数private int size;//默认数组容量private static final int DEFAULT_CAPACITY = 10;123456 2、初始化 12345678910111213141516/** * 创建一个容量为initialCapacity的空的（size==0）对象数组 */ public ArrayList(int initialCapacity) &#123; super();//即父类protected AbstractList() &#123;&#125; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity:&quot; + initialCapacity); this.elementData = new Object[initialCapacity];&#125;/** * 默认初始化一个容量为10的对象数组 */ public ArrayList() &#123; this(10); &#125;12345678910111213141516 3、添加方法（重点） 123456789101112131415161718//每次添加时将数组扩容1，然后再赋值public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;123456789101112131415161718 4、总结：ArrayList每次对内容进行插入操作的时候，都会做扩容处理，这是ArrayList的优点（无容量的限制），同时也是缺点，线程不安全。（以下例子取材于鱼笑笑博客）一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成： 在 Items[Size] 的位置存放此元素； 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 那么如何将其处理为线程安全的？或者说对应的线程安全类有哪些呢？接下来就涉及到我们同步容器。 2、同步容器同步容器分两类，一种是Java提供好的类，另一类是Collections类中的相关同步方法。 （1）ArrayList的线程安全类：Vector,StackVector实现了List接口，Vector实际上就是一个数组，和ArrayList非常的类似，但是内部的方法都是使用synchronized修饰过的方法。Stack它的方法也是使用synchronized修饰了，继承了Vector，实际上就是栈使用举例（Vector）： 123456//定义private static List&lt;Integer&gt; list = new Vector&lt;&gt;();//多线程调用方法private static void update(int i) &#123; list.add(i);&#125;123456 源码分析：使用了synchronized修饰 123456public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;123456 但是Vector也不是完全的线程安全的，比如：错误[1]：删除与获取并发操作 1234567891011121314151617181920212223242526272829public class VectorExample &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 10; i++) &#123; vector.add(i); &#125; Thread thread1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125; &#125;; Thread thread2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; &#125; &#125;; thread1.start(); thread2.start(); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829 运行结果：报错java.lang.ArrayIndexOutOfBoundsException: Array index out of range原因分析：同时发生获取与删除的操作。当两个线程在同一时间都判断了vector的size，假设都判断为9，而下一刻线程1执行了remove操作，随后线程2才去get，所以就出现了错误。synchronized关键字可以保证同一时间只有一个线程执行该方法，但是多个线程同时分别执行remove、add、get操作的时候就无法控制了。 错误[2]：使用foreach\iterator遍历Vector的时候进行增删操作 123456789101112131415161718192021222324252627282930313233343536373839public class VectorExample3 &#123; // 报错java.util.ConcurrentModificationException private static void test1(Vector&lt;Integer&gt; v1) &#123; // foreach for(Integer i : v1) &#123; if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // 报错java.util.ConcurrentModificationException private static void test2(Vector&lt;Integer&gt; v1) &#123; // iterator Iterator&lt;Integer&gt; iterator = v1.iterator(); while (iterator.hasNext()) &#123; Integer i = iterator.next(); if (i.equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; // success private static void test3(Vector&lt;Integer&gt; v1) &#123; // for for (int i = 0; i &lt; v1.size(); i++) &#123; if (v1.get(i).equals(3)) &#123; v1.remove(i); &#125; &#125; &#125; public static void main(String[] args) &#123; Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); vector.add(1); vector.add(2); vector.add(3); test1(vector); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839 解决办法：在使用iteratir进行增删操作的时候，加上Lock或者synchronized同步措施或者并发容器 （2）HashMap的线程安全类：HashTable使用举例: 123456//定义private static Map&lt;Integer, Integer&gt; map = new Hashtable&lt;&gt;();//多线程调用方法private static void update(int i) &#123; map.put(i, i);&#125;123456 源码分析： 保证安全性：使用了synchronized修饰 不允许空值（在代码中特殊做了判断） HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。 Entry对象唯一表示一个键值对，有四个属性：-K key 键对象-V value 值对象-int hash 键对象的hash值-Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部 1234567891011121314151617181920212223public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(&quot;unchecked&quot;) Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125;1234567891011121314151617181920212223 （3）Collections类中的相关同步方法Collections类中提供了一系列的线程安全方法用于处理ArrayList等线程不安全的Collection类 使用方法： 123456//定义private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());//多线程调用方法private static void update(int i) &#123; list.add(i);&#125;123456 源码分析：内部操作的方法使用了synchronized修饰符 123456789101112131415161718static class SynchronizedList&lt;E&gt; extends SynchronizedCollection&lt;E&gt; implements List&lt;E&gt; &#123; ... public E get(int index) &#123; synchronized (mutex) &#123;return list.get(index);&#125; &#125; public E set(int index, E element) &#123; synchronized (mutex) &#123;return list.set(index, element);&#125; &#125; public void add(int index, E element) &#123; synchronized (mutex) &#123;list.add(index, element);&#125; &#125; public E remove(int index) &#123; synchronized (mutex) &#123;return list.remove(index);&#125; &#125; ...&#125; 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79923837]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（七）：线程封闭 - ThreadLocal]]></title>
    <url>%2F36e8f52e.html</url>
    <content type="text"><![CDATA[摘要：本文介绍什么是线程封闭，线程封闭的种类，Springboot框架中使用ThreadLocal。 1、什么是线程封闭？它其实就是把对象封装到一个线程里，只有一个线程能看到这个对象，那么这个对象就算不是线程安全的，也不会出现任何线程安全方面的问题。 线程封闭技术有一个常见的应用： 数据库连接对应jdbc的Connection对象，Connection对象在实现的时候并没有对线程安全做太多的处理，jdbc的规范里也没有要求Connection对象必须是线程安全的。实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。 2、线程封闭的种类：（1）Ad-hoc 线程封闭： Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象（例如，GUI应用程序中的可视化组件或数据模型等）的引用通常保存在公有变量中。 （2）堆栈封闭：堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，方法中的局部变量都会被拷贝一份到线程的栈中（Java内存模型），所以局部变量是不会被多个线程所共享的。 （3）ThreadLocal线程封闭：它是一个特别好的封闭方法，其实ThreadLocal内部维护了一个map,map的key是每个线程的名称，而map的value就是我们要封闭的对象。ThreadLocal提供了get、set、remove方法，每个操作都是基于当前线程的，所以它是线程安全的。 1234567891011121314//ThreadLocal的get方法源码public T get() &#123; Thread t = Thread.currentThread();//当前线程对象 ThreadLocalMap map = getMap(t);//get操作基于当前线程 if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;1234567891011121314 3、Springboot框架中使用ThreadLocal说明：1、这里不描述springboot框架的搭建过程，假定你已经有了一个可以正常运行的springboot简单项目。2、我们这里的例子使用的是springboot框架中的filter与Interceptor来使用threadLocal，对于Springboot的filter与Interceptor不做过多的讲解。 coding：（1）创建一个包含ThreadLocal对象的类，并提供基础的添加、删除、获取操作。 12345678910111213141516public class RequestHolder &#123; private final static ThreadLocal&lt;Long&gt; requestHolder = new ThreadLocal&lt;&gt;(); public static void add(Long id) &#123; requestHolder.set(id); &#125; public static Long getId() &#123; return requestHolder.get(); &#125; public static void remove() &#123; requestHolder.remove(); &#125;&#125;12345678910111213141516 （2）创建Filter，在Filter中对ThreadLocal做添加操作。 123456789101112131415161718192021222324public class HttpFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; //打印当前线程的ID与请求路径 log.info(&quot;do filter, &#123;&#125;, &#123;&#125;&quot;, Thread.currentThread().getId(), request.getServletPath()); //将当前线程ID添加到ThreadLocal中 RequestHolder.add(Thread.currentThread().getId()); filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125;123456789101112131415161718192021222324 （3)创建controller，在controller中获取到filter中存入的值 1234567891011@Controller@RequestMapping(&quot;/threadLocal&quot;)public class ThreadLocalController &#123; @RequestMapping(&quot;/test&quot;) @ResponseBody public Long test() &#123; return RequestHolder.getId(); &#125;&#125;1234567891011 （4）创建拦截器Interceptor，在拦截器中删除刚才添加的值 123456789101112131415161718public class HttpInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; log.info(&quot;preHandle&quot;); return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; RequestHolder.remove(); log.info(&quot;afterCompletion&quot;); return; &#125;&#125;123456789101112131415161718 （5）在springboot的启动类Application中注册filter与Interceptor。要继承WebMvcConfigurerAdapter 类。（我这里的启动类名为：ConcurrencyApplication） 1234567891011121314151617181920212223@SpringBootApplicationpublic class ConcurrencyApplication extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; SpringApplication.run(ConcurrencyApplication.class, args); &#125; //注册过滤器 @Bean public FilterRegistrationBean httpFilter() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new HttpFilter()); //设置要过滤的url registrationBean.addUrlPatterns(&quot;/threadLocal/*&quot;); return registrationBean; &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new HttpInterceptor()).addPathPatterns(&quot;/**&quot;); &#125;&#125;1234567891011121314151617181920212223 （6）运行程序，访问 http://localhost:8080/threadLocal/test 结果如下： 页面中打印出我们当前的线程ID： 查看控制台：从控制台的打印日志我们可以看出，首先filter过滤器先获取到我们当前的线程ID为40、我们当前的请求路径为/threadLocal/test ，紧接着进入了我们的Interceptor的preHandle方法中，打印了preHandle字样。最后进入了我们的Interceptor的afterCompletion方法，删除了我们之前存入的值，并打印了afterCompletion字样。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79902773]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（六）：不可变对象 -final -ImmutableX -unmodifiableX]]></title>
    <url>%2Fe471f102.html</url>
    <content type="text"><![CDATA[摘要：不可变对象一定是线程安全的，但是线程安全的对象不一定是不可变对象。本文介绍不可变对象的概率，如何创建一个不可变对象，final关键字，Java:unmodifiable相关方法和Google的Guava。 1、不可变对象有一种对象只要它发布了就是安全的，它就是不可变对象。一个不可变对象需要满足的条件： 对象创建一个其状态不能修改 对象所有域都是final类型 对象是正确创建的(在对象创建期间，this引用没有逸出) 2、创建一个不可变对象的方法（1）自己定义这里可以采用的方式包括：1、将类声明为final，这样它就不能被继承。2、将所有的成员声明为私有的，这样就不允许直接访问这些成员。3、对变量不提供set方法，将所有可变的成员声明为final，这样就只能赋值一次。通过构造器初始化所有成员进行深度拷贝。4、在get方法中不直接返回对象的本身，而是克隆对象，返回对象的拷贝。 （2）使用Java中提供的Collection类中的各种unmodifiable开头的方法（3）使用Guava中的Immutable开头的类 3、final关键字final关键字可以修饰类、修饰方法、修饰变量 修饰类：类不能被集成。基础类型的包装类都是final类型的类。final类中的成员变量可以根据需要设置为final，但是要注意的是，final类中的所有成员方法都会被隐式的指定为final方法 修饰方法：(1)把方法锁定，以防任何继承类修改它的含义(2)效率：在早期的java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不见效果。一个private方法会被隐式的指定为final方法 修饰变量：基本数据类型变量，在初始化之后，它的值就不能被修改了。如果是引用类型变量，在它初始化之后便不能再指向另外的对象。 从上图我们可见，（1）对一个被final修饰的变量（Integer a、String b）被赋值时在编译过程中就出现了错误。（2）（map）在重新被指向一个新的map对象的时候也出现了错误。那么对被定义为final的map进行赋值呢？我们单独运行map.put(1,3)语句，结果是可以的。被final修饰的引用类型变量，虽然不能重新指向，但是可以修改,这一点尤为要注意。（3）当final修饰方法的参数时：同样也是不允许在方法内部对其修改的。 4、Java:unmodifiable相关方法使用Java的Collection类的unmodifiable相关方法，可以创建不可变对象。unmodifiable相关方法包含：Collection、List、Map、Set….举个栗子： 1234567891011121314151617public class ImmutableExample &#123; private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap(); static &#123; map.put(1, 2); map.put(3, 4); map.put(5, 6); map = Collections.unmodifiableMap(map); &#125; public static void main(String[] args) &#123; map.put(1, 3); log.info(&quot;&#123;&#125;&quot;, map.get(1)); &#125;&#125;1234567891011121314151617 上面程序的执行结果为：在map.put（1，3）操作的位置抛出了异常。由此可见map对象已经成为不可变对象。 那么unmodifiable相关类的实现原理是什么呢？我们查看一下Collections.unmodifiableMap的源码：（以下源码只筛选出表达观点的部分，非全部） 12345678910public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) &#123; return new UnmodifiableMap&lt;&gt;(m);&#125;private static class UnmodifiableMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; ... public V put(K key, V value) &#123; throw new UnsupportedOperationException(); &#125; ...&#125;12345678910 Collections.unmodifiableMap在执行时，将参数中的map对象进行了转换，转换为Collection类中的内部类 UnmodifiableMap对象。而 UnmodifiableMap对map的更新方法（比如put、remove等）进行了重写，均返回UnsupportedOperationException异常，这样就做到了map对象的不可变。 5、Guava:Immutable相关类使用Guava的Immutable相关类也可以创建不可变对象。同样包含很多类型：Collection、List、Map、Set….举栗子：（1）ImmutableList 123private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);list.add(4);//这一句在书写完就会被IDE提示该add方法为过时方法，实际为不可用方法123 对于ImmutableList.of方法，如果传多个参数，需要这样一直写下去，以逗号分隔每个参数。其源码中是这样实现的： 1234567891011121314151617181920212223242526272829303132333435363738//单个或少于12个参数时public static &lt;E&gt; ImmutableList&lt;E&gt; of() &#123; return RegularImmutableList.EMPTY;&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E element) &#123; return new SingletonImmutableList(element);&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2) &#123; return construct(e1, e2);&#125;public static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3) &#123; return construct(e1, e2, e3);&#125;....//多于12个参数时，参数列表中最后的E...other会以数组形式接收参数@SafeVarargspublic static &lt;E&gt; ImmutableList&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5, E e6, E e7, E e8, E e9, E e10, E e11, E e12, E... others) &#123; Object[] array = new Object[12 + others.length]; array[0] = e1; array[1] = e2; array[2] = e3; array[3] = e4; array[4] = e5; array[5] = e6; array[6] = e7; array[7] = e8; array[8] = e9; array[9] = e10; array[10] = e11; array[11] = e12; System.arraycopy(others, 0, array, 12, others.length); return construct(array);&#125;1234567891011121314151617181920212223242526272829303132333435363738 运行结果仍然为抛出UnsupportedOperationException异常。分析源码：Immutable相关类使用了跟Java的unmodifiable相关类相似的实现方法。 123456/** @deprecated */ @Deprecated @CanIgnoreReturnValue public final boolean add(E e) &#123; throw new UnsupportedOperationException(); &#125;123456 （2）ImmutableSetImmutableSet除了使用of的方法进行初始化，还可以使用copyof方法，将Collection类型、Iterator类型作为参数。 123private final static ImmutableSet set = ImmutableSet.copyOf(list);private final static ImmutableSet set = ImmutableSet.copyOf(list.iterator());123 （3）ImmutableMapImmutableMap有特殊的builder写法： 1234private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder() .put(1, 2).put(3, 4).put(5, 6).build(); 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79897550]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（五）：安全发布对象与多种单例模式]]></title>
    <url>%2Fdcfa5a09.html</url>
    <content type="text"><![CDATA[摘要：本文介绍安全发布对象的概念，代码演示，对象逃逸与多种单例模式 概念 发布对象 对象逸出 代码演示 不安全发布对象 对象逸出 安全发布对象示例（多种单例模式演示） 1、懒汉式（最简式） 2、懒汉式（synchronized） 3、双重同步锁模式【先入坑再出坑】 4、饿汉式（最简式） 5、饿汉式（静态块初始化） 6、枚举式 概念发布对象使一个对象能够被当前范围之外的代码所使用。在我们的日常开发中，我们经常要发布一些对象，比如通过类的非私有方法返回对象的引用，或者通过公有静态变量发布对象。 对象逸出一种错误的发布。当一个对象还没有构造完成时，就使它被其他线程所见。 代码演示不安全发布对象1234567891011121314151617public class UnsafePublish &#123; private String[] states = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;; //类的非私有方法，返回私有对象的引用 public String[] getStates() &#123; return states; &#125; public static void main(String[] args) &#123; UnsafePublish unsafePublish = new UnsafePublish(); log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); unsafePublish.getStates()[0] = &quot;d&quot;; log.info(&quot;&#123;&#125;&quot;, Arrays.toString(unsafePublish.getStates())); &#125;&#125;1234567891011121314151617 分析： 这个代码通过public访问级别发布了类的域，在类的任何外部的线程都可以访问这些域 我们无法保证其他线程会不会修改这个域，从而使私有域内的值错误（上述代码中就对私有域进行了修改） 对象逸出123456789101112131415161718192021public class Escape &#123; private Integer thisCanBeEscape = 0; public Escape () &#123; new InnerClass(); thisCanBeEscape = null; &#125; //内部类构造方法调用外部类的私有域 private class InnerClass &#123; public InnerClass() &#123; log.info(&quot;&#123;&#125;&quot;, Escape.this.thisCanBeEscape); &#125; &#125; public static void main(String[] args) &#123; new Escape(); &#125;&#125;123456789101112131415161718192021 分析： 这个内部类的实例里面包含了对封装实例的私有域对象的引用，在对象没有被正确构造完成之前就会被发布，有可能有不安全的因素在里面，会导致this引用在构造期间溢出的错误。 上述代码在函数构造过程中启动了一个线程。无论是隐式的启动还是显式的启动，都会造成这个this引用的溢出。新线程总会在所属对象构造完毕之前就已经看到它了。 因此要在构造函数中创建线程，那么不要启动它，而是应该采用一个专有的start或者初始化的方法统一启动线程 这里其实我们可以采用工厂方法和私有构造函数来完成对象创建和监听器的注册等等，这样才可以避免错误 ——————————————————————————————————————————————————- 如果不正确的发布对象会导致两种错误：（1）发布线程意外的任何线程都可以看到被发布对象的过期的值（2）线程看到的被发布线程的引用是最新的，然而被发布对象的状态却是过期的 安全发布对象示例（多种单例模式演示）如何安全发布对象？共有四种方法 1、在静态初始化函数中初始化一个对象引用 2、将对象的引用保存到volatile类型域或者AtomicReference对象中 3、将对象的引用保存到某个正确构造对象的final类型域中 4、将对象的引用保存到一个由锁保护的域中 下面我们用各种单例模式来演示其中的几种方法 1、懒汉式（最简式）12345678910111213141516public class SingletonExample &#123; //私有构造函数 private SingletonExample()&#123; &#125; //单例对象 private static SingletonExample instance = null; //静态工厂方法 public static SingletonExample getInstance()&#123; if(instance==null)&#123; return new SingletonExample(); &#125; return instance; &#125;&#125;12345678910111213141516 分析：1、在多线程环境下，当两个线程同时访问这个方法，同时制定到instance==null的判断。都判断为null，接下来同时执行new操作。这样类的构造函数被执行了两次。一旦构造函数中涉及到某些资源的处理，那么就会发生错误。所以说最简式是线程不安全的 2、懒汉式（synchronized）12在类的静态方法上使用synchronized修饰 public static synchronized SingletonExample getInstance()12 分析：1、使用synchronized修饰静态方法后，保证了方法的线程安全性，同一时间只有一个线程访问该方法2、有缺陷：会造成性能损耗 3、双重同步锁模式【先入坑再出坑】12345678910111213141516171819public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = null; // 静态的工厂方法 public static SingletonExample getInstance() &#123; if (instance == null) &#123; // 双重检测机制 synchronized (SingletonExample.class) &#123; // 同步锁 if (instance == null) &#123; instance = new SingletonExample(); &#125; &#125; &#125; return instance; &#125;&#125;12345678910111213141516171819 （入坑）分析：1、我们将上面的第二个例子(懒汉式（synchronized))进行了改进，由synchronized修饰方法改为先判断后，再锁定整个类，再加上双重的检测机制，保证了最大程度上的避免耗损性能。2、这个方法是线程不安全的，可能大家会想在多线程情况下，只要有一个线程对类进行了上锁，那么无论如何其他线程也不会执行到new的操作上。接下来我们分析一下线程不安全的原因： 这里有一个知识点：CPU指令相关在上述代码中，执行new操作的时候，CPU一共进行了三次指令（1）memory = allocate() 分配对象的内存空间（2）ctorInstance() 初始化对象（3）instance = memory 设置instance指向刚分配的内存 在程序运行过程中，CPU为提高运算速度会做出违背代码原有顺序的优化。我们称之为乱序执行优化或者说是指令重排。那么上面知识点中的三步指令极有可能被优化为（1）（3）（2）的顺序。当我们有两个线程A与B，A线程遵从132的顺序，经过了两此instance的空值判断后，执行了new操作，并且cpu在某一瞬间刚结束指令（3），并且还没有执行指令（2）。而在此时线程B恰巧在进行第一次的instance空值判断，由于线程A执行完（3）指令，为instance分配了内存，线程B判断instance不为空，直接执行return，返回了instance，这样就出现了错误。 （出坑）解决办法： 12在对象声明时使用volatile关键字修饰，阻止CPU的指令重排。private volatile static SingletonExample instance = null;12 关于volatile如何阻止CPU指令重排，详情请见另一篇文章：高并发探索（四)：线程安全性-可见性-有序性 4、饿汉式（最简式）1234567891011121314public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = new SingletonExample(); // 静态的工厂方法 public static SingletonExample getInstance() &#123; return instance; &#125;&#125;1234567891011121314 分析：1、饿汉模式由于单例实例是在类装载的时候进行创建，因此只会被执行一次，所以它是线程安全的。2、该方法存在缺陷：如果构造函数中有着大量的事情操作要做，那么类的装载时间会很长，影响性能。如果只是做的类的构造，却没有引用，那么会造成资源浪费3、饿汉模式适用场景为：（1）私有构造函数在实现的时候没有太多的处理（2）这个类在实例化后肯定会被使用 5、饿汉式（静态块初始化）123456789101112131415161718public class SingletonExample &#123; // 私有构造函数 private SingletonExample() &#123; &#125; // 单例对象 private static SingletonExample instance = null; static &#123; instance = new SingletonExample(); &#125; // 静态的工厂方法 public static SingletonExample getInstance() &#123; return instance; &#125; public static void main(String[] args) &#123; System.out.println(getInstance().hashCode()); System.out.println(getInstance().hashCode()); &#125;&#125;123456789101112131415161718 分析：1、除了使用静态域直接初始化单例对象，还可以用静态块初始化单例对象。2、值得注意的一点是，静态域与静态块的顺序一定不要反，在写静态域和静态方法的时候，一定要注意顺序，不同的静态代码块是按照顺序执行的，它跟我们正常定义的静态方法和普通方法是不一样的。 6、枚举式1234567891011121314151617181920212223public class SingletonExample &#123; private SingletonExample() &#123; &#125; public static SingletonExample getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private enum Singleton &#123; INSTANCE; private SingletonExample singleton; Singleton() &#123; singleton = new SingletonExample(); &#125; public SingletonExample getInstance() &#123; return singleton; &#125; &#125;&#125;1234567891011121314151617181920212223 由于枚举类的特殊性，枚举类的构造函数Singleton方法只会被实例化一次，且是这个类被调用之前。这个是JVM保证的。 对比懒汉与饿汉模式，它的优势很明显。 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79866152]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（四）：线程安全性-可见性-有序性]]></title>
    <url>%2F4d4cd374.html</url>
    <content type="text"><![CDATA[摘要：本文介绍可见性及保证可见性的synchronized和volatile，有序性及如何保证有序性。 可见性什么是可见性？ 一个线程对主内存的修改可以及时的被其他线程观察到 导致共享变量在线程间不可见的原因 线程交叉执行 重排序结合线程交叉执行 共享变量更新后的值没有在工作内存与主存间及时更新 JVM处理可见性JVM对于可见性，提供了synchronized和volatile JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁是同一把锁） Volatile:通过加入内存屏障和禁止重排序优化来实现 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存。 对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量。 volatile的屏障操作都是cpu级别的。 适合状态验证，不适合累加值，volatile关键字不具有原子性举个例子：我们仍用高并发学习（二）中的例子来说明，对一个int型数值的多线程读写操作。我们将count变量用volatile来修饰： 12345678910111213141516171819202122232425262728293031323334public class CountExample &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //计数 * public static volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count); &#125; private static void add()&#123; count++; &#125;&#125;12345678910111213141516171819202122232425262728293031323334 多次运行代码我们发现：count的最终结果并不是预期的5000，而是有时为5000，但是大多数时间比5000小，这是为什么呢？原因在于对count++的操作中，jvm对count做了三步操作： 1、从主存中取出count的值放入工作变量 count2、对工作变量中的count进行+13、将工作变量中的count刷新回主存中 在单线程执行此操作绝对没有问题，但是在多线程环境中，假设有两个线程A、B同时执行count++操作，某一刻A与B同时读取主存中count的值，然后在自己线程对应的工作空间中对count+1，最后又同时将count+1的值写回主存。到此，count+1的值被写回主存两遍，所以导致最终的count值小了1。在整体程序执行过程中，该事件发生一次或多次，自然结果就不正确。那么volatile适合做什么呢？其实它比较适合做状态标记量（不会涉及到多线程同时读写的操作），而且要保证两点：（1）对变量的写操作不依赖于当前值（2）该变量没有包含在具有其他变量的不变的式子中例如： 12345678910volatile boolean inited = false;//线程一：context = loadContext();inited = true;//线程二：while（!inited）&#123; sleep();&#125;doSomethingWithConfig(context);12345678910 有序性什么是有序性？Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。关于重排序，详情见：高并发学习（二）– 4、乱序执行优化 java中保证有序性java提供了 volatile、synchronized、Lock可以用来保证有序性另外，java内存模型具备一些先天的有序性，即不需要任何手段就能得到保证的有序性。通常被我们成为happens-before原则（先行发生原则）。如果两个线程的执行顺序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机就可以对它们进行重排序。 【以下规则来自于《深入理解java虚拟机》】 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作（重要） 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C —————————————————————————————————————————————— 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79848032]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（三）：线程安全性-原子性-CAS（CAS的ABA问题）]]></title>
    <url>%2F922ce624.html</url>
    <content type="text"><![CDATA[摘要：本文介绍线程的安全性，原子性，java.lang.Number包下的类与CAS操作，synchronized锁，和原子性操作各方法间的对比。 线程安全性 线程安全？ 线程安全性？ 原子性 Atomic包中的类与CAS： AtomicInteger AtomicLong 与 LongAdder AtomicBoolean AtomicIntegerFieldUpdater AtomicStampReference与CAS的ABA问题 AtomicLongArray synchronized synchronized 修饰一个代码块 synchronized 修饰一个方法 synchronized 修饰一个静态方法 synchronized 修饰一个类 原子性操作各方法间的对比 线程安全？当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些进程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。 线程安全性？线程安全性主要体现在三个方面：原子性、可见性、有序性 原子性:提供了互斥访问，同一时刻只能有一个线程来对它进行操作 可见性:一个线程对主内存的修改可以及时的被其他线程观察到 有序性:一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。 基础代码：以下代码用于描述下方的知识点，所有代码均在此代码基础上进行修改。 12345678910111213141516171819202122232425262728293031323334public class CountExample &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //变量声明：计数 public static AtomicInteger count = new AtomicInteger(0); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count.get());//变量取值 &#125; private static void add()&#123; count.incrementAndGet();//变量操作 &#125;&#125;12345678910111213141516171819202122232425262728293031323334 原子性说到原子性，一共有两个方面需要学习一下，一个是JDK中已经提供好的Atomic包，他们均使用了CAS完成线程的原子性操作，另一个是使用锁的机制来处理线程之间的原子性。锁包括：synchronized、Lock Atomic包中的类与CAS：我们从最简单的AtomicInteger类来了解什么是CAS AtomicInteger上边的示例代码就是通过AtomicInteger类保证了线程的原子性。那么它是如何保证原子性的呢？我们接下来分析一下它的源码。示例中，对count变量的+1操作，采用的是incrementAndGet方法，此方法的源码中调用了一个名为unsafe.getAndAddInt的方法 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;123 而getAndAddInt方法的具体实现为： 1234567public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;1234567 在此方法中，方法参数为要操作的对象Object var1、期望底层当前的数值为var2、要修改的数值var4。定义的var5为真正从底层取出来的值。采用do..while循环的方式去获取底层数值并与期望值进行比较，比较成功才将值进行修改。而这个比较再进行修改的方法就是compareAndSwapInt就是我们所说的CAS，它是一系列的接口，比如下面罗列的几个接口。使用native修饰，是底层的方法。CAS取的是compareAndSwap三个单词的首字母. 另外，示例代码中的count可以理解为JMM中的工作内存，而这里的底层数值即为主内存，如果看过我上一篇文章的盆友就能把这一块的知识点串联起来了。 123public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);123 AtomicLong 与 LongAdderLongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。首先看一下代码实现： 1234567891011121314AtomicLong：//变量声明public static AtomicLong count = new AtomicLong(0);//变量操作count.incrementAndGet();//变量取值count.get();1234567LongAdder：//变量声明public static LongAdder count = new LongAdder();//变量操作count.increment();//变量取值count1234567 那么问题来了，为什么有了AtomicLong还要新增一个LongAdder呢？原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。 知识点： 对于普通类型的long、double变量，JVM允许将64位的读操作或写操作拆成两个32位的操作。 LongAdder类的实现核心是将热点数据分离，比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。 1234567891011121314源码：public void increment() &#123; add(1L);&#125;public void add(long x) &#123; Cell[] as; long b, v; int m; Cell a; if ((as = cells) != null || !casBase(b = base, b + x)) &#123; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) longAccumulate(x, null, uncontended); &#125;&#125;1234567891011121314 缺点：如果在统计的时候，如果有并发更新，可能会有统计数据有误差。实际使用中在处理高并发计数的时候优先使用LongAdder，而不是AtomicLong在线程竞争很低的时候，使用AtomicLong会简单效率更高一些。比如序列号生成（准确性） AtomicBoolean这个类中值得一提的是它包含了一个名为compareAndSet的方法，这个方法可以做到的是控制一个boolean变量在一件事情执行之前为false，事情执行之后变为true。或者也可以理解为可以控制某一件事只让一个线程执行，并仅能执行一次。他的源码如下： 12345public final boolean compareAndSet(boolean expect, boolean update) &#123; int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u);&#125;12345 举例说明： 12345678910111213141516171819202122232425262728293031323334353637 //是否发生过 private static AtomicBoolean isHappened = new AtomicBoolean(false); // 请求总数 public static int clientTotal = 5000; // 同时并发执行的线程数 public static int threadTotal = 200; public static void main(String[] args) throws Exception &#123; ExecutorService executorService = Executors.newCachedThreadPool(); final Semaphore semaphore = new Semaphore(threadTotal); final CountDownLatch countDownLatch = new CountDownLatch(clientTotal); for (int i = 0; i &lt; clientTotal ; i++) &#123; executorService.execute(() -&gt; &#123; try &#123; semaphore.acquire(); test(); semaphore.release(); &#125; catch (Exception e) &#123; log.error(&quot;exception&quot;, e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); log.info(&quot;isHappened:&#123;&#125;&quot;, isHappened.get()); &#125; private static void test() &#123; if (isHappened.compareAndSet(false, true)) &#123;//控制某有一段代码只执行一次 log.info(&quot;execute&quot;); &#125; &#125;结果：(log只打印一次)[pool-1-thread-2] INFO com.superboys.concurrency.example.Atomic.AtomicExample6 - execute[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample6 - isHappened:true12345678910111213141516171819202122232425262728293031323334353637 AtomicIntegerFieldUpdater这个类的核心作用是要更新一个指定的类的某一个字段的值。并且这个字段一定要用volatile修饰同时还不能是static的。举例说明： 123456789101112131415161718192021222324252627282930@Slf4jpublic class AtomicExample5 &#123; //原子性更新某一个类的一个实例 private static AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater = AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class,&quot;count&quot;); @Getter public volatile int count = 100;//必须要volatile标记，且不能是static public static void main(String[] args) &#123; AtomicExample5 example5 = new AtomicExample5(); if(updater.compareAndSet(example5,100,120))&#123; log.info(&quot;update success 1,&#123;&#125;&quot;,example5.getCount()); &#125; if(updater.compareAndSet(example5,100,120))&#123; log.info(&quot;update success 2,&#123;&#125;&quot;,example5.getCount()); &#125;else&#123; log.info(&quot;update failed,&#123;&#125;&quot;,example5.getCount()); &#125; &#125;&#125;此方法输出的结果为：[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample5 - update success 1,120[main] INFO com.superboys.concurrency.example.Atomic.AtomicExample5 - update failed,120由此可见，count的值只修改了一次。123456789101112131415161718192021222324252627282930 AtomicStampReference与CAS的ABA问题什么是ABA问题？CAS操作的时候，其他线程将变量的值A改成了B，但是随后又改成了A，本线程在CAS方法中使用期望值A与当前变量进行比较的时候，发现变量的值未发生改变，于是CAS就将变量的值进行了交换操作。但是实际上变量的值已经被其他的变量改变过，这与设计思想是不符合的。所以就有了AtomicStampReference。 12345678910111213141516171819202122232425262728293031源码：private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125;private volatile Pair&lt;V&gt; pair;private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); &#125;public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; //排除新的引用和新的版本号与底层的值相同的情况 newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125;12345678910111213141516171819202122232425262728293031 AtomicStampReference的处理思想是，每次变量更新的时候，将变量的版本号+1，之前的ABA问题中，变量经过两次操作以后，变量的版本号就会由1变成3，也就是说只要线程对变量进行过操作，变量的版本号就会发生更改。从而解决了ABA问题。 解释一下上边的源码：类中维护了一个volatile修饰的Pair类型变量current，Pair是一个私有的静态类，current可以理解为底层数值。compareAndSet方法的参数部分分别为期望的引用、新的引用、期望的版本号、新的版本号。return的逻辑为判断了期望的引用和版本号是否与底层的引用和版本号相符，并且排除了新的引用和新的版本号与底层的值相同的情况（即不需要修改）的情况（return代码部分3、4行）。条件成立，执行casPair方法，调用CAS操作。 AtomicLongArray这个类实际上维护了一个Array数组，我们在对数值进行更新的时候，会多一个索引值让我们更新。 原子性，提供了互斥访问，同一时刻只能有一个线程来对它进行操作。那么在java里，保证同一时刻只有一个线程对它进行操作的，除了Atomic包之外，还有锁的机制。JDK提供锁主要分为两种：synchronized和Lock。接下来我们了解一下synchronized。 synchronized依赖于JVM去实现锁，因此在这个关键字作用对象的作用范围内，都是同一时刻只能有一个线程对其进行操作的。synchronized是java中的一个关键字，是一种同步锁。它可以修饰的对象主要有四种： 修饰代码块:大括号括起来的代码，作用于调用的对象 修饰方法：整个方法，作用于调用的对象 ———————————————————————– 修饰静态方法：整个静态方法，作用于所有对象 修饰类：括号括起来的部分，作用于所有对象 synchronized 修饰一个代码块被修饰的代码称为同步语句块，作用的范围是大括号括起来的部分。作用的对象是调用这段代码的对象。验证： 1234567891011121314151617public class SynchronizedExample &#123; public void test(int j)&#123; synchronized (this)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; &#125; //使用线程池方法进行测试： public static void main(String[] args) &#123; SynchronizedExample example1 = new SynchronizedExample(); SynchronizedExample example2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(()-&gt; example1.test(1)); executorService.execute(()-&gt; example2.test(2)); &#125;&#125;1234567891011121314151617 结果：不同对象之间的操作互不影响 synchronized 修饰一个方法被修饰的方法称为同步方法，作用的范围是大括号括起来的部分，作用的对象是调用这段代码的对象。验证： 123456789public class SynchronizedExample public synchronized void test(int j)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; //验证方法与上面相同 ...&#125;123456789 结果：不同对象之间的操作互不影响 TIPS：如果当前类是一个父类，子类调用父类的被synchronized修饰的方法，不会携带synchronized属性，因为synchronized不属于方法声明的一部分 synchronized 修饰一个静态方法作用的范围是synchronized 大括号括起来的部分，作用的对象是这个类的所有对象。验证： 123456789public class SynchronizedExample&#123; public static synchronized void test(int j)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125; - &#123;&#125;&quot;,j,i); &#125; &#125; //验证方法与上面相同 ...&#125;123456789 结果：同一时间只有一个线程可以执行 synchronized 修饰一个类验证： 1234567891011public class SynchronizedExample&#123; public static void test(int j)&#123; synchronized (SynchronizedExample.class)&#123; for (int i = 0; i &lt; 10; i++) &#123; log.info(&quot;test - &#123;&#125;-&#123;&#125;&quot;,j,i); &#125; &#125; &#125; //验证方法与上面相同 ...&#125;1234567891011 结果：同一时间只有一个线程可以执行 原子性操作各方法间的对比 synchronized:不可中断锁，适合竞争不激烈，可读性好 Lock：可中断锁，多样化同步，竞争激烈时能维持常态 Atomic:竞争激烈时能维持常态，比Lock性能好，每次只能同步一个值 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79837508]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（二）：高并发相关基础知识 - MESI - JMM]]></title>
    <url>%2F4e44ac3.html</url>
    <content type="text"><![CDATA[摘要：本文介绍高并发的工具、基础概念、CPU多级缓存、缓存一致性原则、CPU的乱序执行优化、JMM、JMM的同步操作、同步规则以及并发的优势与风险。 高并发相关基础知识0、工具1、基础概念2、CPU多级缓存3、缓存一致性(MESI Modify|Exclusive|Share|Invalid)4、乱序执行优化5、JAVA 内存模型(JMM)6、Java内存模型-同步八种操作7、Java内存模型-同步规则8、并发的优势与风险 0、工具 Apache Bench(AB) :Apache附带的工具，测试网站性能 — ApacheBench安装及使用方法 Jmeter ： Apache组织开发的压力测试工具（比AB更强大） 代码测试方法 ：Semaphore、CountDownLatch类 Semaphore类：信号量信号量，在我们测试的过程中充当监控并发数的角色。能够维持在同一时间的请求的并发量，达到并发量上线，会阻塞进程。 CountDownLatch类：计数器向下减的闭锁 说明：假设计数器的值为3，线程A执行了await()方法之后，进入了awaiting等待状态。在其他线程的方法中执行了countDown()方法之后，计数器的值都会减一，直到计数器的值减为0，线程A的方法才继续执行。所以说，countDownLatch类可以阻塞线程执行，并且当满足指定条件后让线程继续执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @author JeffOsmond * @version V1.0 * @package com.superboys.concurrency * @description 【线程不安全】模拟示例 * @email yinjiaxing_web@163.com * @time 2018/4/3 */@NotThreadSafe@Slf4jpublic class CountExample1 &#123; //请求总数 public static int clientTotal = 5000; //同时并发执行的线程数 public static int threadTotal = 200; //计数 public static int count = 0; public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newCachedThreadPool();//创建线程池 final Semaphore semaphore = new Semaphore(threadTotal);//定义信号量，给出允许并发的数目 final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//定义计数器闭锁 for (int i = 0;i&lt;clientTotal;i++)&#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire();//判断进程是否允许被执行 add(); semaphore.release();//释放进程 &#125; catch (InterruptedException e) &#123; log.error(&quot;excption&quot;,e); &#125; countDownLatch.countDown(); &#125;); &#125; countDownLatch.await();//保证信号量减为0 executorService.shutdown();//关闭线程池 log.info(&quot;count:&#123;&#125;&quot;,count); &#125; private static void add()&#123; count++; &#125;&#125; 1、基础概念 并发:同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地还如或者换出内存，这些线程是同时”存在”的，每隔线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。 高并发:High Concurrency 是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。 2、CPU多级缓存CPU的频率太快了，快到主存跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源，所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题。CPU多级缓存配置（演变）：局部性原理：(1) 时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。(2) 空间局部性：如果某个数据被访问，那么与他相邻的数据很快也可能被访问。 3、缓存一致性(MESI Modify|Exclusive|Share|Invalid) Modify:被修改，该缓存行只被缓存在该CPU的缓存中。并且是被修改过的，因此它与主存中的数据是不一致的，该缓存行中的内存需要在未来的某个时间点写回主存，这个时间点是允许其他CPU读取主存中相应的内存之前。当这里的值被写回主存之后，该缓存行的状态将变为Excluisive. Exclusive:独享，该缓存行只被缓存在该CPU的缓存中，他是未被修改过的，是与主存中的数据一致的。他可以在任何时刻，被其他CPU读取该内存时，变成Share。当该CPU修改他的内容时，变成Modify Share：共享，意味着该缓存行可能被多个CPU进行缓存，并且各缓存中的数据与主存数据是一致的。当有一个CPU修改该缓存行的时候，其他CPU中该缓存行变成Invalid Invalid：无效 四种操作 本地读取 local read :读本地缓存 本地写入 local write : 写本地缓存 远端读取 remote rade : 将Memory中的数据读取过来 远端写入 remote write : 将数据写回Memory中缓存被修改时的情况：某一时刻缓存被CPU A 与CPU B共享，这时CPU A 要修改本地缓存的时候，会将主存的数据与CPU B在共享的数据置为无效状态。缓存由S -&gt; I 4、乱序执行优化处理器为提高运算速度而做出违背代码原有顺序的优化。举例：初始计算需求如下 预期计算流程： 实际计算流程（乱序执行优化后）： 5、JAVA 内存模型(JMM)一种规范，规范了java虚拟机与计算机内存如何协同工作的。它规定了一个线程如何和何时可以看到其他线程修改过的共享变量的值，以及在必须时如何同步地访问共享变量。 堆Heap:运行时数据区，有垃圾回收，堆的优势可以动态分配内存大小，生存期也不必事先告诉编译器，因为他是在运行时动态分配内存。缺点是由于运行时动态分配内存，所以存取速度慢一些。 栈Stack:优势存取速度快，速度仅次于计算机的寄存器。栈的数据是可以共享的，但是缺点是存在栈中数据的大小与生存期必须是确定的。主要存放基本类型变量，对象据点。要求调用栈和本地变量存放在线程栈上。 静态类型变量跟随类的定义存放在堆上。存放在堆上的对象可以被所持有对这个对象引用的线程访问。 如果两个线程同时调用了同一个对象的同一个方法，他们都会访问这个对象的成员变量。但是这两个线程都拥有的是该对象的成员变量（局部变量）的私有拷贝。—[线程封闭中的堆栈封闭] CPU Registers(寄存器):是CPU内存的基础，CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器速度远大于主存。 CPU Cache Memory(高速缓存):由于计算机的存储设备与处理器的运算速度之间有着几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存，来作为内存与处理器之间的缓冲。将运算时所使用到的数据复制到缓存中,让运算能快速的进行。当运算结束后，再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。 RAM-Main Memory(主存/内存): 当一个CPU需要读取主存的时候，他会将主存中的部分读取到CPU缓存中，甚至他可能将缓存中的部分内容读到他的内部寄存器里面，然后在寄存器中执行操作。当CPU需要将结果回写到主存的时候，他会将内部寄存器中的值刷新到缓存中，然后在某个时间点从缓存中刷回主存。 Java内存模型抽象结构：每个线程都有一个私有的本地内存，本地内存他是java内存模型的一个抽象的概念。它并不是真实存在的，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器的优化。本地内存中它存储了该线程以读或写共享变量拷贝的一个副本。 从更低的层次来说，主内存就是硬件的内存，是为了获取更高的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中，java内存模型中的线程的工作内存是CPU的寄存器和高速缓存的一个抽象的描述。而JVM的静态内存存储模型它只是对内存的一种物理划分而已。它只局限在内存，而且只局限在JVM的内存。 6、Java内存模型-同步八种操作 lock(锁定) ：作用于主内存变量，把一个变量标识为一条线程独占状态 unlock(解锁) ： 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read(读取) ： 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load(载入) ：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 use(使用) ：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 assign(赋值) ： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量 store(存储) ： 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作 write(写入) ：作用于主内存的变量中，它把store操作从工作内存中一个变量的值传送到主内存的变量中 7、Java内存模型-同步规则 如果要把一个变量从主内存中复制到工作内存，就需要按顺序的执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序的执行store和write操作。但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行 不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中 不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步回主内存中 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量早同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须是成对出现。 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock锁定，则不允许对它执行unlock操作，也不允许unlock一个被其他线程锁定的变量 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） 8、并发的优势与风险 风险： 安全性：多个线程共享数据时可能会产生于期望不相符的结果 活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁、饥饿问题 性能：线程过多时会使得CPU频繁切换，调度时间增多；同步机制；消耗过多内存。 优势： 速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程同时进行。 设计：程序设计在某些情况下更简单，也可以有更多选择 资源利用：CPU能够在等待IO的时候做一些其他的事情 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79811336]]></content>
      <categories>
        <category>高并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程入门与高并发面试（一）：详细讲解 - 网站性能测试工具Apache Bench]]></title>
    <url>%2F31ea1ae0.html</url>
    <content type="text"><![CDATA[摘要：本文介绍网站服务器效能测试工具：Apache Bench 的简介、下载、简单的使用方法和测试 1、Apache Bench 简介Apache Bench是Apache 服务器附带的工具，专门用来执行网站服务器的运行效能，特别是针对Apache 网站服务器。原本用来检测Apache网站能够提供的效能，特别是能看出Apache能提供每秒能送出多少网页。 2、Apache Bench下载我们到网站的官网去下载Apache服务器下载地址：Apache服务器下载地址下载成功后直接进行解压，无需安装即可使用（仅针对于ApacheBench而言）。 3、简单的Apache Bench使用方法 我们打开命令行界面，从命令行界面进入Apache Bench的解压路径下，进入后访问bin文件夹。 进入后我们输入基础的测试命令对接口进行测试（例如http://localhost:8080/test） ab -n 1000 -c 50 http://localhost:8080/test 这段命令的含义是对于上述接口进行1000次测试，在同一时间内允许50个并发请求，执行结果如下： 4、测试结果讲解（1）测试指令参数说明：Usage: ab [options][]hostname[:port]/path&gt;我们上述的测试指令中，options为测试指令参数，其全部指参数说明如下： Options are:（英文水平太烂，凑活看吧） 参数编码（-？） 参数名 参数说明 含义 -n requests Number of requests to perform 总请求数 -c concurrency Number of multiple requests to make at a time 并发数量 -t timelimit Seconds to max. to spend on benchmarkin ,This implies -n 50000 测试时长最大秒数 -s timeout Seconds to max. wait for each response, Default is 30 seconds 每次请求等待响应的最长时间，默认30秒 -b windowsize Size of TCP send/receive buffer, in bytes TCP发送\接收缓存大小（单位bytes） -B address Address to bind to when making outgoing connections 发送连接时绑定的地址 -p postfile File containing data to POST. Remember also to set -T 以POST方法发送文件，必须同时使用-T参数 -u putfile File containing data to PUT. Remember also to set -T 以PUT方法发送文件，必须同时使用-T参数 -T content-type Content-type header to use for POST/PUT data, eg., ‘application/x-www-form-urlencoded’, Default is ‘text/plain’ 使用POST\PUT方式时的Content-Type头，例如：’application/x-www-form-urlencoded’，默认：’text/plain’ -v verbosity How much troubleshooting info to print 设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。 -V 显示版本号并退出 -w Print out results in HTML tables 以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表 -i Use HEAD instead of GET 使用HEAD请求 -x attributes String to insert as table attributes 插入字符串作为表格属性 -y attributes String to insert as tr attributes 插入字符串作为tr属性 -z attributes String to insert as td or th attributes 插入字符串作为th属性 -C attribute Add cookie, eg. ‘Apache=1234’. (repeatable) 添加cookie，可重复 -H attribute Add Arbitrary header line, eg. ‘Accept-Encoding: gzip’, Inserted after all normal header lines. (repeatable) 添加任意的头信息，可重复 -A attribute Add Basic WWW Authentication, the attributes ,are a colon separated username and password. 添加基础的www认证、属性，是一个以冒号分割的账号与密码 -P attribute Add Basic Proxy Authentication, the attributes ,are a colon separated username and password. 添加基本的代理身份验证、属性，是一个以冒号分隔的用户名和密码。 -X proxy:port Proxyserver and port number to use 使用的代理服务和对应端口号 -V Print version number and exit 直接输出版本号退出 -k Use HTTP KeepAlive feature 使用Http KeepAlice特性 -d Do not show percentiles served table. -S Do not show confidence estimators and warnings. 不显示confidence estimators和警告 -q Do not show progress when doing more than 150 requests 当超过150个请求的时候不显示进程 -l Accept variable document length (use this for dynamic pages) 接受可变文档长度(用于动态页面) -g filename Output collected data to gnuplot format file. 以gnuplot格式文件输出收集的数据。 -e filename Output CSV file with percentages served 以CSV文件的方式输出命中的服务 -r Don’t exit on socket receive errors. 返回error时不要终端socket -m method Method name 方法名 -h Display usage information (this message) 显示使用信息 （2）返回结果的说明： 字段名 解释 Document Path 测试页面 Document Length 页面大小 Concurrency Level 并发量 Time taken for tests 整个测试持续的时间 Complete requests 完成的请求数量 Failed requests 失败的请求数量 Total transferred 所有请求的响应数据的长度总和，包括每个http响应数据的头信息和正文数据的长度，这里不包括http请求数据的长度。仅仅为WEB服务器流向用户PC的应用层数据总长度 HTML transferred 所有请求的响应数据中正文数据的总和，数量上 = Total transferred - 响应数据头信息的长度 Requests per second 吞吐率,相当于LR中的每秒事务数，后面括号中的mean表示这是一个平均值 Time per request 用户平均请求等待时间,相当于LR中的平均事务响应时间，后面括号中的mean表示这是一个平均值 Time per request 服务器平均请求等待时间,每个连接请求实际运行时间的平均值 Transfer rate （单位时间内从服务器获取的数据长度）平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题。计算公式：（Total transferred : Time taken for tests） 特别感谢：慕课网jimin老师的《Java并发编程与高并发解决方案》课程，以下知识点多数来自老师的课程内容。jimin老师课程地址：Java并发编程与高并发解决方案 经作者授权转载，原文地址：https://blog.csdn.net/jesonjoke/article/details/79806358]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
</search>
